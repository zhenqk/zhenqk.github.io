<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="程序员Tony">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://zhenqk.github.io">
    <!--SEO-->

<meta name="keywords" content="集合" />


<meta name="description" content="1.每日一考1.集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？
equals()方法。  contains() /remove()/retainsAll..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    集合(补1) |
    
    程序员Tony
</title>

<link rel="alternate" href="/atom.xml" title="程序员Tony" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>

    <header class="main-header"  style="background-image:url(
    https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1589855563474&amp;di=3aa70d773e2c49618ad522cba950a73c&amp;imgtype=0&amp;src=http%3A%2F%2Fbpic.588ku.com%2Fback_pic%2F00%2F09%2F33%2F28562e1bc3ca3a9.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Tony'>
            <img src="/img/avatar.gif" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
          <!--<h2 class="text-hide">成为自己要成为的人</h2> -->
            
            <h2>
                越简单越OK
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://zhenqk.github.io">
                        程序员Tony</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                主目录</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/工具/"><i class="fa "></i>
                                工具</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">

            <div class="row">
 
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="集合(补1)">
            
            集合(补1)
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/Java-%E5%9F%BA%E7%A1%80/">Java 基础</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2016/07/06</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>1.集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？</p>
<p>equals()方法。  contains() /remove()/retainsAll() ….</p>
<p>List：equals()方法</p>
<p>Set：(HashSet、LinkedHashSet为例)：equals()、hashCode()</p>
<p>  (TreeSet为例)：Comparable：compareTo(Object obj)</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator：compare(Object o1,Object o2)</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>ArrayList,LinkedList,Vector三者的相同点与不同点？【面试题】</li>
</ol>
<p>List  Map(多)  Set (用的少、禁飞名单 人员)<br>都实现了List接口   底层都是数组<br>查找快<br>实现方式</p>
<p>3.List 接口的常用方法有哪些？(增、删、改、查、插、长度、遍历)</p>
<p>add(Object obj)</p>
<p>remove(Object obj)/remove(int index)</p>
<p>set(int index,Object obj)</p>
<p>get(int index)</p>
<p>add(int index,Object obj)</p>
<p>size()    实际长度</p>
<p>使用Iterator;foreach;普通的for<br>4.如何使用Iterator和增强for循环遍历List。举例说明<br>5.Set存储数据的特点是什么？常见的实现类有什么？说明一下彼此的特点。<br>无需不可重复的</p>
<p>HashSet  LinkedHashSet  TreeSet</p>
<p>HashMap    LinkedHashMap   TreeMap</p>
<h2 id="2-复习-Collection及Collection的遍历"><a href="#2-复习-Collection及Collection的遍历" class="headerlink" title="2.复习:Collection及Collection的遍历"></a>2.复习:Collection及Collection的遍历</h2><p>2.Collection接口常用方法:</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_01" alt="1588293364258"></p>
<p>3.Collection集合与数组间的转换</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_02" alt="1588232608177"> String 不用加new String 就可以</p>
<p>4.使用Collection集合存储对象，要求对象所属的类满足:</p>
<p>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重 写equals(). </p>
<p>5.本章节对大家的要求:</p>
<p>层次一:选择合适的集合类去实现数据的保存，调用其内部的相关方法。<br>层次二:不同的集合类底层的数据结构为何?如何实现数据的操作的:增删改查等，|</p>
<h4 id="Collection接口与-foreach遍历"><a href="#Collection接口与-foreach遍历" class="headerlink" title="Collection接口与 foreach遍历"></a>Collection接口与 foreach遍历</h4><p>1.遍历collection的两种方式:<br>①使用迭代器Iterator<br>② foreach循环(或增强for循环)</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_03" alt="1588293947305"></p>
<p>2.java.utils包下定义的迭代器接口: Iterator<br>2.1说明:</p>
<p>●lteratr对象称为迭代器(设计模式的一种), 主要用于遍历Cllction集合中的元素。<br>●GOF给迭代器模式的定义为:提供-种方法访问一一个容器(container)对象中各个元素， 而又不需暴露该对<br>象的内部细节。迭代器模式，就是为容器而生。</p>
<p>2.2作用:遍历集合元素  Collection元素<br>2.3如何获取实例:   coll.iterator()返回一个迭代器实例<br>2.4遍历的代码实现:</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_04" alt="1588294090220"></p>
<p>2.5图示说明:</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_05" alt="1588233312775"></p>
<p>2.6 remove()的使用:</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/23_23" alt="1588233352886"></p>
<p>3.jdk5. 0新特性–增强for循环: (foreach循环)<br>1.遍历集合举例:<br><img src="/2016/07/06/2016-07-06-ji-he-bu-1/23_26" alt="1588235758885"></p>
<p>说明:<br>内部依然调用迭代器</p>
<p>2.遍历数组举例:<img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_06" alt="1588294337913"></p>
<h2 id="3-复习-List接口"><a href="#3-复习-List接口" class="headerlink" title="3.复习:List接口"></a>3.复习:List接口</h2><p>1.存储的数据特点:<br>|—-Collection接口：单列集合，用来存储一个一个的对象<br>|—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组,替换原有的数组<br>    |—-ArrayList：作为List接口的<code>主要实现类</code>；线程不安全的，效率高；底层使用Object[] elementData存储<br>    |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储  —》 铁链子 内部   打比方 传话<br>    |—-Vector：作为List接口的<code>古老实现类</code>；线程安全的，效率低；底层使用Object[] elementData存储      打比方  不怎么用，   皇帝与旧臣</p>
<p>2.常用方法: (记住)<br>增：add(Object obj)<br>删：remove(int index) / remove(Object obj)<br>改：set(int index, Object ele)<br>查：get(int index)<br>插：add(int index, Object ele)<br>长度：size()<br>遍历：① Iterator迭代器方式<br>② 增强for循环<br>③ 普通的循环</p>
<p>3.常用实现类:<br>|—-Collection接口：单列集合，用来存储一个一个的对象<br>|—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组,替换原有的数组<br>    |—-ArrayList：作为List接口的<code>主要实现类</code>；线程不安全的，效率高；底层使用Object[] elementData存储<br>    |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储  —》 铁链子 内部   打比方 传话<br>    |—-Vector：作为List接口的<code>古老实现类</code>；线程安全的，效率低；底层使用Object[] elementData存储      打比方  不怎么用，   皇帝与旧臣</p>
<p>4.源码分析(难点)</p>
<ol>
<li><p>ArrayList的源码分析：<br>2.1 jdk 7情况下<br> ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData<br> list.add(123);//elementData[0] = new Integer(123);<br> …<br> list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。<br> 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。<br>*<br> <strong><strong><strong>**</strong></strong></strong>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)；<br>*</p>
<p>2.2 jdk 8中ArrayList的变化：<br>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组</p>
</li>
</ol>
<p>*<br>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]<br>…<br>后续的添加和扩容操作与jdk 7 无异。<br> 2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象<br>     的创建类似于单例的懒汉式，–&gt;延迟了数组的创建，节省内存。</p>
<p>4.2 LinkedList的源码分析：<br>   LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null<br>    list.add(123);//将123封装到Node中，创建了Node对象。<br>    *<br>    其中，Node定义为：体现了LinkedList的双向链表的说法<br>    private static class Node<e> {<br>     E item;<br>     Node<e> next;<br>     Node<e> prev;</e></e></e></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br><span class="line"> this.item = element;</span><br><span class="line"> this.next = next;</span><br><span class="line"> this.prev = prev;</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">*</span><br></pre></td></tr></tbody></table></figure>

<p>4.3 Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。<br>   在扩容方面，默认扩容为原来的数组长度的2倍。  stack</p>
<p>left right  二叉树</p>
<p>5.存储的元素的要求:<br>添加的对象:所在的类要重写equals()方法|</p>
<p>[面试题]</p>
<p>面试题：ArrayList、LinkedList、Vector三者的异同？<br>同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据<br>不同：见上</p>
<h2 id="4-复习"><a href="#4-复习" class="headerlink" title="4.复习"></a>4.复习</h2><p>1.存储的数据特点:无序的、不可重复的元素</p>
<p>具体的:<br>以HashSet为例说明:</p>
<ol>
<li>无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</li>
<li>不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。<br>2.元素添加过程: ( 以HashSet为例)<br> 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br> 此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断<br>  数组此位置上是否已经有元素：<br>   如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>   如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<pre><code>        如果hash值不相同，则元素a添加成功。---&gt;情况2
        如果hash值相同，进而需要调用元素a所在类的equals()方法：
               equals()返回true,元素a添加失败
               equals()返回false,则元素a添加成功。---&gt;情况2
对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。
jdk 7 :元素a放到数组中，指向原来的元素。
jdk 8 :原来的元素在数组中，指向元素a
总结：七上八下</code></pre></li>
</ol>
<p>HashSet底层：数组+链表的结构。（前提jdk7）</p>
<p>3.常用方法<br>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</p>
<p>4.常用实现类:<br>|—-Collection接口：单列集合，用来存储一个一个的对象<br>     |—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”<br>         |—-HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值<br>             |—-LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历<br>|在添加数据的同时，每个数据还维护J两个引用，记录此数据前一一个数据和后一个数据。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                        对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">|----TreeSet：可以按照添加对象的指定属性，进行排序。  红黑树</span><br></pre></td></tr></tbody></table></figure>

<p>5.存储对象所在类的要求:<br>HashSet/LinkedHashSet:<br>要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()<br>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码<br> 重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p>
<p>TreeSet:<br>1.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().<br>2.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</p>
<ol start="6">
<li>TreeSet的使用<br>6.1使用说明:<br>1.向TreeSet中添加的数据，要求是相同类的对象。<br>2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）<br>6.2常用的排序方式:<br><img src="/2016/07/06/2016-07-06-ji-he-bu-1/23_57" alt="自然排序"><br><img src="/2016/07/06/2016-07-06-ji-he-bu-1/23_61" alt="定制排序"></li>
</ol>
<h2 id="5-TreeSet的课后练习"><a href="#5-TreeSet的课后练习" class="headerlink" title="5.TreeSet的课后练习"></a>5.TreeSet的课后练习</h2><p>1.定义一个Employee类。<br>该类包含:private 成员变量name,age,birthday，其中birthday 为MyDate类的对象;并为每-一个属性定义getter, setter方法;并重写toString方法输出name, age, birthday</p>
<p>MyDate类包含:private成员变量year,month,day;并为每一个属性定 义getter, setter<br>方法;</p>
<p>创建该类的5个对象，并把这些对象放入TreeSet 集合中(下一章:TreeSet需使用泛型来定义)<br>分别按以下两种方式对集合中的元素进行排序，并遍历输出:<br>1).使Employee实现Comparable 接口，并按name排序<br>2).创建TreeSet 时传入Comparator 对象，按生日日期的先后排序。</p>
<p>MyDate m1=new MyDate(2020,11,31);<br>Employee e2=new  Employee(“jim”,17,new MyDate(2001,11,26));</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_07" alt="1588299061194"></p>
<p>方式二在MyDate 实现Com  的接口</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_08" alt="1588299129432"></p>
<h2 id="6-Set-课后2道面试题"><a href="#6-Set-课后2道面试题" class="headerlink" title="6. Set 课后2道面试题"></a>6. Set 课后2道面试题</h2><p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/23_59" alt="1588258563702"><br>删除先去找hash值</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_09" alt="1588299877584"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/23_60" alt="1588258589496"></p>
<p>位置hashCode 没错；然后    报错了，没有equals</p>
<h2 id="7-Map接口及其多个实现类的对比"><a href="#7-Map接口及其多个实现类的对比" class="headerlink" title="7.Map接口及其多个实现类的对比"></a>7.Map接口及其多个实现类的对比</h2><p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_10" alt="1588300201403"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_11" alt="1588300302969"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_12" alt="1588300324391"></p>
<p>一、Map的实现类的结构：<br> |—-Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)<br>        |—-HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value<br>             |—-LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。<br>                     原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。<br>                     对于频繁的遍历操作，此类执行效率高于HashMap。<br>        |—-TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序<br>                     底层使用红黑树<br>        |—-Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value<br>             |—-Properties:常用来处理配置文件。key和value都是String类型<br>     HashMap的底层：数组+链表  （jdk7及之前）<br>                   数组+链表+红黑树 （jdk 8）<br> *<br> *<br> 面试题：</p>
<ol>
<li>HashMap的底层实现原理？</li>
<li>HashMap 和 Hashtable的异同？</li>
<li>CurrentHashMap 与 Hashtable的异同？（暂时不讲）<br>*</li>
</ol>
<h2 id="8-Map中存储的key-value的特点"><a href="#8-Map中存储的key-value的特点" class="headerlink" title="8.Map中存储的key-value的特点"></a>8.Map中存储的key-value的特点</h2><p>二、Map结构的理解：<br>      Map中的key:无序的、不可重复的，使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）<br>      Map中的value:无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()<br>      一个键值对：key-value构成了一个Entry对象。<br>      Map中的entry:无序的、不可重复的，使用Set存储所有的entry</p>
<h2 id="9-HashMap在JDK7中的底层实现原理"><a href="#9-HashMap在JDK7中的底层实现原理" class="headerlink" title="9.HashMap在JDK7中的底层实现原理"></a>9.HashMap在JDK7中的底层实现原理</h2><p> 三、HashMap的底层实现原理？以jdk7为例说明：<br>     HashMap map = new HashMap():<br>     在实例化以后，底层创建了长度是16的一维数组Entry[] table。<br>     …可能已经执行过多次put…<br>     map.put(key1,value1):<br>     首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。<br>     如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1<br>     如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据<br>     的哈希值：<br>             如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2<br>             如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：<br>                     如果equals()返回false:此时key1-value1添加成功。—-情况3<br>                     如果equals()返回true:使用value1替换value2。<br> *<br>      补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。<br> *<br>     在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<h2 id="10-HashMap在JDK8中的底层实现原理"><a href="#10-HashMap在JDK8中的底层实现原理" class="headerlink" title="10.HashMap在JDK8中的底层实现原理"></a>10.HashMap在JDK8中的底层实现原理</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jdk8 相较于jdk7在底层实现方面的不同：</span><br><span class="line">1. new HashMap():底层没有创建一个长度为16的数组</span><br><span class="line">2. jdk 8底层的数组是：Node[],而非Entry[]</span><br><span class="line">3. 首次调用put()方法时，底层创建长度为16的数组</span><br><span class="line">4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</span><br><span class="line">   4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</span><br><span class="line">      4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="11-HashMap在JDK7中的源码分析"><a href="#11-HashMap在JDK7中的源码分析" class="headerlink" title="11.HashMap在JDK7中的源码分析."></a>11.HashMap在JDK7中的源码分析.</h2><h2 id="12-HashMap在JDK8中的源码分析"><a href="#12-HashMap在JDK8中的源码分析" class="headerlink" title="12.HashMap在JDK8中的源码分析."></a>12.HashMap在JDK8中的源码分析.</h2><p> 在第12个  如果存储的是null  不扩容<br>     DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16<br>     DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75<br>     threshold：扩容的临界值，=容量<em>填充因子：16\</em>0.75 =&gt; 12<br>     TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8<br>     MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64<br> *</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_13" alt="1588305937157"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_14" alt="1588305963226"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_15" alt="1588305984564"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_16" alt="1588306013458"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_17" alt="1588306051967"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_18" alt="1588306080705"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_19" alt="1588306114766"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_20" alt="1588306139611"></p>
<p> <img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_21" alt="1588306157975"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_22" alt="1588306176088"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_23" alt="1588306192670"></p>
<p>出现链表的情况少</p>
<h2 id="13-LinkedHashMap的底层实现原理"><a href="#13-LinkedHashMap的底层实现原理" class="headerlink" title="13.LinkedHashMap的底层实现原理"></a>13.LinkedHashMap的底层实现原理</h2><p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_24" alt="1588306320593"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_25" alt="1588306337685"></p>
<p>四、LinkedHashMap的底层实现原理（了解）<br>     源码中：<br>     static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {<br>             Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序<br>             Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {<br>                super(hash, key, value, next);<br>             }<br>         }<br> *Present=new Object</p>
<h2 id="14-Map中的常用方法"><a href="#14-Map中的常用方法" class="headerlink" title="14. Map中的常用方法"></a>14. Map中的常用方法</h2><p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_26" alt="1588306693853"></p>
<p>​    <img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_27" alt="1588306714103"></p>
<p>  五、Map中定义的方法：<br> 添加、删除、修改操作：<br> Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_28" alt="1588306821736"></p>
<p> void putAll(Map m):将m中的所有key-value对存放到当前map中<br> Object remove(Object key)：移除指定key的key-value对，并返回value</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_29" alt="1588306909088"></p>
<p> 不存在null</p>
<p>void clear()：清空当前map中的所有数据</p>
<p>{}  size:0</p>
<p> 元素查询的操作：</p>
<p>   Object get(Object key)：获取指定key对应的value</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_30" alt="1588307047376"></p>
<p> boolean containsKey(Object key)：是否包含指定的key<br> boolean containsValue(Object value)：是否包含指定的value<br> int size()：返回map中key-value对的个数</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_31" alt="1588307157255"></p>
<p> boolean isEmpty()：判断当前map是否为空   new的·对象依然存在</p>
<p> boolean equals(Object obj)：判断当前map和参数对象obj是否相等</p>
<h2 id="15-Map中的常用方法2"><a href="#15-Map中的常用方法2" class="headerlink" title="15.Map中的常用方法2"></a>15.Map中的常用方法2</h2><p> 元视图操作的方法：<br> Set keySet()：返回所有key构成的Set集合<br> Collection values()：返回所有value构成的Collection集合<br> Set entrySet()：返回所有key-value对构成的Set集合</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_32" alt="1588311167816"></p>
<p> 总结：常用方法：<br>添加：put(Object key,Object value)<br>删除：remove(Object key)<br>修改：put(Object key,Object value)<br>查询：get(Object key)<br>长度：size()<br>遍历：keySet() / values() / entrySet()</p>
<h2 id="16-TreeMap两种添加方式的使用"><a href="#16-TreeMap两种添加方式的使用" class="headerlink" title="16.TreeMap两种添加方式的使用"></a>16.TreeMap两种添加方式的使用</h2><p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_33" alt="1588311543622"></p>
<p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象<br>因为要按照key进行排序：自然排序 、定制排序<br>自然排序</p>
<p>person  implements Compable </p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_34" alt="1588311960563"></p>
<p>定制排序:</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_35" alt="1588312030825"></p>
<p>不能按照 value 排序</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_36" alt="1588312121291"></p>
<h2 id="17-Properties处理属性文件"><a href="#17-Properties处理属性文件" class="headerlink" title="17.Properties处理属性文件"></a>17.Properties处理属性文件</h2><p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_37" alt="1588312158878"></p>
<p>​    //Properties:常用来处理配置文件。key和value都是String类型   ，文件读到内存当中</p>
<p>workspace-&gt;</p>
<p>new -&gt; Resource  Bundle-&gt;jdbc-&gt;ok</p>
<p>name=tom</p>
<p>password=abc123</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_38" alt="1588312564631"></p>
<p>File Encodings-Transparent-native&gt;打钩 </p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_39" alt="1588312710514"></p>
<h2 id="18-Collections工具类常用方法的测试"><a href="#18-Collections工具类常用方法的测试" class="headerlink" title="18.Collections工具类常用方法的测试"></a>18.Collections工具类常用方法的测试</h2><p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_40" alt="1588312942185"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_41" alt="1588312989372"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_42" alt="1588313045587"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_43" alt="1588313074625"> 不用了听一下就可以</p>
<p> 面试题：Collection 和 Collections的区别？</p>
<p>reverse(List)：反转 List 中元素的顺序<br>shuffle(List)：对 List 集合元素进行随机排序<br>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序<br>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
<p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素<br>Object min(Collection)<br>Object min(Collection，Comparator)<br>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_47" alt="1588313901489"></p>
<p>void copy(List dest,List src)：将src中的内容复制到dest中</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_48" alt="1588314164802"></p>
<p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
<p>返回线程安全的</p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_49" alt="1588314240465"></p>
<h2 id="19-集合课后几道练习题说明"><a href="#19-集合课后几道练习题说明" class="headerlink" title="19. 集合课后几道练习题说明."></a>19. 集合课后几道练习题说明.</h2><p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_44" alt="1588313104484"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_45" alt="1588313136326"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_50" alt="1588314515984"></p>
<p><img src="/2016/07/06/2016-07-06-ji-he-bu-1/24_46" alt="1588313155704"></p>
<p>hashSet</p>
<h2 id="20-java数据结构的简述"><a href="#20-java数据结构的简述" class="headerlink" title="20.java数据结构的简述"></a>20.java数据结构的简述</h2><p>战术与策略 ： 数据结构</p>
<p>研究数据结构的目的是:加快程序执行速度，减少内存占有空间</p>
<p>算法是为了解决实际问题而设计的,数据结构是算法需要处理的问题载体。</p>
<p>数据结构与算法分析Java语言描述(第2版) [美] 卡拉罗(Carrano,FM.)<br>著金名，等译</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="https://img2020.cnblogs.com/blog/1508241/202005/1508241-20200519155417931-1887836889.jpg"><b>支付宝打赏</b>
            </span>
            
            
            <span class="reward-type">
                <img class="wechat" src="https://img2020.cnblogs.com/blog/1508241/202005/1508241-20200519155421281-200217015.jpg"><b>微信打赏</b>
            </span>
            
        </div>
    </div>
    <p class="reward-tip">
        一分一毛也是爱
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Tony</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2018/12/01/2018-12-01-centos-7-18-10-da-jian-si-ren-wang-pan-he-bo-ke/" class="pre-post btn btn-default" title='CentOS 7(18.10)搭建个人网盘和博客'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            CentOS 7(18.10)搭建个人网盘和博客</span>
    </a>
    
    
    <a href="/2016/07/06/2016-07-06-ji-he/" class="next-post btn btn-default" title='集合'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            集合</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>

<script src="http://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'LWmP4tvyNOjV0hDcXSzBxE6c-gzGzoHsz',
    appKey: 'R7xHtkFCXCFDHvyOSB5h4YjG',
    placeholder: '说点什么吧',
    notify: true,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '5',
    path: window.location.pathname,
    lang: 'zh-CN'.toLowerCase()
})
</script>


</div>

                  
                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            大纲
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-每日一考"><span class="toc-text">1.每日一考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-复习-Collection及Collection的遍历"><span class="toc-text">2.复习:Collection及Collection的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collection接口与-foreach遍历"><span class="toc-text">Collection接口与 foreach遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-复习-List接口"><span class="toc-text">3.复习:List接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-复习"><span class="toc-text">4.复习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-TreeSet的课后练习"><span class="toc-text">5.TreeSet的课后练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Set-课后2道面试题"><span class="toc-text">6. Set 课后2道面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Map接口及其多个实现类的对比"><span class="toc-text">7.Map接口及其多个实现类的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Map中存储的key-value的特点"><span class="toc-text">8.Map中存储的key-value的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-HashMap在JDK7中的底层实现原理"><span class="toc-text">9.HashMap在JDK7中的底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-HashMap在JDK8中的底层实现原理"><span class="toc-text">10.HashMap在JDK8中的底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-HashMap在JDK7中的源码分析"><span class="toc-text">11.HashMap在JDK7中的源码分析.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-HashMap在JDK8中的源码分析"><span class="toc-text">12.HashMap在JDK8中的源码分析.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-LinkedHashMap的底层实现原理"><span class="toc-text">13.LinkedHashMap的底层实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Map中的常用方法"><span class="toc-text">14. Map中的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-Map中的常用方法2"><span class="toc-text">15.Map中的常用方法2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-TreeMap两种添加方式的使用"><span class="toc-text">16.TreeMap两种添加方式的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-Properties处理属性文件"><span class="toc-text">17.Properties处理属性文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Collections工具类常用方法的测试"><span class="toc-text">18.Collections工具类常用方法的测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-集合课后几道练习题说明"><span class="toc-text">19. 集合课后几道练习题说明.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-java数据结构的简述"><span class="toc-text">20.java数据结构的简述</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>


<script type="text/javascript" src="/js/love_mouse.js"></script>
<canvas id="canv" width="630" height="648" style="position: fixed; top: 0px; left: 0px; z-index: -2; opacity: 1.0;"></canvas>
 <script type="text/javascript" src="/js/jscartoon2.js"></script>  
<script type="text/javascript" src="/js/code/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/js/code/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/js/code/codeCopy.js"></script>
<script type="text/javascript" src="/js/code/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/js/code/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>

    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2015
                    
                </span> |
                <span>
                    Powered by <a href="//user.qzone.qq.com/943697678" class="copyright-links" target="_blank" rel="nofollow">QQ空间</a>
                </span> |
            
            </div>
        </div>
    </div>
</div>



<script src="/assets/tagcanvas.min.js?rev=2.9.js"></script>

<script>
var tagOption = {
    textColour: '#444', // 字体颜色
    outlineMethod: 'block', // 选中模式
    outlineColour: '#FFDAB9', // 选中模式的颜色
    interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
    textHeight: 13,
    outlineRadius: 3,
    freezeActive: true || '', // 选中的标签是否继续滚动
    frontSelect: true || '', // 不选标签云后部的标签
    initial: [0.1, -0.1],
    depth: 0.5,
    decel: 0.95,
    maxSpeed: 0.03,
    reverse: true || '', // 是否反向触发
    fadeIn: 500, // 进入动画时间
    wheelZoom: false || '' // 是否启用鼠标滚轮
}
TagCanvas.Start('tag-cloud-3d', '', tagOption);
</script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>