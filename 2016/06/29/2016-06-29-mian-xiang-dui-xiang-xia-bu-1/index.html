<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="程序员Tony">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://zhenqk.github.io">
    <!--SEO-->

<meta name="keywords" content="面向对象概述" />


<meta name="description" content="shk_20200425_基础_15-面向对象(下)1. 每日一考1.static修饰的属性，相较于实例变量，有哪些特别之处(&gt;=3点)随着类的加载而加载:早于对象的创建;只要权限允许，可..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    面向对象(下)补1 |
    
    程序员Tony
</title>

<link rel="alternate" href="/atom.xml" title="程序员Tony" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>

    <header class="main-header"  style="background-image:url(
    https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1589855563474&amp;di=3aa70d773e2c49618ad522cba950a73c&amp;imgtype=0&amp;src=http%3A%2F%2Fbpic.588ku.com%2Fback_pic%2F00%2F09%2F33%2F28562e1bc3ca3a9.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Tony'>
            <img src="/img/avatar.gif" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
          <!--<h2 class="text-hide">成为自己要成为的人</h2> -->
            
            <h2>
                越简单越OK
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://zhenqk.github.io">
                        程序员Tony</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                主目录</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/工具/"><i class="fa "></i>
                                工具</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">

            <div class="row">
 
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="面向对象(下)补1">
            
            面向对象(下)补1
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/Java-%E5%9F%BA%E7%A1%80/">Java 基础</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/" rel="tag">面向对象概述</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2016/06/29</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="shk-20200425-基础-15-面向对象-下"><a href="#shk-20200425-基础-15-面向对象-下" class="headerlink" title="shk_20200425_基础_15-面向对象(下)"></a>shk_20200425_基础_15-面向对象(下)</h1><h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1. 每日一考"></a>1. 每日一考</h2><h3 id="1-static修饰的属性，相较于实例变量，有哪些特别之处-gt-3点"><a href="#1-static修饰的属性，相较于实例变量，有哪些特别之处-gt-3点" class="headerlink" title="1.static修饰的属性，相较于实例变量，有哪些特别之处(>=3点)"></a>1.static修饰的属性，相较于实例变量，有哪些特别之处(&gt;=3点)</h3><p>随着类的加载而加载:早于对象的创建;只要权限允许，可以通过”对象.static属性”的方式进行调用:存在于方法区的静态域。</p>
<h3 id="2-final可以用来修饰哪些结构，分别表示什么意思。"><a href="#2-final可以用来修饰哪些结构，分别表示什么意思。" class="headerlink" title="2.final可以用来修饰哪些结构，分别表示什么意思。"></a>2.final可以用来修饰哪些结构，分别表示什么意思。</h3><h3 id="3-代码实现单例模式的饿汉式4"><a href="#3-代码实现单例模式的饿汉式4" class="headerlink" title="3.代码实现单例模式的饿汉式4"></a>3.代码实现单例模式的饿汉式4</h3><h3 id="4-代码实现单例模式的懒汉式"><a href="#4-代码实现单例模式的懒汉式" class="headerlink" title="4.代码实现单例模式的懒汉式"></a>4.代码实现单例模式的懒汉式</h3><h3 id="5-类的属性赋值的位置有哪些-先后顺序为何"><a href="#5-类的属性赋值的位置有哪些-先后顺序为何" class="headerlink" title="5.类的属性赋值的位置有哪些?先后顺序为何?"></a>5.类的属性赋值的位置有哪些?先后顺序为何?</h3><p>默认初始化<br>显式初始化、代码块中初始化<br>构造器中初始化<br>通过”对象.属性”或”对象.方法”的方式赋值</p>
<h2 id="2-复习static"><a href="#2-复习static" class="headerlink" title="2.复习static"></a>2.复习static</h2><p>static:静态的<br>1.可以用来修饰的结构:主要用来修饰类的内部结构<br>属性、方法、代码块、内部类</p>
<p>2.static修饰属性: 静态变量(或类变量)<br>​2.1 属性，按是否使用static修饰，又分为：静态属性vs 非静态属性(实例变量)</p>
<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。<br>2.2 static修饰属性的其他说明：<pre><code>① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用</code></pre>② 静态变量的加载要早于对象的创建。<br>③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。<br>④        类变量    实例变量<br>类        yes        no<br>对象        yes        yes<br>2.3 静态属性举例：System.out; Math.PI;</li>
</ul>
<p>3.静态变量内存解析:<br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_01.png" alt="静态变量内存解析"><br>4.static修饰方法: 静态方法、类方法</p>
<p>① 随着类的加载而加载，可以通过”类.静态方法”的方式进行调用<br>②            静态方法    非静态方法<br>                 类        yes        no<br>                 对象        yes        yes<br>③ 静态方法中，只能调用静态的方法或属性<br> 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
<p>5.static的注意点:</p>
<p>5.1在静态的方法内，不能使用this关键字、super关键字<br>5.2关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</p>
<p>6.如何判定属性和方法应该使用static关键字:</p>
<p>身份证号加final</p>
<p>构造中赋值  static</p>
<p>6.1关于属性</p>
<blockquote>
<p>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。<br>类中的常量也常常声明为static</p>
</blockquote>
<p>6.2关于方法</p>
<blockquote>
<p>操作静态属性的方法，通常设置为static的<br>工具类中的方法，习惯上声明为static的。 比如: Math、 Arrays、 Collections</p>
</blockquote>
<p>7.使用举例:<br>举例一: Arrays、 Math、Collections等工具类<br>举例二:单例模式<br>举例三:<br>class Circle{<br>private double radius ;<br>private int id;//自动赋值<br>public Circle(){<br>id = init++; .<br>total++;<br>}<br>public Circle(double radius){<br>this();<br>//<br>id = init++;<br>//<br>total++;<br>this.radius = radius;<br>}</p>
<h2 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h2><p>1.设计模式的说明<br>1.1 理解<br>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。<br>1.2常用设计模式— 23种经典的设计模式<br>创建型模式，共5种: 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共种:适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共11种:策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br>GOF<br>工作上手了 ，，那数据结构、设计模式 、JVM</p>
<p>2.单例模式<br>2.1要解决的问题:<br>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p>
<p>2.2具体代码的实现:<br>饿汉式<br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_02.png" alt="饿汉式"><br>懒汉式;<br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_03.png" alt="懒汉式"><br>2.3两种方式的对比:<br>饿汉式:<br>坏处:对象加载时间过长。<br>好处:饿汉式是线程安全的<br>懒汉式:好处:延迟对象的创建。<br>目前的写法坏处:线程不安全。—&gt;到多线程内容时，再修改</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_04.png" alt="懒汉式优化  线程安全"></p>
<p>效率差</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_05.png" alt="也算单例"></p>
<h2 id="4-复习main"><a href="#4-复习main" class="headerlink" title="4.复习main()"></a>4.复习main()</h2><p>1.main()方法作为程序的入口<br>2.main()方法也是一个普通的静态方法<br>3.main()方法可以作为我们与控制台交互的方式。 (之.前: 使用Scanner</p>
<p>如何将控制台获取的数据传给形参: String[] args?<br>运行时: java 类名’Tom” “Jerry” “123” “true“<br>sysout(args[0]);//“Tom<br>sysout(args[3]);//“true”<br>– &gt;Boolean. parseBoolean(args[3]);<br>sysout(args[4])//报异常  最好 length-1</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_06.png" alt="小节"></p>
<p>方法体:来体现方法的功能</p>
<p>你哪知道他有多少子类</p>
<p>所以传入父类就可以了</p>
<h2 id="5-代码块和final"><a href="#5-代码块和final" class="headerlink" title="5.代码块和final"></a>5.代码块和final</h2><p>类的成员之四:代码块(初始化块) (重要性较属性、方法、构造器差一些)<br>1.代码块的作用:用来初始化类、对象的信息</p>
<p>2.分类 :代码块要是使用修饰符，只能使用static</p>
<p>分类:静态代码块 VS 非静态代码块</p>
<p>3.</p>
<p>静态代码块:</p>
<blockquote>
<p>内部可以输出语句<br>随着类的加载而执行，而且只执行一次<br>作用:初始化类的信息<br>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>静态代码块的执行要优先于非静态代码块的执行<br>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p>
</blockquote>
<p>非静态代码块:</p>
<blockquote>
<p>内部可以输出语句<br>随着对象的创建而执行<br>每创建一个对象，就执行一-次非静态代码块<br>作用:可以在创建对象时，对对象的属性等进行初始化<br>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、静态的方法</p>
</blockquote>
<p>4.实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序: </p>
<p>对应的练习: LeafTest. java /I Son. java</p>
<p>由父及子，静态先行。</p>
<p>①默认初始化<br>②显式初始化/⑤在代码块中赋值<br>③构造器中初始化<br>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值<br>执行的先后顺序:①-②/⑤-③-④</p>
<h3 id="final-最终的"><a href="#final-最终的" class="headerlink" title="final:最终的"></a>final:最终的</h3><p>1.可以用来修饰:</p>
<p>可以用来修饰:类、方法、变量</p>
<p>2.具体的:</p>
<ol>
<li>final 用来修饰一个类:此类不能被其他类所继承。<pre><code>比如：String类、System类、StringBuffer类</code></pre></li>
<li>final 用来修饰方法：表明此方法不可以被重写<br>比如：Object类中getClass();</li>
<li>final 用来修饰变量：此时的”变量”就称为是一个常量<pre><code>3.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化
3.2 final修饰局部变量：
   尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</code></pre></li>
</ol>
<p> static final 用来修饰属性：全局常量</p>
<h2 id="6-抽象类和抽象方法的使用"><a href="#6-抽象类和抽象方法的使用" class="headerlink" title="6. 抽象类和抽象方法的使用"></a>6. 抽象类和抽象方法的使用</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_07.png" alt="抽象类的引入"></p>
<p>老大不在做事了，交给下面做</p>
<p>abstract关键字的使用<br>1.abstract:抽象的<br>2.abstract可以用来修饰的结构：类、方法</p>
<p>抽象 类不能实例化<br>3.abstract修饰类：抽象类<br>    &gt; 此类不能实例化<br>    &gt; 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）<br>    &gt; 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p>
<ol start="4">
<li><p>abstract修饰方法：抽象方法<br>/ /抽象方法<br>Tpublic abstract void eat();</p>
<blockquote>
<p>抽象方法只有方法的声明，没有方法体<br>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。<br>若子类重写了父类中的所有的抽象方法后，此子类方可实例化<br>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p>
</blockquote>
<h2 id="6-7-抽象的应用场景"><a href="#6-7-抽象的应用场景" class="headerlink" title="6 -7 抽象的应用场景"></a>6 -7 抽象的应用场景</h2><p>提示必须进行方法的重写<br>抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。</p>
</li>
</ol>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_08.png" alt="抽象类的解决方案引入"></p>
<h2 id="8-abstract使用中的注意点"><a href="#8-abstract使用中的注意点" class="headerlink" title="8.abstract使用中的注意点"></a>8.abstract使用中的注意点</h2><p>abstract使用上的注意点：<br>1.abstract不能用来修饰：属性、构造器等结构</p>
<p>2.abstract不能用来修饰私有方法、静态方法、final的方法、final的类</p>
<h2 id="9-基本操作—抽象性的练习"><a href="#9-基本操作—抽象性的练习" class="headerlink" title="9. 基本操作—抽象性的练习"></a>9. 基本操作—抽象性的练习</h2><p>大四  过去</p>
<p>努力不一定成功  不努力一定不成功</p>
<p>问题 1：为什么抽象类不可以使用 final 关键字声明？<br>问题 2：一个抽象类中可以定义构造器 吗？  可以<br>问题 3：是否可以这样理解：抽象类就比普通多定义 了抽象方 法，除了不能直接 进行类的 实例化操作之外，并没有任何的不同?</p>
<p>编写一个 Employee Employee Employee 类，声明为抽象类，<br>包含如下三个 属性： name ，id ，salary。<br>提供必要的构造器和抽象方法： work()<br>对于 Manager Manager Manager 类来说，他既是员工还具有奖金 (bonus (bonus )的属性。<br>请使用继承的思想，设计CommonEmployee类和 Manager Manager类 ，要求中提供必要的方法进行属性访问。<br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_09.png" alt="抽象类题"><br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_10.png" alt="抽象类题"><br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/..%5CstudyNote_Pic%5Csgg%5Cday12%5C15_11.png" alt="抽象类题"><br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_13.png" alt="抽象类题"></p>
<h2 id="10-创建抽象类的匿名子类对象"><a href="#10-创建抽象类的匿名子类对象" class="headerlink" title="10.创建抽象类的匿名子类对象"></a>10.创建抽象类的匿名子类对象</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_14.png" alt="抽象类题"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_12.png" alt="匿名抽象的引入"></p>
<h4 id="匿名子类"><a href="#匿名子类" class="headerlink" title="匿名子类"></a>匿名子类</h4><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_15.png" alt="匿名抽象的引入"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_16.png" alt="匿名抽象的引入">   person 子类的重写</p>
<p>method(p)</p>
<p>匿名只用一次，省事，</p>
<p>懒得像这样，用一次new 一次对象</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_17.png" alt="匿名抽象的引入">q</p>
<p>最省事的匿名子类的匿名对象</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_18.png" alt="匿名抽象的引入"></p>
<p>能看懂别人写代码的意图就可以了</p>
<hr>
<h2 id="11-模板方法的设计模式及应用场景"><a href="#11-模板方法的设计模式及应用场景" class="headerlink" title="11. 模板方法的设计模式及应用场景"></a>11. 模板方法的设计模式及应用场景</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_19.png" alt="多态的应用"></p>
<p>多态的应用</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_20.png" alt="模板的使用案例"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		</span><br><span class="line">		SubTemplate t = <span class="keyword">new</span> SubTemplate();</span><br><span class="line">		</span><br><span class="line">		t.spendTime();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>{</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>{</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.code();<span class="comment">//不确定的部分、易变的部分 </span></span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"花费的时间为："</span> + (end - start));</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>{</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++){</span><br><span class="line">			<span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++){</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(i % j == <span class="number">0</span>){</span><br><span class="line">					isFlag = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(isFlag){</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>模板方法</p>
<h2 id="12-抽象方法的课后练习"><a href="#12-抽象方法的课后练习" class="headerlink" title="12.抽象方法的课后练习"></a>12.抽象方法的课后练习</h2><h2 id="13-接口的理解"><a href="#13-接口的理解" class="headerlink" title="13.接口的理解"></a>13.接口的理解</h2><ul>
<li><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</p>
</li>
<li><p>另一方面，有时必须从几个类中抽取出一-些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如:鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p>
</li>
<li><p>接口就是规范，定义的是- -组规则，体现了现实世界中“如果你是/要..则必须能..”的思想。<code>继承是一个"是不是"的关系，而接口实现则是"能不能" 的关系。</code></p>
</li>
<li><p><code>接口的本质是契约，标准，规范，</code>就像我们的法律- -样。制定好后大家都要遵守。</p>
<p>if 要飞，必须实现 </p>
</li>
</ul>
<p>举例<br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_21.png" alt="接口的举例"></p>
<p>虚线 类和接口的关系<br>实现 is a的关系<br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_22.png" alt="接口的举例"></p>
<h2 id="14-接口的定义和引用"><a href="#14-接口的定义和引用" class="headerlink" title="14.接口的定义和引用"></a>14.接口的定义和引用</h2><p>接口的使用<br>1.接口使用interface来定义<br>2.Java中，接口和类是并列的两个结构<br>3.如何定义接口：定义接口中的成员<br>    3.1 JDK7及以前：只能定义全局常量和抽象方法<br>            &gt;全局常量：public static final的.但是书写时，可以省略不写<br>            &gt;抽象方法：public abstract的  可省略 publicabstract 的</p>
<pre><code>3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</code></pre><ol start="4">
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.<br>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化<br>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类<br><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_23.png" alt="接口的实现"><br>abstract class A{</p>
</li>
</ol>
<p>}</p>
<ol start="6">
<li><p>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性<br> 格式：class AA extends BB implements CC,DD,EE</p>
</li>
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
</ol>
<hr>
<ol start="8">
<li>接口的具体使用，体现多态性</li>
<li>接口，实际上可以看做是一种规范</li>
</ol>
<p>面试题：抽象类与接口有哪些异同？</p>
<h2 id="15-接口的多实现和接口的继承性（多态性的体现-接口和抽象类）"><a href="#15-接口的多实现和接口的继承性（多态性的体现-接口和抽象类）" class="headerlink" title="15.接口的多实现和接口的继承性（多态性的体现  接口和抽象类）"></a>15.接口的多实现和接口的继承性（多态性的体现  接口和抽象类）</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_24.png" alt="接口继承接口"></p>
<h2 id="16-实例演示接口是一种规范"><a href="#16-实例演示接口是一种规范" class="headerlink" title="16.实例演示接口是一种规范"></a>16.实例演示接口是一种规范</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_25.png" alt="实例演示接口是一种规范">不同的USB接口  传输速率不一样，不知道用途  ，定义了抽象方法</p>
<p>以后任何方法 都要接受规范</p>
<p>实现类的集合  就是驱动</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_26.png" alt="实例演示接口是一种规范"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_27.png" alt="实例演示接口是一种规范"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_28.png" alt="实例演示接口是一种规范"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_29.png" alt="实例演示接口是一种规范"></p>
<p>接口的使用</p>
<p>1.体现了接口的多态性</p>
<p>2.接口实际上定义了一种规范</p>
<p>3.开发中，体会面向接口编程</p>
<p>JDBC  如何操作数据库的规范</p>
<p>MySQL Driver 是接口实现类的集合  </p>
<p>面向接口的编程</p>
<p>项目的具体需求是多变的,我们必须以不变应万变才能从容开发,此处的”不变”就是”规范”。因此,我们开发项目往往都是面向接口编程?</p>
<p>接口的主要用途就是被实现类实现</p>
<h2 id="17-创建接口匿名实体类的对象"><a href="#17-创建接口匿名实体类的对象" class="headerlink" title="17.创建接口匿名实体类的对象"></a>17.创建接口匿名实体类的对象</h2><ol start="3">
<li><p>匿名实现类没有用所以用  new USB代替</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_30.png" alt="实例演示接口是一种规范"></p>
</li>
</ol>
<p>com.transferDate(phone)    phone 可以多次使用</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_31.png" alt="实例演示接口是一种规范"></p>
<p>没有名用父类对象名充当的 —&gt;    上面是匿名实现类</p>
<h2 id="18-接口的应用–-gt-代理模式"><a href="#18-接口的应用–-gt-代理模式" class="headerlink" title="18.接口的应用–>代理模式"></a>18.接口的应用–&gt;代理模式</h2><p>实用性为主</p>
<p>用着用着感觉  ，，还真是？</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_32.png" alt="代理模式">代理类    和  被代理类</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_33.png" alt="代理模式"></p>
<p>​    <img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_34.png" alt="代理模式"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的应用：代理模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Server server = <span class="keyword">new</span> Server();</span><br><span class="line"><span class="comment">//		server.browse();</span></span><br><span class="line">		ProxyServer proxyServer = <span class="keyword">new</span> ProxyServer(server);</span><br><span class="line">		</span><br><span class="line">		proxyServer.browse();</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>{</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"真实的服务器访问网络"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> NetWork work;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>{</span><br><span class="line">		<span class="keyword">this</span>.work = work;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"联网之前的检查工作"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>{</span><br><span class="line">		check();</span><br><span class="line">		</span><br><span class="line">		work.browse();</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_35.png" alt="代理模式应用场景"></p>
<p>上面静态代理类</p>
<h2 id="19-接口应用：工厂模式—-一个了解的例子"><a href="#19-接口应用：工厂模式—-一个了解的例子" class="headerlink" title="19.接口应用：工厂模式—  一个了解的例子"></a>19.接口应用：工厂模式—  一个了解的例子</h2><p>工厂模式:实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离<br>起来，达到提高灵活性的目的。小<br>其实设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维<br>护，解决方式就是一个“分工”。。<br>社会的发展也是这样，分工越来越细。小<br>原始社会的人:人什么都要会，自己种，自己打猎，自己织衣服，自己治病<br>现在的人:可以只会一样，其他都不会，只会Java也能活，不会做饭，不会开<br>车，不会…..</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_36.png" alt="无工厂模式"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_37.png" alt="无工厂模式1"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_38.png" alt="简单工厂模式"></p>
<p>只是创建者</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_39.png" alt="简单工厂模式  使用"></p>
<p>上面也叫静态工厂</p>
<hr>
<p>缺点:对于增加新产品，不修改代码的话，是无法扩展的。违反了开闭原则(对<br>扩展开放:对修改封闭)。</p>
<p>需要对现有代码进行修改</p>
<p>工厂方法模式</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_40.png" alt="工厂方法模式  使用"></p>
<p>抽象工厂     了解下就可以了  ，，主要是对接口的使用</p>
<p>接口和抽象类的对比</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_41.png" alt="工厂方法模式  使用"></p>
<h2 id="20-接口课后两道笔试题"><a href="#20-接口课后两道笔试题" class="headerlink" title="20. 接口课后两道笔试题"></a>20. 接口课后两道笔试题</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_42.png" alt="面试题"></p>
<p>pX()   有误   编译有误，由于X是不确定的</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_44.png" alt="面试题"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_45.png" alt="面试题"></p>
<p>没毛病的</p>
<hr>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_43.png" alt="面试题 使用"></p>
<p>football   常量是final 静态的</p>
<h2 id="21-接口练习—-比较对象的大小"><a href="#21-接口练习—-比较对象的大小" class="headerlink" title="21.接口练习—-  比较对象的大小"></a>21.接口练习—-  比较对象的大小</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_46.png" alt="练习题"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_47.png" alt="练习题"></p>
<p>这个对象按照什么顺序排；对象是可排序的</p>
<h2 id="22-Java8中接口的新特性"><a href="#22-Java8中接口的新特性" class="headerlink" title="22.Java8中接口的新特性"></a>22.Java8中接口的新特性</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_48.png" alt="java8 的新特性"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_49.png" alt="java8 的新特性"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_50.png" alt="java8 的新特性的实现"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_51.png" alt="java8 的新特性的实现"></p>
<p>父类中重写 method3(sup)</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_52.png" alt="java8 的新特性的实现"></p>
<hr>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_53.png" alt="java8 的新特性的实现"></p>
<p>要是都没有方法体  或抽象的  确定有问题</p>
<p>public inteface CompareB{</p>
<p>default void method3(){</p>
<p>sout(“compre:上肢”)</p>
<p>}</p>
<p>}</p>
<p>解决办法:必须在实现类中重写此方法</p>
<hr>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_54.png" alt="java8 的新特性的实现"></p>
<p>目前静态方法非常少</p>
<h2 id="23-Java8-接口新特性的应用"><a href="#23-Java8-接口新特性的应用" class="headerlink" title="23.Java8 接口新特性的应用"></a>23.Java8 接口新特性的应用</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_55.png" alt="Java8 接口新特性的应用"></p>
<p>而第二种</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_56.png" alt="Java8 接口新特性的应用"></p>
<p>第三种   谁都没听    –&gt;第五个知识点</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_57.png" alt="Java8 接口新特性的应用"></p>
<p>关于接口的改进</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_58.png" alt="Java8 接口新特性的应用"></p>
<h2 id="24-内部类的分类-实际开发很少写-应用型差"><a href="#24-内部类的分类-实际开发很少写-应用型差" class="headerlink" title="24.内部类的分类(实际开发很少写  应用型差)"></a>24.内部类的分类(实际开发很少写  应用型差)</h2><ul>
<li>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。</li>
<li>在Java中，允许-一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</li>
<li>Innerclass–般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。<br>➢Innerclass的名字不能与包含它的外部类类名相同;</li>
<li>分类:成员内部类(static成员内部类和非static成员内部类)<br>局部内部类(不谈修饰符)、匿名内部类<br>person 与大脑  </li>
</ul>
<hr>
<p>1.Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类<br>2.内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)<br>3.成员内部类：<br>        一方面，作为外部类的成员：<br>        调用外部类的结构<br>        可以被static修饰<br>        可以被4种不同的权限修饰<br>        另一方面，作为一个类：<br>         类内可以定义属性、方法、构造器等<br>        可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承<br>        可以被abstract修饰</p>
<p>4.关注如下的3个问题<br>  4.1 如何实例化成员内部类的对象<br>  4.2 如何在成员内部类中区分调用外部类的结构<br>  4.3 开发中局部内部类的使用  见《InnerClassTest1.java》</p>
<p>局部内部类</p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_59.png" alt="局部内部类"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_60.png" alt="成员内部类"></p>
<h2 id="25-成员内部类的特点"><a href="#25-成员内部类的特点" class="headerlink" title="25.成员内部类的特点"></a>25.成员内部类的特点</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_59.png" alt="局部内部类"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_61.png" alt="成员内部类"></p>
<h2 id="26-如何实例化成员内部类"><a href="#26-如何实例化成员内部类" class="headerlink" title="26. 如何实例化成员内部类"></a>26. 如何实例化成员内部类</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_62.png" alt=" 如何实例化成员内部类"></p>
<h2 id="27-成员内部类中调用外部类的结构"><a href="#27-成员内部类中调用外部类的结构" class="headerlink" title="27. 成员内部类中调用外部类的结构"></a>27. 成员内部类中调用外部类的结构</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_63.png" alt=" 如何实例化成员内部类"></p>
<h2 id="28-开发中局部内部类的使用"><a href="#28-开发中局部内部类的使用" class="headerlink" title="28.开发中局部内部类的使用"></a>28.开发中局部内部类的使用</h2><p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_64.png" alt=" 开发中局部内部类的使用"></p>
<p><img src="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_65.png" alt=" 开发中局部内部类的使用"></p>
<p>能看懂就可以  自己定义内部类不多</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="https://img2020.cnblogs.com/blog/1508241/202005/1508241-20200519155417931-1887836889.jpg"><b>支付宝打赏</b>
            </span>
            
            
            <span class="reward-type">
                <img class="wechat" src="https://img2020.cnblogs.com/blog/1508241/202005/1508241-20200519155421281-200217015.jpg"><b>微信打赏</b>
            </span>
            
        </div>
    </div>
    <p class="reward-tip">
        一分一毛也是爱
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Tony</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2018/12/01/2018-12-01-centos-7-18-10-da-jian-si-ren-wang-pan-he-bo-ke/" class="pre-post btn btn-default" title='CentOS 7(18.10)搭建个人网盘和博客'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            CentOS 7(18.10)搭建个人网盘和博客</span>
    </a>
    
    
    <a href="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia/" class="next-post btn btn-default" title='面向对象(下)'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            面向对象(下)</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>

<script src="http://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'LWmP4tvyNOjV0hDcXSzBxE6c-gzGzoHsz',
    appKey: 'R7xHtkFCXCFDHvyOSB5h4YjG',
    placeholder: '说点什么吧',
    notify: true,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '5',
    path: window.location.pathname,
    lang: 'zh-CN'.toLowerCase()
})
</script>


</div>

                  
                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            大纲
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#shk-20200425-基础-15-面向对象-下"><span class="toc-text">shk_20200425_基础_15-面向对象(下)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-每日一考"><span class="toc-text">1. 每日一考</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static修饰的属性，相较于实例变量，有哪些特别之处-gt-3点"><span class="toc-text">1.static修饰的属性，相较于实例变量，有哪些特别之处(&gt;&#x3D;3点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-final可以用来修饰哪些结构，分别表示什么意思。"><span class="toc-text">2.final可以用来修饰哪些结构，分别表示什么意思。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-代码实现单例模式的饿汉式4"><span class="toc-text">3.代码实现单例模式的饿汉式4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-代码实现单例模式的懒汉式"><span class="toc-text">4.代码实现单例模式的懒汉式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-类的属性赋值的位置有哪些-先后顺序为何"><span class="toc-text">5.类的属性赋值的位置有哪些?先后顺序为何?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-复习static"><span class="toc-text">2.复习static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-单例模式"><span class="toc-text">3.单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-复习main"><span class="toc-text">4.复习main()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-代码块和final"><span class="toc-text">5.代码块和final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final-最终的"><span class="toc-text">final:最终的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-抽象类和抽象方法的使用"><span class="toc-text">6. 抽象类和抽象方法的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-抽象的应用场景"><span class="toc-text">6 -7 抽象的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-abstract使用中的注意点"><span class="toc-text">8.abstract使用中的注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-基本操作—抽象性的练习"><span class="toc-text">9. 基本操作—抽象性的练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-创建抽象类的匿名子类对象"><span class="toc-text">10.创建抽象类的匿名子类对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名子类"><span class="toc-text">匿名子类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-模板方法的设计模式及应用场景"><span class="toc-text">11. 模板方法的设计模式及应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-抽象方法的课后练习"><span class="toc-text">12.抽象方法的课后练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-接口的理解"><span class="toc-text">13.接口的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-接口的定义和引用"><span class="toc-text">14.接口的定义和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-接口的多实现和接口的继承性（多态性的体现-接口和抽象类）"><span class="toc-text">15.接口的多实现和接口的继承性（多态性的体现  接口和抽象类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-实例演示接口是一种规范"><span class="toc-text">16.实例演示接口是一种规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-创建接口匿名实体类的对象"><span class="toc-text">17.创建接口匿名实体类的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-接口的应用–-gt-代理模式"><span class="toc-text">18.接口的应用–&gt;代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-接口应用：工厂模式—-一个了解的例子"><span class="toc-text">19.接口应用：工厂模式—  一个了解的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-接口课后两道笔试题"><span class="toc-text">20. 接口课后两道笔试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-接口练习—-比较对象的大小"><span class="toc-text">21.接口练习—-  比较对象的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-Java8中接口的新特性"><span class="toc-text">22.Java8中接口的新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-Java8-接口新特性的应用"><span class="toc-text">23.Java8 接口新特性的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-内部类的分类-实际开发很少写-应用型差"><span class="toc-text">24.内部类的分类(实际开发很少写  应用型差)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-成员内部类的特点"><span class="toc-text">25.成员内部类的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-如何实例化成员内部类"><span class="toc-text">26. 如何实例化成员内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-成员内部类中调用外部类的结构"><span class="toc-text">27. 成员内部类中调用外部类的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-开发中局部内部类的使用"><span class="toc-text">28.开发中局部内部类的使用</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
<script type="text/javascript" src="/js/love_mouse.js"></script>

<canvas id="canv" width="630" height="648" style="position: fixed; top: 0px; left: 0px; z-index: -2; opacity: 1.0;"></canvas>
 <script type="text/javascript" src="/js/jscartoon2.js"></script>  



    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2015
                    
                </span> |
                <span>
                    Powered by <a href="//user.qzone.qq.com/943697678" class="copyright-links" target="_blank" rel="nofollow">QQ空间</a>
                </span> |
            
            </div>
        </div>
    </div>
</div>



<script src="/assets/tagcanvas.min.js?rev=2.9.js"></script>

<script>
var tagOption = {
    textColour: '#444', // 字体颜色
    outlineMethod: 'block', // 选中模式
    outlineColour: '#FFDAB9', // 选中模式的颜色
    interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
    textHeight: 13,
    outlineRadius: 3,
    freezeActive: true || '', // 选中的标签是否继续滚动
    frontSelect: true || '', // 不选标签云后部的标签
    initial: [0.1, -0.1],
    depth: 0.5,
    decel: 0.95,
    maxSpeed: 0.03,
    reverse: true || '', // 是否反向触发
    fadeIn: 500, // 进入动画时间
    wheelZoom: true || '' // 是否启用鼠标滚轮
}
TagCanvas.Start('tag-cloud-3d', '', tagOption);
</script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>