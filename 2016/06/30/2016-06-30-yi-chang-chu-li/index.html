<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="程序员Tony">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://zhenqk.github.io">
    <!--SEO-->

<meta name="keywords" content="异常处理" />


<meta name="description" content="1.每日一考抽象和接口是中心
1.abstract 能修饰哪些结构?修饰以后， 有什么特点?类、方法static final abstract类不能实例化，提供子类  extends抽象方法，，..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    异常处理 |
    
    程序员Tony
</title>

<link rel="alternate" href="/atom.xml" title="程序员Tony" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>

    <header class="main-header"  style="background-image:url(
    https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1589855563474&amp;di=3aa70d773e2c49618ad522cba950a73c&amp;imgtype=0&amp;src=http%3A%2F%2Fbpic.588ku.com%2Fback_pic%2F00%2F09%2F33%2F28562e1bc3ca3a9.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Tony'>
            <img src="/img/avatar.gif" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
          <!--<h2 class="text-hide">成为自己要成为的人</h2> -->
            
            <h2>
                越简单越OK
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://zhenqk.github.io">
                        程序员Tony</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                主目录</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/工具/"><i class="fa "></i>
                                工具</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">

            <div class="row">
 
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="异常处理">
            
            异常处理
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/Java-%E5%9F%BA%E7%A1%80/">Java 基础</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" rel="tag">异常处理</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2016/06/30</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>抽象和接口是中心</p>
<p>1.abstract 能修饰哪些结构?修饰以后， 有什么特点?<br>类、方法<br>static final abstract<br>类不能实例化，提供子类  extends<br>抽象方法，，只定义了一种功能的标准。具体的执行,需要子类去实现。</p>
<p>2.接口是否能继承接口?抽象类是否能实现(implements)接口?抽象<br>类是否能继承非抽象的类?。<br>能；能；能（object）</p>
<p>3.声明抽象类，并包含抽象方法。测试类中创建 一个继承抽象类的匿名子类的对象<br>匿名子类的对象。<br>abstract AA{<br>public abstract void m();<br>}<br>main(){<br>AAa = new AA(){<br>public void m(){</p>
<p>}<br>};<br>a.m();}<br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_01.png" alt="代码"></p>
<p>4.抽象类和接口有哪些共同点和区别?<br>不能实例化<br>不同类:抽象类  有构造器  ，接口没有<br>多继承VS单继承<br>接口往类方向靠近<br>5.如何创建静态成员内部类和非静态成员内部类的对象?<br>Person static Dog Bird<br>Person.Dog dog = new Person.Dog();<br>Person p = new Person();<br>Person.Bird bird = p.new Bird();<br>理解没用  还是要做些2遍</p>
<h2 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2.抽象类"></a>2.抽象类</h2><p>abstract:抽象的<br>1.可以用来修饰:类、方法<br>2.具体的:<br>abstract修饰类:抽象类</p>
<ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化的全过程)</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作—&gt;抽象的使用前提:继承性</li>
</ul>
<p>abstract修饰方法:抽象方法</p>
<ul>
<li>抽象方法只方法的声明，没方法体</li>
<li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li>
<li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li>
<li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li>
</ul>
<p>3.注意点:<br>1.abstract不能用来修饰:属性、构造器等结构<br>2.abstract不能用来修饰私方法、静态方法、final的方法、final的类<br>今天方法不能被重写</p>
<ol start="4">
<li>abstract的应用举例:<br>public void method(Person p){}<br>交通工具</li>
</ol>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_02.png" alt="抽象复习 "><br>举例二  求面积<br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_03.png" alt="抽象复习 "><br>IO流</p>
<p>想继承必须要重写<br>举例三: I0流中设计到的抽象类: InputStream/outputStream|Reader /Writer<br>在内部定义类抽象的read(）)</p>
<h3 id="模板方法的设计模式"><a href="#模板方法的设计模式" class="headerlink" title="模板方法的设计模式"></a>模板方法的设计模式</h3><p>1.解决的问题<br>在软件开发中实现-一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变<br>部分可以抽象出来，供不同子类实现。这就是一种模板模式。<br>2.举例<br>花费了多长时间<br>原来就是模板<br>3.应用场景</p>
<h2 id="3-复习-接口"><a href="#3-复习-接口" class="headerlink" title="3. 复习 接口"></a>3. 复习 接口</h2><p>interface:接口<br>1.使用说明:<br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_04.png" alt="抽象复习 "><br>比较清楚理解这个事就可以 ，主要是多写代码<br>2.举例:</p>
<p>U盘插电脑</p>
<p>体会:</p>
<ul>
<li>1.接口使用，上也满足多态性</li>
</ul>
<p>2.接口，实际上就是定义了一种规范</p>
<p>3.开发中，体会面向接口编程!</p>
<p>3.体会面向接口编程的思想</p>
<p> JDBC 技术  操作数据库的规范    sun定义规范</p>
<p>面向接口编程:我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个数据库厂商的API。</p>
<p>4.Java8中关于接口的新规范   对大家要求不高</p>
<p>//知识点1:接口中定义的静态方法，只能通过接口来调用。<br>//知识点2:通过实现类的对象，可以调用接口中的默认方法。.<br>//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法<br>//知识点3:如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重<br>写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则<br>//知识点4:如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，<br>//那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。<br>//这就需要我们必须在实现类中重写此方法</p>
<p>//知识点5:如何在子类(或实现类)的方法中调用父类、接口中被重写的方法<br>public void myMethod(){<br>method3();//调用自己定义的重写的方法.<br>super . method3();//调用的是父类中声明的<br>//调用接口中的默认方法<br>CompareA. super . method3();<br>CompareB . super . method3();<br>}</p>
<p>5.面试题:</p>
<p>抽象类和接口的异同   往新特征靠</p>
<p>java7  定义常量和方法</p>
<p>java8 静态方法</p>
<p>Java 9 私有方法</p>
<p>抽象类和接口的异同?<br>相同点:不能实例化;都可以包含抽象方法的。.<br>不同点:<br>1)把抽象类和接口(java7, java8, java9)的定义、内部结构解释说明<br>2)类:单继承性<br>接口:多继承<br>类与接口:多实现</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>1.解决的问题<br>代理模式是Java开发中使用较多的-种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。<br>2.举例</p>
<p>代理上网，明星经纪人</p>
<p>3.应用场景</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/..%5CstudyNote_Pic%5Csgg%5Cday12%5C16_05.png" alt="代理模式"></p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂方法</p>
<p>抽象工厂  </p>
<p>1.解决的问题<br>实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。<br>2.具体模式</p>
<ul>
<li>简单工厂模式:用来生产同一等级结构中的任意产品。(对于增加新的产品， 需要修改已有代码)</li>
<li>厂方法模式:用来生产同一等级结构中的固定产品。(支持增加任意产品</li>
<li>抽象工厂模式:用来生产不同产品族的全部产品。(对于增加新的产品， 无能为力;支持增加产品族<h2 id="4-复习内部类"><a href="#4-复习内部类" class="headerlink" title="4 复习内部类"></a>4 复习内部类</h2><h4 id="内部类-类的第五个成员"><a href="#内部类-类的第五个成员" class="headerlink" title="内部类:类的第五个成员"></a>内部类:类的第五个成员</h4></li>
</ul>
<p>1.定义:Java中允许将-一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.<br>2.内部类的分类:<br>成员内部类(静态、非静态)Vs局部内部类(方法内、代码块内、构造器内)</p>
<p>3.成员内部类的理解:</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/..%5CstudyNote_Pic%5Csgg%5Cday12%5C16_06.png" alt="成员内部类的理解"></p>
<p>4.成员内部类:<br>4.1如何创建成员内部类的对象?(静态的，非静态的)<br>//创建静态的Dog内部类的实例(静态的成员内部类):<br>Person.Dog dog = new Person.Dog();<br>//创建非静态的Bird内部类的实例(非静态的成员内部类):<br>//Person.Bird bird = new Person. Bird();//错误的<br>Person p = new Person() ;<br>Person.Bird bird = p.new Bird();</p>
<p>4.2如何在成员内部类中调用外部类的结构?<br>dlass Bird{<br>String name =<br>“杜鹃”;<br>public void display(String name ){<br>System. out . println(name);//方法的形参<br>System. out. print1n( this. name);//内部类的属性<br>System. out . print1n(Person. this . name);//外部类的属性<br>}</p>
<p>5.局部内部类的使用:<br>/ /返回一个实现了Comparable接口的类的对象<br>public Comparable getComparable(){<br>注意点：<br>前台开发  android</p>
<p>在局部内部类的方法中（比如：show）如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,<br>要求此局部变量声明为final的。<br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_07.png" alt="代码"></p>
<p>副本不能更改，只能用本身</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_08.png" alt="代码"></p>
<p>jdk 7及之前版本：要求此局部变量显式的声明为final的<br>jdk 8及之后的版本：可以省略final的声明</p>
<p>总结:<br>成员内部类和局部内部类，在编译以后，都会生成字节码文件。<br>格式:成员内部类:外部类$内部类名.class<br>局部内部类:外部类$数字内部类名.class</p>
<h2 id="6-异常概述"><a href="#6-异常概述" class="headerlink" title="6.异常概述"></a>6.异常概述</h2><h3 id="7-1异常概述与异常体系结构"><a href="#7-1异常概述与异常体系结构" class="headerlink" title="7-1异常概述与异常体系结构"></a>7-1异常概述与异常体系结构</h3><p>在使用计算机语言进行项目开发的过程中，即序员把代码写得 尽善美 ， 在系统的运行过程中仍然会遇到一些问题，因为很多不是靠代码能够避免的，比如:客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。</p>
<hr>
<ul>
<li>异常:在Java语言中，将程序执行中发生的不正常情况称为“异常’。(开发过程中的语法错误和逻辑错误不是异常)</li>
<li>Java程序在执行过程中所发生的异常事件可分为两类:<br>➢Error: Java虛 拟机无法解决的严重问题。如: JVM系统内部错误、资源.<br>耗尽等严重情况。比如: StackOverflowError和OOM。一般不编写针对性<br>的代码进行处理。<br>➢Exception:其它因编程错误或偶然的外在因素导致的一般性问题，可以使<br>用针对性的代码进行处理。例如:<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
</li>
</ul>
<p>Error:<br>Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。<br>一般不编写针对性的代码进行处理。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//1.栈溢出：java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">//		main(args);</span></span><br><span class="line">		<span class="comment">//2.堆溢出：java.lang.OutOfMemoryError  OOM</span></span><br><span class="line">		Integer[] arr = <span class="keyword">new</span> Integer[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="7-异常的分类"><a href="#7-异常的分类" class="headerlink" title="7.异常的分类"></a>7.异常的分类</h2><ul>
<li>对于这些错误，一 般有两种<code>解决方法</code>:一是遇到错误就终止程序<br>的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。   （打比方 生病了  ，工作做不了的;提前拿药；过高速路口 </li>
<li>捕获错误最理想的是在<code>编译期间</code>，但有的错误只有在运行时才会发生。<br>比如:<code>除数为0，数组下标越界</code>等<br>  ➢分类:编译时异常和运行时异常<br>Throwable   顶级父类<br>Exception<h3 id="7-2常见异常"><a href="#7-2常见异常" class="headerlink" title="7-2常见异常"></a>7-2常见异常</h3>一、异常体系结构</li>
</ul>
<p>java.lang.Throwable<br>        |—–java.lang.Error:一般不编写针对性的代码进行处理。<br>        |—–java.lang.Exception:可以进行异常的处理<br>            |——编译时异常(checked)<br>                    |—–IOException<br>                        |—–FileNotFoundException<br>                    |—–ClassNotFoundException<br>            |——运行时异常(unchecked,RuntimeException)<br>                    |—–NullPointerException<br>                    |—–ArrayIndexOutOfBoundsException<br>                    |—–ClassCastException<br>                    |—–NumberFormatException<br>                    |—–InputMismatchException<br>                    |—–ArithmeticException</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_09.png" alt="异常分类"><br>面试题：常见的异常都有哪些？举例说明</p>
<h2 id="8-常见异常的举例"><a href="#8-常见异常的举例" class="headerlink" title="8.常见异常的举例"></a>8.常见异常的举例</h2><p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_10.png" alt="异常举例"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_11.png" alt="异常举例"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_12.png" alt="异常举例"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_13.png" alt="异常举例  输入abc  异常"><br>编译时异常举例<br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_14.png" alt="异常举例  编译时异常"></p>
<h2 id="9-异常处理方式概述"><a href="#9-异常处理方式概述" class="headerlink" title="9.异常处理方式概述"></a>9.异常处理方式概述</h2><h3 id="7-3异常处理机制一-try-catch-fially-自己可以搞定"><a href="#7-3异常处理机制一-try-catch-fially-自己可以搞定" class="headerlink" title="7-3异常处理机制一: try- catch-fially(自己可以搞定)"></a>7-3异常处理机制一: try- catch-fially(自己可以搞定)</h3><p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_15.png" alt="异常处理机制一"></p>
<ul>
<li>Java提供的是异常处理的抓拋模型。</li>
<li>Java程序的执行过程中如出现异常，会生成一一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。</li>
<li>异常对象的生成<br>➢由虚拟机自动生成:程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出————自动抛出<br>➢由开发人员手动创建: Exception exception = new ClassCastException();一创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样</li>
</ul>
<hr>
<p>一、异常的处理：抓抛模型</p>
<p>过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出,一旦抛出对象以后，其后的代码就不再执行<br>关于异常对象的产生：① 系统自动生成的异常对象② 手动的生成一个异常对象，并抛出（throw）<br>过程二：”抓”：可以理解为异常的处理方式：① try-catch-finally  ② throws</p>
<h2 id="10-try-catch-方式"><a href="#10-try-catch-方式" class="headerlink" title="10.try-catch 方式"></a>10.try-catch 方式</h2><p>二、try-catch-finally的使用</p>
<p>try{<br>        //可能出现异常的代码</p>
<p>}catch(异常类型1 变量名1){<br>        //处理异常的方式1<br>}catch(异常类型2 变量名2){<br>        //处理异常的方式2<br>}catch(异常类型3 变量名3){<br>        //处理异常的方式3<br>}<br>….<br>finally{<br>        //一定会执行的代码<br>}</p>
<p>说明：</p>
<ol>
<li>finally是可选的。</li>
<li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的 try-catch结构（在没有写finally的情况）。继续执行其后的代码</li>
<li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。<br>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</li>
<li>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()  详细</li>
<li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li>
<li>try-catch-finally结构可以嵌套</li>
</ol>
<p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。<br>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。 针对于编译时异常，我们说一定要考虑异常的处理。</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_16.png" alt="代码"></p>
<h2 id="11-finally的使用"><a href="#11-finally的使用" class="headerlink" title="11.finally的使用"></a>11.finally的使用</h2><p>try-catch-finally中finally的使用：</p>
<p>1.finally是可选的</p>
<p>2.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p>
<p>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_17.png" alt="代码"></p>
<p>垃圾回收机制只回收JVM堆内存里的对象空间。<br>对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力</p>
<p>需要自己关流</p>
<p>编译器自己surround With try/cath</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_18.png" alt="避免空指针异常"></p>
<h2 id="12-编译时异常和运行时异常订单不同处理"><a href="#12-编译时异常和运行时异常订单不同处理" class="headerlink" title="12.编译时异常和运行时异常订单不同处理"></a>12.编译时异常和运行时异常订单不同处理</h2><p>运行时异常  不考虑try-catch处理</p>
<p>编译时异常  考虑</p>
<h2 id="13-处理异常-throws-方式"><a href="#13-处理异常-throws-方式" class="headerlink" title="13.处理异常:throws 方式"></a>13.处理异常:throws 方式</h2><h3 id="7-4异常处理机制二-throws-搞不定，找别人-往上报"><a href="#7-4异常处理机制二-throws-搞不定，找别人-往上报" class="headerlink" title="7-4异常处理机制二: throws(搞不定，找别人  往上报)"></a>7-4异常处理机制二: throws(搞不定，找别人  往上报)</h3><p>异常处理的方式二：throws + 异常类型</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_19.png" alt="例子"></p>
<ol>
<li><p>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。</p>
<p> 异常代码后续的代码，就不再执行！</p>
</li>
<li><p>体会：try-catch-finally:真正的将异常给处理掉了。</p>
<pre><code>throws的方式只是将异常抛给了方法的调用者。  并没有真正将异常处理掉。  </code></pre></li>
<li><p>开发中如何选择使用try-catch-finally 还是使用throws？<br>  3.1 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。</p>
<pre><code>3.2 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。    二选择一</code></pre></li>
</ol>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_20.png" alt="例子"></p>
<p>往上扑出，往上剖 ，异常并没有解决掉</p>
<h2 id="14-重写方法抛出的规则"><a href="#14-重写方法抛出的规则" class="headerlink" title="14.重写方法抛出的规则"></a>14.重写方法抛出的规则</h2><p>方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<h2 id="15-开发中如何选择那中方式处理异常"><a href="#15-开发中如何选择那中方式处理异常" class="headerlink" title="15.开发中如何选择那中方式处理异常"></a>15.开发中如何选择那中方式处理异常</h2><h2 id="16-手动抛出异常对象"><a href="#16-手动抛出异常对象" class="headerlink" title="16.手动抛出异常对象"></a>16.手动抛出异常对象</h2><p>7-5手动抛出异常: throw</p>
<p>产生手动  throw</p>
<p>抛出异常 throws    异常处理的一种方式</p>
<p> new RuntimeException或Exception</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_21.png" alt="例子"></p>
<h5 id="throw-new-Exception-“ns”-需要做处理-throws一下"><a href="#throw-new-Exception-“ns”-需要做处理-throws一下" class="headerlink" title="throw new Exception(“ns”)  需要做处理   throws一下"></a>throw new Exception(“ns”)  需要做处理   throws一下</h5><p>throws 体现异常处理，在方法声明处</p>
<p>生成一个异常对象，在方法里面</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_22.png" alt="throws"></p>
<h2 id="17-如何自动义异常"><a href="#17-如何自动义异常" class="headerlink" title="17.如何自动义异常"></a>17.如何自动义异常</h2><h3 id="7-6用户自定义异常类"><a href="#7-6用户自定义异常类" class="headerlink" title="7-6用户自定义异常类"></a>7-6用户自定义异常类</h3><p>如何自定义异常类?<br>1.继承于现有的异常结构: RuntimeException、Exception<br>2.提供全局常量: serialVersionUID<br>3.提供重载的构造器<br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_23.png" alt="throws"></p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_24.png" alt="throws"></p>
<p>只有异常体系才能throw</p>
<h2 id="18-基本使用"><a href="#18-基本使用" class="headerlink" title="18.基本使用"></a>18.基本使用</h2><p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_25.png" alt="throws"></p>
<h2 id="19-异常处理的练习"><a href="#19-异常处理的练习" class="headerlink" title="19.异常处理的练习"></a>19.异常处理的练习</h2><p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_26.png" alt="总结"></p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_27.png" alt="throws"></p>
<h2 id="20-异常处理章节总结"><a href="#20-异常处理章节总结" class="headerlink" title="20.异常处理章节总结"></a>20.异常处理章节总结</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>1.异常的体系结构</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_28.png" alt="异常体系结构"></p>
<p>2.从程序执行过程，看编译时异常和运行时异常</p>
<p>编译时异常:执行javac . exe命名时，可能出现的异常</p>
<p>运行时异常:执行java. exe命名时，可能出现的异常I</p>
<p>3.常见的异常类型，请举例说明:</p>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><ol>
<li>java异常处理的抓抛模型<br>过程一:“抛”:程序在正常执行的过程中，一一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。<br>关于异常对象的产生:①系统自动生成的异常对象<br>②手动的生成一个异常对象，并抛出(throw)|<br>过程二:“抓”: 可以理解为异常的处理方式:①try-catch-finally ② throws</li>
</ol>
<p>2.2.异常处理方式一try-cakch-finally|<br>2.1使用说明:</p>
<p>、try-catch-finally的使用</p>
<p>try{<br>        //可能出现异常的代码</p>
<p>}catch(异常类型1 变量名1){<br>        //处理异常的方式1<br>}catch(异常类型2 变量名2){<br>        //处理异常的方式2<br>}catch(异常类型3 变量名3){<br>        //处理异常的方式3<br>}<br>….<br>finally{<br>        //一定会执行的代码<br>}</p>
<p>说明：</p>
<ol>
<li>finally是可选的。</li>
<li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的 try-catch结构（在没有写finally的情况）。继续执行其后的代码</li>
<li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。<br>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</li>
<li>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()  详细</li>
<li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li>
<li>try-catch-finally结构可以嵌套</li>
</ol>
<p>总结:如何看待代码中的编译时异常和运行时异常?</p>
<p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。<br>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。<br>     针对于编译时异常，我们说一定要考虑异常的处理。</p>
<p>编译时异常 必须进行处理</p>
<p>2.2: finally的再 说明: </p>
<ul>
<li>1.finally是可省略的</li>
<li>2.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。</li>
<li>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。I</li>
</ul>
<p>2.3: [面试题]<br>final、finally. finalize三者的区别?</p>
<p>类似:</p>
<p>throw和throws<br>Collection和Collections<br>String、StringBuffer. StringBuilder<br>ArrayList、LinkedList<br>HashMap、LinkedHashMap<br>重写、重载</p>
<p>结构不相似的:<br>抽象类、接口<br>==、equals()<br>sleep()、wait()</p>
<p>3.异常处理方式二:</p>
<p>“throws +异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成-一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行!</p>
<p>4.对比两种处理方式<br>try-catch-finally:   真正的将异常给处理掉了<br>throws的方式只是将异常抛给了方法的调用者。|并没真正将异常处理掉。</p>
<p>5.体会开发中应该如何选择两种处理方式?<br>5.1 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理.<br>5.2 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</p>
<p>补充:<br>方法重写的规则之一:<br>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<h3 id="手动抛出异常对象"><a href="#手动抛出异常对象" class="headerlink" title="手动抛出异常对象"></a>手动抛出异常对象</h3><p>1.使用说明<br>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw-个异常类的对象。</p>
<p>2.[面试题]<br>throw和throws 区别:<br>throw表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。<br>throws属于异常处理的一种方式，声明在方法的声明处。</p>
<p>3.典型例题;</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_30.png" alt="例子"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_31.png" alt="例子"></p>
<h3 id="自定义异常对象"><a href="#自定义异常对象" class="headerlink" title="自定义异常对象"></a>自定义异常对象</h3><p>如何自定义一个异常类?<br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/16_32.png" alt="如何自定义异常类"></p>
<h2 id="项目三"><a href="#项目三" class="headerlink" title="项目三"></a>项目三</h2><p>开发团队人员调度软件</p>
<p>项目三软件架构</p>
<p>处理语言的能力  </p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/17_01.png" alt="代码"></p>
<p>throw new TeamException(“找不到指定的员工”)</p>
<p>各个详情不一样，  多态</p>
<p><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/17_02.png" alt="代码"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/17_03.png" alt="代码"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/17_04.png" alt="代码"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/17_05.png" alt="代码"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/17_06.png" alt="代码"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/17_07.png" alt="代码"><br><img src="/2016/06/30/2016-06-30-yi-chang-chu-li/17_08.png" alt="代码"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="https://img2020.cnblogs.com/blog/1508241/202005/1508241-20200519155417931-1887836889.jpg"><b>支付宝打赏</b>
            </span>
            
            
            <span class="reward-type">
                <img class="wechat" src="https://img2020.cnblogs.com/blog/1508241/202005/1508241-20200519155421281-200217015.jpg"><b>微信打赏</b>
            </span>
            
        </div>
    </div>
    <p class="reward-tip">
        一分一毛也是爱
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Tony</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2016/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/" class="pre-post btn btn-default" title='IDEA学习与多线程'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            IDEA学习与多线程</span>
    </a>
    
    
    <a href="/2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/" class="next-post btn btn-default" title='面向对象(下)补1'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            面向对象(下)补1</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>

<script src="http://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'LWmP4tvyNOjV0hDcXSzBxE6c-gzGzoHsz',
    appKey: 'R7xHtkFCXCFDHvyOSB5h4YjG',
    placeholder: '说点什么吧',
    notify: true,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '5',
    path: window.location.pathname,
    lang: 'zh-CN'.toLowerCase()
})
</script>


</div>

                  
                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            大纲
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-每日一考"><span class="toc-text">1.每日一考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-抽象类"><span class="toc-text">2.抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模板方法的设计模式"><span class="toc-text">模板方法的设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-复习-接口"><span class="toc-text">3. 复习 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代理模式"><span class="toc-text">代理模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#工厂模式"><span class="toc-text">工厂模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-复习内部类"><span class="toc-text">4 复习内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内部类-类的第五个成员"><span class="toc-text">内部类:类的第五个成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-异常概述"><span class="toc-text">6.异常概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1异常概述与异常体系结构"><span class="toc-text">7-1异常概述与异常体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-异常的分类"><span class="toc-text">7.异常的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2常见异常"><span class="toc-text">7-2常见异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-常见异常的举例"><span class="toc-text">8.常见异常的举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-异常处理方式概述"><span class="toc-text">9.异常处理方式概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3异常处理机制一-try-catch-fially-自己可以搞定"><span class="toc-text">7-3异常处理机制一: try- catch-fially(自己可以搞定)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-try-catch-方式"><span class="toc-text">10.try-catch 方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-finally的使用"><span class="toc-text">11.finally的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-编译时异常和运行时异常订单不同处理"><span class="toc-text">12.编译时异常和运行时异常订单不同处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-处理异常-throws-方式"><span class="toc-text">13.处理异常:throws 方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4异常处理机制二-throws-搞不定，找别人-往上报"><span class="toc-text">7-4异常处理机制二: throws(搞不定，找别人  往上报)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-重写方法抛出的规则"><span class="toc-text">14.重写方法抛出的规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-开发中如何选择那中方式处理异常"><span class="toc-text">15.开发中如何选择那中方式处理异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-手动抛出异常对象"><span class="toc-text">16.手动抛出异常对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#throw-new-Exception-“ns”-需要做处理-throws一下"><span class="toc-text">throw new Exception(“ns”)  需要做处理   throws一下</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-如何自动义异常"><span class="toc-text">17.如何自动义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6用户自定义异常类"><span class="toc-text">7-6用户自定义异常类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-基本使用"><span class="toc-text">18.基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-异常处理的练习"><span class="toc-text">19.异常处理的练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-异常处理章节总结"><span class="toc-text">20.异常处理章节总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常"><span class="toc-text">异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常的处理"><span class="toc-text">异常的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#手动抛出异常对象"><span class="toc-text">手动抛出异常对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常对象"><span class="toc-text">自定义异常对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目三"><span class="toc-text">项目三</span></a></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
<script type="text/javascript" src="/js/love_mouse.js"></script>

<canvas id="canv" width="630" height="648" style="position: fixed; top: 0px; left: 0px; z-index: -2; opacity: 1.0;"></canvas>
 <script type="text/javascript" src="/js/jscartoon2.js"></script>  



    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2015
                    
                </span> |
                <span>
                    Powered by <a href="//user.qzone.qq.com/943697678" class="copyright-links" target="_blank" rel="nofollow">QQ空间</a>
                </span> |
            
            </div>
        </div>
    </div>
</div>



<script src="/assets/tagcanvas.min.js?rev=2.9.js"></script>

<script>
var tagOption = {
    textColour: '#444', // 字体颜色
    outlineMethod: 'block', // 选中模式
    outlineColour: '#FFDAB9', // 选中模式的颜色
    interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
    textHeight: 13,
    outlineRadius: 3,
    freezeActive: true || '', // 选中的标签是否继续滚动
    frontSelect: true || '', // 不选标签云后部的标签
    initial: [0.1, -0.1],
    depth: 0.5,
    decel: 0.95,
    maxSpeed: 0.03,
    reverse: true || '', // 是否反向触发
    fadeIn: 500, // 进入动画时间
    wheelZoom: true || '' // 是否启用鼠标滚轮
}
TagCanvas.Start('tag-cloud-3d', '', tagOption);
</script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>





<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":145,"height":315},"mobile":{"show":true,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>