[{"title":"Ubuntu1810下安装MySQL","date":"2018-12-02T08:33:33.000Z","path":"2018/12/02/2018-12-02-ubuntu1810-xia-an-zhuang-mysql/","text":"版本:Ubuntu 18101.切换为root,下载并安装SQL服务器 123456q@q-virtual-machine:~$ su root密码： root@q-virtual-machine:/home/q# wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.debroot@q-virtual-machine:/home/q# dpkg -i mysql-apt-config_0.8.10-1_all.deb root@q-virtual-machine:/home/q# sudo apt updateroot@q-virtual-machine:/home/q# apt-get install mysql-server mysql-client libmysqlclient-dev 查看是否安装成功 1root@q-virtual-machine:/home/q# systemctl status mysql 遇到错误不紧张:重启 2.修改配置设置远程访问及修改密码 12345root@q-virtual-machine:/home/q# mysql mysql&gt; use mysql;select user, plugin from user;mysql&gt; update user set authentication_string=password(\"2557\"),plugin='mysql_native_password' where user='root';mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '456';mysql&gt; flush privileges; 一条语句版: 1mysql&gt;use mysql;select user, plugin from user;update user set authentication_string=password(\"2557\"),plugin='mysql_native_password' where user='root';grant all privileges on *.* to 'root'@'%' identified by '456';flush privileges;commit; 远程登录密码是456本地是2557更改的是本地密码 mysql&gt; set password=password(‘123’);和2557是同等功效 &amp;%只在远端登录(可不做 知识扩充) 12345678910root@q-virtual-machine:/home/q# vi /etc/mysql/mysql.conf.d/mysqld.cnf注释掉 #bind-address = 127.0.0.1root@q-virtual-machine:/etc/mysql/mysql.conf.d# mysql mysql&gt; use mysql mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '456';mysql&gt; flush privileges;commit;q@q-virtual-machine:~$ sudo systemctl restart mysql.service远端可以使用 密码456本地登录依然不需要密码 3.注释掉(要以root权限打开) 1234root@q-virtual-machine:/home/q# cd /etc/mysql/mysql.conf.d/root@q-virtual-machine:/etc/mysql/mysql.conf.d# vi mysqld.cnf注释掉#bind-address = 127.0.0.1 远端登录成功 4.设置utf-8字符集 1234root@q-virtual-machine:/etc/mysql/mysql.conf.d# sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnflc-messages-dir = /usr/share/mysqlcharacter-set-server=utf8 12root@q-virtual-machine:/etc/mysql/mysql.conf.d# gedit /etc/mysql/conf.d/mysql.cnfdefault-character-set=utf8 查看效果 1SHOW VARIABLES LIKE 'char%'; shell脚本 配置ubuntu 3步1.t.shell 1234567891011# 注释 文件复制 用于配置字符集utf-8和远端登录cp t1.cnf /etc/mysql/mysql.conf.d/mysqld.cnfcp t3.cnf /etc/mysql/conf.d/mysql.cnf# 设置本地密码2557 开启远端密码456 刷新权限mysql \"mysql\" -e\"update user set authentication_string=password('2557'),plugin='mysql_native_password' where user='root';grant all privileges on *.* to 'root'@'%' identified by '456';flush privileges;commit;\"echo \"everything is ok\"# 重启服务systemctl restart mysql.servicesystemctl enable mysql.service# 查看字符集utf-8mysql -uroot -p2557 -e\"SHOW VARIABLES LIKE 'char%';\" 2.t1.cnf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106## The MySQL database server configuration file.## You can copy this to one of:# - \"/etc/mysql/my.cnf\" to set global options,# - \"~/.my.cnf\" to set user-specific options.# # One can use all long options that the program supports.# Run program with --help to get a list of available options and with# --print-defaults to see which it would actually understand and use.## For explanations see# http://dev.mysql.com/doc/mysql/en/server-system-variables.html# This will be passed to all mysql clients# It has been reported that passwords should be enclosed with ticks/quotes# escpecially if they contain \"#\" chars...# Remember to edit /etc/mysql/debian.cnf when changing the socket location.# Here is entries for some specific programs# The following values assume you have at least 32M ram[mysqld_safe]socket = /var/run/mysqld/mysqld.socknice = 0[mysqld]## * Basic Settings#user = mysqlpid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockport = 3306basedir = /usrdatadir = /var/lib/mysqltmpdir = /tmplc-messages-dir = /usr/share/mysqlcharacter-set-server=utf8skip-external-locking## Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.# bind-address = 127.0.0.1## * Fine Tuning#key_buffer_size = 16Mmax_allowed_packet = 16Mthread_stack = 192Kthread_cache_size = 8# This replaces the startup script and checks MyISAM tables if needed# the first time they are touchedmyisam-recover-options = BACKUP#max_connections = 100#table_open_cache = 64#thread_concurrency = 10## * Query Cache Configuration#query_cache_limit = 1Mquery_cache_size = 16M## * Logging and Replication## Both location gets rotated by the cronjob.# Be aware that this log type is a performance killer.# As of 5.1 you can enable the log at runtime!#general_log_file = /var/log/mysql/mysql.log#general_log = 1## Error log - should be very few entries.#log_error = /var/log/mysql/error.log## Here you can see queries with especially long duration#slow_query_log = 1#slow_query_log_file = /var/log/mysql/mysql-slow.log#long_query_time = 2#log-queries-not-using-indexes## The following can be used as easy to replay backup logs or for replication.# note: if you are setting up a replication slave, see README.Debian about# other settings you may need to change.#server-id = 1#log_bin = /var/log/mysql/mysql-bin.logexpire_logs_days = 10max_binlog_size = 100M#binlog_do_db = include_database_name#binlog_ignore_db = include_database_name## * InnoDB## InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.# Read the manual for more InnoDB related options. There are many!## * Security Features## Read the manual, too, if you want chroot!# chroot = /var/lib/mysql/## For generating SSL certificates I recommend the OpenSSL GUI \"tinyca\".## ssl-ca=/etc/mysql/cacert.pem# ssl-cert=/etc/mysql/server-cert.pem# ssl-key=/etc/mysql/server-key.pem 3.t3.cnf 12[mysql]default-character-set=utf8 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhenqk.github.io/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhenqk.github.io/tags/MySQL/"}]},{"title":"CentOS 7(18.10)搭建个人网盘和博客","date":"2018-12-01T02:01:01.000Z","path":"2018/12/01/2018-12-01-centos-7-18-10-da-jian-si-ren-wang-pan-he-bo-ke/","text":"1. java环境 jdk-8u231-linux-x64.tar.gz 由于原先有jdk7版本,故移除更换先上传文件-&gt; 修改环境变量-&gt;解压至此文件下/usr/local/src/java/ 文件名为解压名 jdk1.8.0_231（和下面配置环境变量java_HOME路径一致） 2. 环境变量配置123456[root@NEU java]# vi /etc/profile #set java environment JAVA_HOME=/usr/local/src/java/jdk1.8.0_231 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 3.使环境变量生效12[root@NEU java]# source /etc/profile[root@NEU java]# java -version 搭建私有网盘解压文件tank-3.0.6.linux-amd64.tar.gz 到/root/blueBall 下执行12[root@NEU blueBall]# cd tank-3.0.6/[root@NEU tank-3.0.6]# ./tank 若执行遇到权限不足，请解压！！！！12[root@NEU ~]# cd blueBall/[root@NEU blueBall]# tar -zxvf tank-3.0.6.linux-amd64.tar.gz 修改默认端口 搭建博客修改端口,数据库,用户名和登录密码 startup.sh1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/bin/bash# executable pathDIR=\"$( cd \"$( dirname \"$0\" )\" &amp;&amp; pwd )\"JAR_PATH=$DIR/blog-1.1.0.jar#configsServerPort=80#mysql configsMysqlPort=3306MysqlHost=192.168.20.20MysqlSchema=blogMysqlUsername=rootMysqlPassword=123MysqlUrl=\"jdbc:mysql://$MysqlHost:$MysqlPort/$MysqlSchema?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false\"#tank configsTankUrl=\"https://tank.eyeblue.cn\"TankEmail=zhenqk@163.comTankPassword=123456#admin configsAdminUsername=TonyAdminNickname=TonyAdminEmail=zhenqk@163.comAdminPassword=123456#email configsMailProtocol=smtpsMailHost=smtp.126.comMailPort=465MailUsername=zhenqk@126.comMailPassword=a4877188MailDefaultEncoding=UTF-8OPTS=\"-Xmx512m -Dserver.port=$ServerPort -Dspring.datasource.url=$MysqlUrl -Dspring.datasource.username=$MysqlUsername -Dspring.datasource.password=$MysqlPassword -Dtank.url=$TankUrl -Dtank.email=$TankEmail -Dtank.password=$TankPassword -Dadmin.username=$AdminUsername -Dadmin.nickname=$AdminNickname -Dadmin.email=$AdminEmail -Dadmin.password=$AdminPassword -Dspring.mail.protocol=$MailProtocol -Dspring.mail.host=$MailHost -Dspring.mail.port=$MailPort -Dspring.mail.username=$MailUsername -Dspring.mail.password=$MailPassword -Dspring.mail.default-encoding=$MailDefaultEncoding\"echo $OPTSJAVA='java'if [ -z `which java` ]; then if [ -z $JAVA_HOME ]; then JAVA=$JAVA_HOME/bin/java else echo 'Cannot find java command and JAVA_HOME.' fifiif [ ! -z `java -version 2&gt;&amp;1 | grep 'java version' | awk '{print $3}' | egrep '1.[8-9].\\d*'` ]; then nohup $JAVA $OPTS -jar $JAR_PATH &gt;/dev/null 2&gt;&amp;1 &amp; echo $JAR_PATH echo 'Started successfully.'else echo 'Java version not support, must be 1.8 or 1.8+.'fi 启动12[root@NEU blueBall]# cd blog-1.1.0/[root@NEU blog-1.1.0]# sh startup.sh 开机软件启动(根目录)12sh /root/blueBall/blog-1.1.0/startup.sh/root/blueBall/tank-3.0.6/tank document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"blueBall","slug":"blueBall","permalink":"http://zhenqk.github.io/tags/blueBall/"},{"name":"Linux下JDK的安装","slug":"Linux下JDK的安装","permalink":"http://zhenqk.github.io/tags/Linux%E4%B8%8BJDK%E7%9A%84%E5%AE%89%E8%A3%85/"}]},{"title":"集合(补1)","date":"2016-07-06T06:52:54.000Z","path":"2016/07/06/2016-07-06-ji-he-bu-1/","text":"1.每日一考1.集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？ equals()方法。 contains() /remove()/retainsAll() …. List：equals()方法 Set：(HashSet、LinkedHashSet为例)：equals()、hashCode() (TreeSet为例)：Comparable：compareTo(Object obj) 1Comparator：compare(Object o1,Object o2) ArrayList,LinkedList,Vector三者的相同点与不同点？【面试题】 List Map(多) Set (用的少、禁飞名单 人员)都实现了List接口 底层都是数组查找快实现方式 3.List 接口的常用方法有哪些？(增、删、改、查、插、长度、遍历) add(Object obj) remove(Object obj)/remove(int index) set(int index,Object obj) get(int index) add(int index,Object obj) size() 实际长度 使用Iterator;foreach;普通的for4.如何使用Iterator和增强for循环遍历List。举例说明5.Set存储数据的特点是什么？常见的实现类有什么？说明一下彼此的特点。无需不可重复的 HashSet LinkedHashSet TreeSet HashMap LinkedHashMap TreeMap 2.复习:Collection及Collection的遍历2.Collection接口常用方法: 3.Collection集合与数组间的转换 String 不用加new String 就可以 4.使用Collection集合存储对象，要求对象所属的类满足: 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重 写equals(). 5.本章节对大家的要求: 层次一:选择合适的集合类去实现数据的保存，调用其内部的相关方法。层次二:不同的集合类底层的数据结构为何?如何实现数据的操作的:增删改查等，| Collection接口与 foreach遍历1.遍历collection的两种方式:①使用迭代器Iterator② foreach循环(或增强for循环) 2.java.utils包下定义的迭代器接口: Iterator2.1说明: ●lteratr对象称为迭代器(设计模式的一种), 主要用于遍历Cllction集合中的元素。●GOF给迭代器模式的定义为:提供-种方法访问一一个容器(container)对象中各个元素， 而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。 2.2作用:遍历集合元素 Collection元素2.3如何获取实例: coll.iterator()返回一个迭代器实例2.4遍历的代码实现: 2.5图示说明: 2.6 remove()的使用: 3.jdk5. 0新特性–增强for循环: (foreach循环)1.遍历集合举例: 说明:内部依然调用迭代器 2.遍历数组举例: 3.复习:List接口1.存储的数据特点:|—-Collection接口：单列集合，用来存储一个一个的对象|—-List接口：存储有序的、可重复的数据。 –&gt;“动态”数组,替换原有的数组 |—-ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 —》 铁链子 内部 打比方 传话 |—-Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储 打比方 不怎么用， 皇帝与旧臣 2.常用方法: (记住)增：add(Object obj)删：remove(int index) / remove(Object obj)改：set(int index, Object ele)查：get(int index)插：add(int index, Object ele)长度：size()遍历：① Iterator迭代器方式② 增强for循环③ 普通的循环 3.常用实现类:|—-Collection接口：单列集合，用来存储一个一个的对象|—-List接口：存储有序的、可重复的数据。 –&gt;“动态”数组,替换原有的数组 |—-ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 —》 铁链子 内部 打比方 传话 |—-Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储 打比方 不怎么用， 皇帝与旧臣 4.源码分析(难点) ArrayList的源码分析：2.1 jdk 7情况下 ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData list.add(123);//elementData[0] = new Integer(123); … list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。* **结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)；* 2.2 jdk 8中ArrayList的变化：ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组 *list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]…后续的添加和扩容操作与jdk 7 无异。 2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象 的创建类似于单例的懒汉式，–&gt;延迟了数组的创建，节省内存。 4.2 LinkedList的源码分析： LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null list.add(123);//将123封装到Node中，创建了Node对象。 * 其中，Node定义为：体现了LinkedList的双向链表的说法 private static class Node { E item; Node next; Node prev; 1234567 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }}* 4.3 Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。 在扩容方面，默认扩容为原来的数组长度的2倍。 stack left right 二叉树 5.存储的元素的要求:添加的对象:所在的类要重写equals()方法| [面试题] 面试题：ArrayList、LinkedList、Vector三者的异同？同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据不同：见上 4.复习1.存储的数据特点:无序的、不可重复的元素 具体的:以HashSet为例说明: 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。2.元素添加过程: ( 以HashSet为例) 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值， 此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断 数组此位置上是否已经有元素： 如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1 如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值： 如果hash值不相同，则元素a添加成功。---&gt;情况2 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败 equals()返回false,则元素a添加成功。---&gt;情况2 对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。 jdk 7 :元素a放到数组中，指向原来的元素。 jdk 8 :原来的元素在数组中，指向元素a 总结：七上八下 HashSet底层：数组+链表的结构。（前提jdk7） 3.常用方法Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。 4.常用实现类:|—-Collection接口：单列集合，用来存储一个一个的对象 |—-Set接口：存储无序的、不可重复的数据 –&gt;高中讲的“集合” |—-HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值 |—-LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历|在添加数据的同时，每个数据还维护J两个引用，记录此数据前一一个数据和后一个数据。 12 对于频繁的遍历操作，LinkedHashSet效率高于HashSet.|----TreeSet：可以按照添加对象的指定属性，进行排序。 红黑树 5.存储对象所在类的要求:HashSet/LinkedHashSet:要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码 重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 TreeSet:1.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().2.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals(). TreeSet的使用6.1使用说明:1.向TreeSet中添加的数据，要求是相同类的对象。2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）6.2常用的排序方式: 5.TreeSet的课后练习1.定义一个Employee类。该类包含:private 成员变量name,age,birthday，其中birthday 为MyDate类的对象;并为每-一个属性定义getter, setter方法;并重写toString方法输出name, age, birthday MyDate类包含:private成员变量year,month,day;并为每一个属性定 义getter, setter方法; 创建该类的5个对象，并把这些对象放入TreeSet 集合中(下一章:TreeSet需使用泛型来定义)分别按以下两种方式对集合中的元素进行排序，并遍历输出:1).使Employee实现Comparable 接口，并按name排序2).创建TreeSet 时传入Comparator 对象，按生日日期的先后排序。 MyDate m1=new MyDate(2020,11,31);Employee e2=new Employee(“jim”,17,new MyDate(2001,11,26)); 方式二在MyDate 实现Com 的接口 6. Set 课后2道面试题删除先去找hash值 位置hashCode 没错；然后 报错了，没有equals 7.Map接口及其多个实现类的对比 一、Map的实现类的结构： |—-Map:双列数据，存储key-value对的数据 —类似于高中的函数：y = f(x) |—-HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value |—-LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。 原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。 对于频繁的遍历操作，此类执行效率高于HashMap。 |—-TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序 底层使用红黑树 |—-Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value |—-Properties:常用来处理配置文件。key和value都是String类型 HashMap的底层：数组+链表 （jdk7及之前） 数组+链表+红黑树 （jdk 8） * * 面试题： HashMap的底层实现原理？ HashMap 和 Hashtable的异同？ CurrentHashMap 与 Hashtable的异同？（暂时不讲）* 8.Map中存储的key-value的特点二、Map结构的理解： Map中的key:无序的、不可重复的，使用Set存储所有的key —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例） Map中的value:无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals() 一个键值对：key-value构成了一个Entry对象。 Map中的entry:无序的、不可重复的，使用Set存储所有的entry 9.HashMap在JDK7中的底层实现原理 三、HashMap的底层实现原理？以jdk7为例说明： HashMap map = new HashMap(): 在实例化以后，底层创建了长度是16的一维数组Entry[] table。 …可能已经执行过多次put… map.put(key1,value1): 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。 如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据 的哈希值： 如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2 如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较： 如果equals()返回false:此时key1-value1添加成功。—-情况3 如果equals()返回true:使用value1替换value2。 * 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。 * 在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。 10.HashMap在JDK8中的底层实现原理1234567jdk8 相较于jdk7在底层实现方面的不同：1. new HashMap():底层没有创建一个长度为16的数组2. jdk 8底层的数组是：Node[],而非Entry[]3. 首次调用put()方法时，底层创建长度为16的数组4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。 4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素） 4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。 11.HashMap在JDK7中的源码分析.12.HashMap在JDK8中的源码分析. 在第12个 如果存储的是null 不扩容 DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75 threshold：扩容的临界值，=容量填充因子：16\\0.75 =&gt; 12 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64 * 出现链表的情况少 13.LinkedHashMap的底层实现原理 四、LinkedHashMap的底层实现原理（了解） 源码中： static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; { Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) { super(hash, key, value, next); } } *Present=new Object 14. Map中的常用方法 ​ 五、Map中定义的方法： 添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m):将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value 不存在null void clear()：清空当前map中的所有数据 {} size:0 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 new的·对象依然存在 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 15.Map中的常用方法2 元视图操作的方法： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 总结：常用方法：添加：put(Object key,Object value)删除：remove(Object key)修改：put(Object key,Object value)查询：get(Object key)长度：size()遍历：keySet() / values() / entrySet() 16.TreeMap两种添加方式的使用 向TreeMap中添加key-value，要求key必须是由同一个类创建的对象因为要按照key进行排序：自然排序 、定制排序自然排序 person implements Compable 定制排序: 不能按照 value 排序 17.Properties处理属性文件 ​ //Properties:常用来处理配置文件。key和value都是String类型 ，文件读到内存当中 workspace-&gt; new -&gt; Resource Bundle-&gt;jdbc-&gt;ok name=tom password=abc123 File Encodings-Transparent-native&gt;打钩 18.Collections工具类常用方法的测试 不用了听一下就可以 面试题：Collection 和 Collections的区别？ reverse(List)：反转 List 中元素的顺序shuffle(List)：对 List 集合元素进行随机排序sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换 Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素Object min(Collection)Object min(Collection，Comparator)int frequency(Collection，Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值 返回线程安全的 19. 集合课后几道练习题说明. hashSet 20.java数据结构的简述战术与策略 ： 数据结构 研究数据结构的目的是:加快程序执行速度，减少内存占有空间 算法是为了解决实际问题而设计的,数据结构是算法需要处理的问题载体。 数据结构与算法分析Java语言描述(第2版) [美] 卡拉罗(Carrano,FM.)著金名，等译 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"集合","slug":"集合","permalink":"http://zhenqk.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"集合","date":"2016-07-05T22:37:54.000Z","path":"2016/07/06/2016-07-06-ji-he/","text":"1.每日一考1.什么是枚举类？枚举类的对象声明的修饰符都有哪些？ 枚举类：类中的对象的个数是确定的，有限个。 private final (No) public static final (Yes) 2.什么是元注解？说说Retention和Target元注解的作用 元注解：对现有的注解进行解释说明的注解。 Retention：指明所修饰的注解的生命周期。SOURCE CLASS RUNTIME 说说你所理解的集合框架都有哪些接口，存储数据的特点是什么 比较throw 和 throws 的异同 同： throw:生成一个异常对象，并抛出。使用在方法内部 &lt;-&gt; 自动抛出异常对象 throws:处理异常的方式。使用在方法声明处的末尾&lt;-&gt;try-catch-finally “上游排污，下游治污” 谈谈你对同步代码块中同步监视器和共享数据的理解及各自要求。同步监视器：俗称锁。①任何一个类的对象都可以充当锁。② 多个线程共用同一把锁。共享数据：多个线程共同操作的数据，即为共享数据。需要使用同步机制将操作共享数据的代码包起来。不能包多了，也不能包少了。2.复习枚举类 枚举类的说明: 1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类2.当需要定义一组常量时，强烈建议使用枚举类3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 2.如何自定义枚举类?步骤: jdk 5.0新增使用enum定义枚举类。步骤: 使用enum定 义枚举类之后，枚举类常用方法: (继承于java. lang. Enum类) 5.使用enum定义枚举类之后，如何让枚举类对象分别实现接口: 3.复习:注解1.注解的理解① jdk 5.0 新增的功能② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。框架=注解+反射机制+设计模式 2.注解的使用示例示例一：生成文档相关的注解示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法;;加上注解编译的时候校验,不加在运行时校验 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择(向下兼容) @SuppressWarnings: 抑制编译器警告示例:跟踪代码依赖性,实现替代配置文件功能 3.如何自定义注解 如何自定义注解：参照@SuppressWarnings定义 ① 注解声明为：@interface ② 内部定义成员，通常使用value表示 ③ 可以指定成员的默认值，使用default定义 ④ 如果自定义注解没有成员，表明是一个标识作用。override说明:仿照这些如果注解有成员，在使用注解时，需要指明成员的值。 自定义注解必须配上注解的信息处理流程(使用反射)才有意义。 自定义注解通过都会指明两个元注解：Retention、Target代码举例:@Inherited@Repeatable(MyAnnotations . class)@Retention( RetentionPolicy.RUNTIME)@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_ ,VARIABLE , TYPE_ PARAMETER,TYPE_ USE})public @interface MyAnnotation {String value() default “hello”;}4.元注解:对现有的注解进行解释说明的注解。.jdk 提供的4种元注解Retention：指定所修饰的 Annotation 的生命周期：SOURCE javac 不保留注解 \\CLASS（默认行为） 运行时不保留注解 不会加载内存 \\RUNTIME(运行时候需要调 反射)只有声明为RUNTIME生命周期的注解，才能通过反射获取。Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素 ***出现的频率较低***Documented:表示所修饰的注解在被javadoc解析时，保留下来。Inherited:被它修饰的 Annotation 将具有继承性。String name 都是他的元数据—&gt;类比:元数据的概念: String name = “Tom” ;5.如何获取注解信息: 通过反射来进行获取、调用前提:前提:要求此注解的元注解Retention中声明的生命周期状态为: RUNTIME.6. JDK8中注解的新特性:可重复注解、类型注解 6.1 可重复注解： ① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class 两个注解关联在一起 ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 6.2 类型注解： ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 4. 复习集合1.集合与数组存储数据概述: 集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中） 2.数组存储的特点: 一旦初始化以后，其长度就确定了。数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。 比如：String[] arr;int[] arr1;Object[] arr2; 3.数组存储的弊端: 一旦初始化以后，其长度就不可修改。数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 4.集合存储的优点: 解决数组存储数据方面的弊端 集合接口1.单列集合框架结构 |—-Collection接口：单列集合，用来存储一个一个的对象 |—-List接口：存储有序的、可重复的数据。 –&gt;“动态”数组 |—-ArrayList、LinkedList、Vector * |—-Set接口：存储无序的、不可重复的数据 –&gt;高中讲的“集合” |—-HashSet、LinkedHashSet、TreeSet * |—-Map接口：双列集合，用来存储一对(key - value)一对的数据 –&gt;高中函数：y = f(x) |—-HashMap、LinkedHashMap、TreeMap、Hashtable、Properties 对应图示: 2.Collection接口常用方法: 3.Collection集合与数组间的转换4.使用Collection集合存储对象，要求对象所属的类满足:5.本章节对大家的要求:层次一:选择合适的集合类去实现数据的保存，调用其内部的相关方法。 1.Java集合框架概述2.Collection接口方法– 1.1集合框架与数组的对比及概述 一、集合框架的概述 *1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中） *2.1 数组在存储多个数据方面的特点： &gt; 一旦初始化以后，其长度就确定了。 &gt; 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。 比如：String[] arr;int[] arr1;Object[] arr2;2.2 数组在存储多个数据方面的缺点： &gt; 一旦初始化以后，其长度就不可修改。 &gt; 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。 &gt; 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用 &gt; 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 *二、集合框架 |—-Collection接口：单列集合，用来存储一个一个的对象 |—-List接口：存储有序的、可重复的数据。 –&gt;“动态”数组 |—-ArrayList、LinkedList、Vector * |—-Set接口：存储无序的、不可重复的数据 –&gt;高中讲的“集合” |—-HashSet、LinkedHashSet、TreeSet * |—-Map接口：双列集合，用来存储一对(key - value)一对的数据 –&gt;高中函数：y = f(x) |—-HashMap、LinkedHashMap、TreeMap、Hashtable、Properties * *三、Collection接口中的方法的使用 使用场景应用: 外卖、 1.2 集合框架涉及到API 1.3接口中的常用方法1什么容器干什么事 5-7.接口中的常用方法2-41结论：* 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). 先学会用 ，里面怎么用， 在判断的时候回调用obj对象所在类的equals方法， 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals(). 需要中需要删除一个数据 boolean值， 交集 比较两个集合元素相等，下面是不相等的，由于456的123位置，ArrayList是有序的 ``8.集合与数组之间的转换 11.3.Iterator迭代器接口8.使用Iterator遍历Collection Iterator it=coll.iterator(); iterator.next() 取数据 走悬崖 在next 就输了 iterator.hasNext() 取数据时判断有没有下一个 集合元素的遍历操作，使用迭代器Iterator接口1.内部的方法：hasNext() 和 next()2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。3.内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove() 9.迭代器的执行原理next 下移了 10.Iterator遍历集合的两种错误写法1234567891011 //错误方式一：// Iterator iterator = coll.iterator();// while((iterator.next()) != null){// System.out.println(iterator.next());// } //错误方式二： 死循环 //集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。 while (coll.iterator().hasNext()){ System.out.println(coll.iterator().next()); } 11.Iterator跌代器remove()的使用 迭代器只适用于 Collection 不适合Map 12.使用foreach循环遍历集合或数组 jdk 5.0 新增了foreach循环，用于遍历集合、数组 4.Collection子接口一: List 13. List接口常用实现类的对比 动态数组 List接口框架 *|—-Collection接口：单列集合，用来存储一个一个的对象 |—-List接口：存储有序的、可重复的数据。 –&gt;“动态”数组,替换原有的数组 |—-ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储 |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储 —》 铁链子 内部 打比方 传话 |—-Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储 打比方 不怎么用， 皇帝与旧臣** ArrayList的源码分析：2.1 jdk 7情况下ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementDatalist.add(123);//elementData[0] = new Integer(123);…list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。 ***结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)； *2.2 jdk 8中ArrayList的变化：ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组*list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]…后续的添加和扩容操作与jdk 7 无异。2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，–&gt;延迟了数组的创建，节省内存。* LinkedList的源码分析：LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为nulllist.add(123);//将123封装到Node中，创建了Node对象。 *其中，Node定义为：体现了LinkedList的双向链表的说法private static class Node {E item;Node next;Node prev; Node(Node prev, E element, Node next) {this.item = element;this.next = next;this.prev = prev;} } * Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。在扩容方面，默认扩容为原来的数组长度的2倍。 * 面试题：ArrayList、LinkedList、Vector三者的异同？ 同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据 不同：见上 * * * List接口中的常用方法 * @author shkstart @create 2019 上午 11:39*/public class ListTest { /*void add(int index, Object ele):在index位置插入ele元素boolean addAll(int index, Collection eles):从index位置开始将el中的所有元素添加进来Object get(int index):获取指定index位置的元素int indexOf(Object obj):返回obj在集合中首次出现的位置int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置Object remove(int index):移除指定index位置的元素，并返回此元素Object set(int index, Object ele):设置指定index位置的元素为eleList subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合 总结：常用方法增：add(Object obj)删：remove(int index) / remove(Object obj)改：set(int index, Object ele)查：get(int index)插：add(int index, Object ele)长度：size()遍历：① Iterator迭代器方式② 增强for循环③ 普通的循环 14.ArrayList的源码分析. 1 2 删除对象的2 new Integer(2); 17.List接口中的常用方法测试 18.List遍历及方法总结，19.List一个面试小题new Integer(123) 编程对象 5.Collection子接口二: Set 20.Set接口实现类的对比 Set接口的框架：*|—-Collection接口：单列集合，用来存储一个一个的对象 |----Set接口：存储无序的、不可重复的数据 --&gt;高中讲的“集合” |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值 |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历 对于频繁的遍历操作，LinkedHashSet效率高于HashSet. |----TreeSet：可以按照添加对象的指定属性，进行排序。 红黑树 Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。 要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。 21.Set的无序性与不可重复性的理解(开发使用set 相对较少)一、Set：存储无序的、不可重复的数据 以HashSet为例说明： 1. 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。 2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。 22.HashSet中元素的添加过程二、添加元素的过程：以HashSet为例： 7上⑧下 equal是true 才真一样，，首先比较code 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值， 此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断 数组此位置上是否已经有元素： 如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1 如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值： 如果hash值不相同，则元素a添加成功。—&gt;情况2 如果hash值相同，进而需要调用元素a所在类的equals()方法： equals()返回true,元素a添加失败 equals()返回false,则元素a添加成功。—&gt;情况2 对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。 jdk 7 :元素a放到数组中，指向原来的元素。 jdk 8 :原来的元素在数组中，指向元素a 总结：七上八下 HashSet底层：数组+链表的结构。 23.关于hashCode0和equals0的重写object hashcode 是随机算一个数 简单 return name.hashCode()+age *31 相撞的概率降低 24.LinkedHashSet的使用 //LinkedHashSet的使用 //LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个 //数据和后一个数据。 //优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet25.TreeSet的自然排序 1.向TreeSet中添加的数据，要求是相同类的对象。 2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator） 3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals(). 4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().自然排序 compareTo 为0，他就认为是一样的 二叉排序树 26.TreeSet的定制排序 (com) 定制排序，没写按照默认排序 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"集合","slug":"集合","permalink":"http://zhenqk.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"枚举类与注解","date":"2016-07-04T23:16:58.000Z","path":"2016/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/","text":"1.每日一考 将字符串”2017-08-16”转换为对应的java.sql.Date类的对象。 （使用JDK8之前或JDK8中的API皆可） SimpleDateFormat sdf = new SimpleDateFormat(“yyyy-MM-dd”); 解析：java.util.Date date = sdf.parse(“2017-08-16”); DateTimeFormatter dtf= DateTimeFormatter.ofPattern(“yyyy-MM-dd”); new + 构造器 单例、Calendar.getInstance() 解释何为编码？解码？ 何为日期时间的格式化？解析？ 编码：字符串 -&gt;字节 解码：字节 -&gt;字符串 格式化：日期 -&gt;字符串 format 解析：字符串 -&gt;日期 parse 自定义Person类如下，如何实现自然排序（按姓名从小到大排序），代码说明 class Person implements Comparable{ ​ private String name; ​ private int age; ​ public int compareTo(Object obj){ ​ //… this.name.compareTo(s.name); } } 提供定制排序涉及到的接口的实现类对象，并按Person类的年龄从大到小排序 Comparator com = new Comparator(){ ​ public int compare(Object obj1,Object obj2){ ​ if(){ } } }; JDK 8之前和JDK8中日期、时间相关的类分别有哪些？ java.util.Date 和 java.sql.Date -&gt; Instant SimpleDateFormat -&gt;DateTimeFormatter Calendar -&gt; LocalDate、LocalTime、LocalDateTime 2.复习 日期时间API痛苦才有所变化 java . text. SimpleDataFormat类SimpleDateFormat对日期Date类的格式化和解析1.两个操作:1.1 格式化:日期—&gt;字符串1.2解析:格式化的逆过程，字符串—&gt; 日期2.SimpleDateFormat的实例化:new +构造器 小练习: 练习一：字符串”2020-09-08”转换为java.sql.Date 123456 String birth = \"2020-09-08\"; SimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = sdf1.parse(birth);// System.out.println(date);java.sql.Date birthDate = new java.sql.Date(date.getTime());System.out.println(birthDate); 练习二：”三天打渔两天晒网” 1990-01-01 xxxx-xx-xx 打渔？晒网？ 举例：2020-09-08 ？ 总天数 123456总天数 % 5 == 1,2,3 : 打渔总天数 % 5 == 4,0 : 晒网总天数的计算？方式一：( date2.getTime() - date1.getTime()) / (1000606024) + 1（小数）=...天方式二：1990-01-01 --&gt; 2019-12-31 + 2020-01-01 --&gt;2020-09-08 4.Calendar类： 日历类，抽象类 JDK8新日期时间API1.日期时间API的迭代:第一代: jdk1.0Date类第二代: jdk 1.1 Calendar类，一定程度 上替换Date类第三代: jdk 1.8提出了新的一套API 2.前两代存在的问题举例:可变性:像日期和时间这样的类应该是不可变的。偏移性: Date中的年份是从1900开始的，而月份都从0开始。格式化:格式化只对Date用，Calendar则不行。此外，它们也不是线程安全的;不能处理闰秒等。 3.java 8中新的日期时间API涉及到的包 4.本地日期、本地时间、本地日期时间的使用: LocalDate / LocalTime / LocalDateTime 4.1说明: 说明： 1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高 2.类似于Calendar 4.2常用方法: 5.时间点: Instant5.1说明: ①时间线上的一个瞬时点。概念上讲， 它只是简单的表示自1970年1月1日0时0分0秒(UTC开始的秒数。)②类似于java.util.Date类 5.2常用方法: 6.日期时间格式化类: DateTimeFormatter6.1说明: 6.日期时间格式化类: DateTimeFormatter6.1说明: ①格式化或解析日期、时间②类似于SimpleDateFormat 6.2常用方法: 特别的:自定义的格式。如: ofPattern(“””yy-MM-dd h:mmss”);方式三 7.其它API的使用(不讲) 3.复习 Java比较器1.Java比较器的使用背景:. Java中的对象，正常情况下，只能进行比较:==或!=。不能使用〉或&lt;的但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现?使用两个接口中的任何-一个: Comparable 或Comparator 2.自然排序:使用Comparable接口2.1说明 1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列 3.重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。 在compareTo(obj)方法中指明如何排序 2.2自定义类代码举例: 3.定制排序:使用Comparator接口 3.1 说明 1.背景： 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作， 那么可以考虑使用 Comparator 的对象来排序 2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 3.2代码举例: 使用: Arrays.sort(goods,com); Collections.sort(coll,com); new TreeSet(com) 4.两种排序方式对比 Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。(一劳永逸) Comparator接口属于临时性的比较。(临时工) 其他类1.System类 native long currentTimeMillis()void exitint status)void gc()String getProperty(String key) 2.Math类 3.BigInteger类、BigDecimal类说明: ①java. math包的BigInteger可以表示不可变的任意精度的整数。❷要求数字精度比较高，用到java.math.BigDecimal类 代码举例: 10.1枚举类的使用如何使用关键字enum定义枚举类Enum类的主要方法 4.枚举类的理解 列全 一、枚举类的使用1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类2.当需要定义一组常量时，强烈建议使用枚举类3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。 *二、如何定义枚举类方式一：jdk5.0之前，自定义枚举类方式二：jdk5.0，可以使用enum关键字定义枚举类 *三、Enum类中的常用方法： values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称 *四、使用enum关键字定义的枚举类实现接口的情况 情况一：实现接口，在enum类中实现抽象方法 情况二：让枚举类的对象分别实现接口中的抽象方法 5.自定义枚举类5.0 自动装箱 拆箱 ，stringbuilder，注解 6.使用enum关键字定义枚举类 ​ public String getSeasonDesc(){ return seasonDesc } 不用重写toString ‘’‘’ System.out.println(Season1.class.getSuperclass()); 7.enum类的常用方法 单个枚举值用 ，隔开 8.使用enum关键字定义的枚举类实现接口 情况一：实现接口，在enum类中实现抽象方法 1interface Info{ void show();} enum Season1 implements Info{ 重写方法 public void show() {System. out. println(“这是- -个季节”);}4 } 主方法: winter. show();| 情况二：让枚举类的对象分别实现接口中的抽象方法 希望每个对象调用方法展示不同内容，由于情况一都是“ 这是- -个季节” 9.修改status 为enum的定义 把myproject03放置module中， setting-&gt;module-&gt;加号 两个字的名字 可以中间整空格 switch 可以实现 10.2注解的使用10.注解的理解 放射 读取操作注解 11.Annotation的使用实例 下面的替换掉 理解Annotation:① jdk 5.0 新增的功能② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 12.JDK内置的三个基本注解 Annocation的使用示例示例一：生成文档相关的注解示例二：在编译时进行格式检查(JDK内置的三个基本注解) @Override: 限定重写父类方法, 该注解只能用于方法;;加上注解编译的时候校验,不加在运行时校验 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择(向下兼容) @SuppressWarnings: 抑制编译器警告 示例:跟踪代码依赖性,实现替代配置文件功能 示例三：跟踪代码依赖性，实现替代配置文件功能 rawtypes 泛型警告 3.如何自定义注解：参照@SuppressWarnings定义 ① 注解声明为：@interface ② 内部定义成员，通常使用value表示 ③ 可以指定成员的默认值，使用default定义 ④ 如果自定义注解没有成员，表明是一个标识作用。override 123如果注解有成员，在使用注解时，需要指明成员的值。自定义注解必须配上注解的信息处理流程(使用反射)才有意义。自定义注解通过都会指明两个元注解：Retention、Target 指定默认值 回头用反射读取注解值，看想做什么 14-15.jdk中4个基本的元注解的使用4.jdk 提供的4种元注解 元注解：对现有的注解进行解释说明的注解 Retention：指定所修饰的 Annotation 的生命周期：SOURCE javac 不保留注解 \\CLASS（默认行为） 运行时不保留注解 不会加载内存 \\RUNTIME(运行时候需要调 反射)只有声明为RUNTIME生命周期的注解，才能通过反射获取。Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素 ***出现的频率较低*** Documented:表示所修饰的注解在被javadoc解析时，保留下来。 Inherited:被它修饰的 Annotation 将具有继承性。 注解继承演示 具有继承性 在注解上加5.通过反射获取注解信息 —到反射内容时系统讲解 16.jdk 8 中注解的新特性6.jdk 8 中注解的新特性：可重复注解、类型注解 6.1 可重复注解： ① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class 两个注解关联在一起 ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。 上面是jdk8 之前 17 类型注解 6.2 类型注解： ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。 ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 注解可以修饰参数 18.可重复注解中元注解不一致的问题解决 元注解 解释哈哈哈 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"枚举","slug":"枚举","permalink":"http://zhenqk.github.io/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"注解","slug":"注解","permalink":"http://zhenqk.github.io/tags/%E6%B3%A8%E8%A7%A3/"}]},{"title":"常用类Date","date":"2016-07-03T23:20:57.000Z","path":"2016/07/04/2016-07-04-chang-yong-lei-date/","text":"Java高级编程 使用层面 理解是可以长久保存的，别死记硬背 1.每日一考1.画出如下几行代码的内容结构:。String s1 = “hello”;String s2 = “hell’”;,String s3 = new String(“hello”);s1 += “world”; s1还是在堆里面，， 2.如何理解String类的不可变性。 数据不能做任何修改，s1该了 s2不能改变 现有字符串的操作，必须新造 3.String 类是否可以被继承?为什么? Strings = new Stringl”hello”);在内存中创建了几个对象?请说明 不能被继承， final 了 4.String, StringBuffer, StringBuilder 三者的对比 char[] 5.String的常用方法有哪些? (至少 7个) 4 length substring equal startwith endwith contains CharAt 2.复习 String类java .lang .String类的使用1.概述 String:字符串，使用一对””引起来表示。 1.String声明为final的，不可被继承 2.String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大 3.String内部定义了final char[] value用于存储字符串数据 4.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。 5.字符串常量池中是不会存储相同内容（使用String类的equals()比较，返回true）的字符串的。 2.String的不可变性2.1说明 1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 2.2代码举例 2.3图示 3.String实例化的不同方式3.1方式说明 方式一:通过字面量定义的方式方式二:通过new+构造器的方式 3.2 代码举例 3.3 面试题 面试题: string s = new String(“abc”);方式创建对象，在内存中创建了几个对象?两个:一个是堆空间中new结构，另一个是char[ ]对应的常量池中的数据: “abc “ 3.4 图示 4.字符串拼接方式赋值的对比4.1说明 1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。2.只要其中一个是变量，结果就在堆中。3.如果拼接的结果调用intern()方法，返回值就在常量池中 4.2代码举例 String s1 = “javaEEhadoop” ;String s2 = “javaEE” ;String s3 = s2 + “hadoop” ;System. out.println(s1 == s3);//falsefinal String s4 = “javaEE” ;//s4:常量String s5 = s4 + “hadoop” ;System. out.println(s1 == s5);//true String s8=s5.intern(); sout(s3==s8)； 5.常用方法 忘了去找 找 重点-&gt;反反复复用6. String与其它结构的转换6.1与基本数据类型、包装类之间的转换String str1=”123” int num=Integer.parseInt(str1) String.valueOf(num); 或者 num+”” .concat 6.2与字符数组之间的转换 6.3与字节数组之间的转换 编码：String –&gt; byte[]:调用String的getBytes() 解码：byte[] –&gt; String:调用String的构造器 6.4与StringBuffer、 StringBuilder之 间的转换 String –&gt;StringBuffer、 StringBuilder: 调用StringBuffer、StringBuilder构造器 StringBuffer、StringBuilder –&gt;String调 ①用String构造器; ②StringBuffer、 StringBuilder的toString() 7.JVM中字符串常量池存放位置说明:jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区(永久区)jdk1.7:字符串常量池存储在堆空间jdk 1.8:字符串常量池存储在方法区(元空间) 8.常见算法题目的考查: 3.复习 string、StringBuffer、 StringBuilder1.string、StringBuffer、 StringBuilder三者的对比String:不可变的字符序列;底层使用char[]存储StringBuffer:可变的字符序列;线程安全的，效率低;底层使用char[]存储StringBuilder:可变的字符序列; jdk5. 8新增的，线程不安全的，效率高;底层使用char[]存储 2.StringBuffer.与StringBuilder的内存解析以StringBuffer为例: 源码分析： String str = new String();//char[] value = new char[0]; length=0 String str1 = new String(\"abc\");//char[] value = new char[]{'a','b','c'}; StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。 System.out.println(sb1.length());// sb1.append('a');//value[0] = 'a'; sb1.append('b');//value[1] = 'b'; StringBuffer sb2 = new StringBuffer(\"abc\");//char[] value = new char[\"abc\".length() + 16];问题1. System.out.println(sb2.length());//3 //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。 指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity) 应届生 学校好 底子扎实 3.对比String、StringBuffer、 StringBuilder三者 的执行效率从高到低排列：StringBuilder &gt; StringBuffer &gt; String4.stringBuffer、StringBuilder中的常用方法 增：append(xxx) 删：delete(int start,int end) 改：setCharAt(int n ,char ch) / replace(int start, int end, String str) 查：charAt(int n ) 插：insert(int offset, xxx) 长度：length(); *遍历：for() + charAt() / toString()4.复习:日期时间的API1.获取系统当前时间 12345678//1.System类中的currentTimeMillis() @Test public void test1(){ long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 //称为时间戳 System.out.println(time); } 2.java.util.Date类与java. sql .Date类1.两个构造器的使用 &gt;构造器一：Date()：创建一个对应当前时间的Date对象 &gt;构造器二：创建指定毫秒数的Date对象2.两个方法的使用 &gt;toString():显示当前的年、月、日、时、分、秒 &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳） 3.java.sql.Date对应着数据库中的日期类型的变量 &gt;如何实例化 &gt;如何将java.util.Date对象转换为java.sql.Date对象 3.java. text .SimpleDataFormat类4.Calendar类 5-8 课后算法题目11111111111111 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 方式二 方式三: 111111111111111 2222222 .获取一个字符串在另-一个字符串中出现的次数。比如:获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数 2222222 33333333 4.获取两个字符串中最大相同子串。比如:str1 = “abcwerthelloyuiodef;str2 = “cvhellobnm’提示:将短的那个串进行长度依次递减的子串与较长的串比较。 前提是:两个字符串中只有一个最大相同子串 多个定义arraylist // 如果存在多个长度相同的最大相同子串 // 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便 public String[] getMaxSameSubString1(String str1, String str2) { if (str1 != null &amp;&amp; str2 != null) { StringBuffer sBuffer = new StringBuffer(); String maxString = (str1.length() &gt; str2.length()) ? str1 : str2; String minString = (str1.length() &gt; str2.length()) ? str2 : str1; int len = minString.length(); for (int i = 0; i &lt; len; i++) { for (int x = 0, y = len - i; y &lt;= len; x++, y++) { String subString = minString.substring(x, y); if (maxString.contains(subString)) { sBuffer.append(subString + \",\"); } } System.out.println(sBuffer); if (sBuffer.length() != 0) { break; } } String[] split = sBuffer.toString().replaceAll(\",$\", \"\").split(\"\\\\,\"); return split; } return null; }33333333 9.IDEA中Debug的调试逻辑能力 长度 10.simpleDateFormat的使用 1.两个操作： 1.1 格式化：日期 —&gt;字符串 1.2 解析：格式化的逆过程，字符串 —&gt; 日期 2.SimpleDateFormat的实例化 11-12.SimpleDateFormat的课后练习1-2练习一：字符串”2020-09-08”转换为java.sql.Date 123456 String birth = \"2020-09-08\"; SimpleDateFormat sdf1 = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = sdf1.parse(birth);// System.out.println(date);java.sql.Date birthDate = new java.sql.Date(date.getTime());System.out.println(birthDate); 练习二：”三天打渔两天晒网” 1990-01-01 xxxx-xx-xx 打渔？晒网？ 举例：2020-09-08 ？ 总天数 总天数 % 5 == 1,2,3 : 打渔 总天数 % 5 == 4,0 : 晒网 总天数的计算？ 方式一：( date2.getTime() - date1.getTime()) / (1000606024) + 1（小数）=...天 方式二：1990-01-01 --&gt; 2019-12-31 + 2020-01-01 --&gt;2020-09-0813.Calendar日历类的使用 14.JDK8中新日期时间API的介绍 9.3 JDK8中新日期时间APILocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter、其他类 偏移性: 15.LocalDate、LocalTime、LocalDateTime的使用 说明： 1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高 2.类似于Calendar 16.Instant类的使用 ==date 17.Date TimeFormatter的使用 18.其他日期时间相关的API的使用 19.导入module 模块 20.java比较器的概述9.4 Java 比较器 在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。 Java实现对象排序的方式有两种:➢自然排序: java.lang.Comparable➢定制排序: java.util.Comparator 一、说明：Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的 但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。 如何实现？使用两个接口中的任何一个：Comparable 或 Comparator二、Comparable接口与Comparator的使用的对比： Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。(一劳永逸) Comparator接口属于临时性的比较。(临时工) 21.Comparable 自然排序举例:Comparable接口的使用举例： 自然排序1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列 3.重写compareTo(obj)的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。 在compareTo(obj)方法中指明如何排序 22.自定义类实现Comparable自然排序public class Goods. implements Comparable{ } 当价格相同时,按书名排序 23.使用Comparator实现定制排序 Comparator接口的使用：定制排序 1.背景： 当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作， 那么可以考虑使用 Comparator 的对象来排序 2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小： 如果方法返回正整数，则表示o1大于o2； 如果返回0，表示相等； 返回负整数，表示o1小于o2。 sout(Arrays.toString(arr)); 用哪一种都可以 24.System、Math、BigInteger、BigDecimal的使用9.5 System类 9.6 Math类 9.7 BigInteger和BigDecimal // 报错 由于没有除尽 支持任意精度的小数位 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"常用类","slug":"常用类","permalink":"http://zhenqk.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"常用类String","date":"2016-07-02T07:24:09.000Z","path":"2016/07/02/2016-07-02-chang-yong-lei-string/","text":"Java高级编程 使用层面 理解是可以长久保存的，别死记硬背 1.每日一考1.画图说明线程的生命周期，以及各状态切换使用到的方法等，五种状态 状态转换 方法2.同步代码块中涉及到同步监视器和共享数据，谈谈你对同步监视器和共享数据的理解，以及注意点。synchronized（同步监视器)/操作共享数据的代码(不能包括多了，也不能包括少了)} 把握核心的东西3.sleep()和wait()的区别。4.写一个线程安全的懒汉式需要会手写5.创建多线程有哪几种方式。继承Thread类实现Runnable接口实现Cllable接口。线程池 （响应速度提高了，提高了资源的重用率，便于管理) 2.生命周期与同步机制图示:说明:1.生命周期关注两个概念:状态、相应的方法2.关注:状态a–&gt;状态b:哪些方法执行了(回调方法)某个方法主动调用:状态a–&gt;状态b ;3.阻塞:临时状态，不可以作为最终状态死亡:最终状态。| 线程的同步机制1.背景火车票卖票 2.Java解决方案: 同步机制 方式一：同步代码块 synchronized(同步监视器){ //需要被同步的代码 } 说明：1.操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。任意 要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 在继承Thread类创建多线程的方式中，慎用this 充当同步监视器，考虑使用当前类充当同步监视器。 方式二：同步方法。 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 解决线程安全问题的方式三：Lock锁 — JDK5.0新增 * 面试题：synchronized 与 Lock的异同？相同：二者都可以解决线程安全问题不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 关于同步方法的总结： 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 非静态的同步方法，同步监视器是：this静态的同步方法，同步监视器是：当前类本身 理解下，自己把它写一下 Lock -&gt; 同步代码块（已经进入了方法体，分配了相应资源） -&gt;同步方法（在方法体之外） 3.利弊 同步的方式，解决了线程的安全问题。—好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 —局限性 4.面试题: Java是如何解决线程安全问题的，有几种方式?并对比几种方式的不同 面试题：synchronized 与 Lock的异同？相同：二者都可以解决线程安全问题不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 面试题: synchronized和Lock方 式解决线程安全问题的对比 异步 喊你吃饭，他走了，你也走了，他在你前面 ##3.线程通信和新的线程创建方式 使用同步机制将单例模式中的懒汉式改写为线程安全的。 懒汉式: 12345678910111213141516171819202122232425262728293031323334353637/** * 使用同步机制将单例模式中的懒汉式改写为线程安全的 */public class BankTest {}class Bank{ private Bank(){} private static Bank instance = null; public static Bank getInstance(){ //方式一：效率稍差// synchronized (Bank.class) {// if(instance == null){//// instance = new Bank();// }// return instance;// } //方式二：效率更高 if(instance == null){ synchronized (Bank.class) { if(instance == null){ instance = new Bank(); } } } return instance; }} 面试题::写一个线程安全的单例模式 饿汉式 懒汉式 写上面优化的 死锁: 1.死锁的理解:不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁2.说明: 1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续2）我们使用同步时，要避免出现死锁。 3.举例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class ThreadTest { public static void main(String[] args) { StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread(){ @Override public void run() { synchronized (s1){ s1.append(\"a\"); s2.append(\"1\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s2){ s1.append(\"b\"); s2.append(\"2\"); System.out.println(s1); System.out.println(s2); } } } }.start(); new Thread(new Runnable() { @Override public void run() { synchronized (s2){ s1.append(\"c\"); s2.append(\"3\"); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (s1){ s1.append(\"d\"); s2.append(\"4\"); System.out.println(s1); System.out.println(s2); } } } }).start(); }} 线程通讯1.线程通信涉及到的三个方法: 两个线程之间并行 有交流 例题: 使用两个线程打印1-100。线程1,线程2交替打印 wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 2.说明: 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常 外面生成一个object 要是同一把锁 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 3.面试题 面试题：sleep() 和 wait()的异同？1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。2.不同点： 1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 4.小结释放锁的操作: 小结不会释放锁的操作: 新特性新增方式一:实现Callable接口 说明: 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ call()可以有返回值的。 call()可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 新增方式二:使用线程池说明: 好处:提高响应速度(减少了创建新线程的时间)降低资源消耗(重复利用线程池中线程，不需要每次都创建)便于线程管理V corePoolSize: 核心池的大小V maximumPoolSize: 最大线程数VkeepAliveTime:线程没有任务时最多保持多长时间后会终止 面试题: Java中 多线程的创建有几种方式?四种 创建线程的两种方式（继承Thread类，实现Runnable接口 ）+新特性 4.Java常用类的概述5.String类的概述6.理解String 不可变性9.1 字符串相关的类String类及常用方法和StringBuffer、StringBuilder 数组实现 String的特性 String:字符串，使用一对””引起来表示。 1.String声明为final的，不可被继承 2.String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大 3.String内部定义了final char[] value用于存储字符串数据 4.String:代表不可变的字符序列。简称：不可变性。体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。 2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。 6.字符串常量池中是不会存储相同内容的字符串的。 7.不同实例化方式的对比s5=s4.replace(‘a’,’m’); String 对象的创建 第一种在常量池种 第二种 在堆种 面试题: string s = new String(“abc”);方式创建对象，在内存中创建了几个对象?两个:一个是堆空间中new结构，另一个是char[ ]对应的常量池中的数据: “abc “ 8.String 不同拼接操作的对比 通过变量名参与，此时均不在常量池，需要在堆空间开辟 说明: 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。只要其中有一个是变量，结果就在堆中 String s8=s5.intern(); sout(s3==s8)； s8使用了常量值种已经存在的数据 如果拼接的结果调用intern()方法，返回值就在常量池中 9.String的一道面试题 String 不可变 10.JVM中设计字符串的内存结构jvm 7 字符串方法区在堆种 jvm8在元空间(永久区) 11. String 的常用方法1-3明确做啥 //什么情况下，index0f(str) 和astIndex0f(str)返回值相同?//情况一:存在唯一的一个str.。情况二:不存在str 数据库是从1开始 正则表达式 1String s1=\"123hello456world789\"; //开头有,或者结尾有逗号 | 或者String s2 = s1.replaceAll(\"\\\\d+\", \",\").replaceAll(\"^,|,$\", \"\");System.out.println(s2); 14.String与基本数据类型包装类的转换 String str1=”123” int num=Integer.parseInt(str1) String.valueOf(num); 或者 num+”” .concat 15.String与char[]之间的转换 编码：String –&gt; byte[]:调用String的getBytes() 解码：byte[] –&gt; String:调用String的构造器 编码：字符串 –&gt;字节 (看得懂 —&gt;看不懂的二进制数据)解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂） 说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。 17.解决一个拼接问题 18.面试中String 算法考查说明1.模拟一个trim方法，去除字符串两端的空格。2.将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”3.获取一个字符串在另-一个字符串中出现的次数。比如:获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数4.获取两个字符串中最大相同子串。比如:str1 = “abcwerthelloyuiodef;str2 = “cvhellobnm’提示:将短的那个串进行长度依次递减的子串与较长的串比较。5.对字符串中字符进行自然顺序排序。提示:1)字符串变成字符数组。2)对数组排序，选择，冒泡，Arrays. sort();3)将排序后的数组变成字符串。 自己去想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248package com.atguigu.java;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import org.junit.Test;/* * 1.模拟一个trim方法，去除字符串两端的空格。 * * 2.将一个字符串进行反转。将字符串中指定部分进行反转。比如将“abcdefg”反转为”abfedcg” * * 3.获取一个字符串在另一个字符串中出现的次数。 比如：获取“ab”在 “cdabkkcadkabkebfkabkskab” 中出现的次数 4.获取两个字符串中最大相同子串。比如： str1 = \"abcwerthelloyuiodef“;str2 = \"cvhellobnm\"//10 提示：将短的那个串进行长度依次递减的子串与较长 的串比较。5.对字符串中字符进行自然顺序排序。\"abcwerthelloyuiodef\"提示：1）字符串变成字符数组。2）对数组排序，选择，冒泡，Arrays.sort(str.toCharArray());3）将排序后的数组变成字符串。 */public class StringExer { // 第1题 public String myTrim(String str) { if (str != null) { int start = 0;// 用于记录从前往后首次索引位置不是空格的位置的索引 int end = str.length() - 1;// 用于记录从后往前首次索引位置不是空格的位置的索引 while (start &lt; end &amp;&amp; str.charAt(start) == ' ') { start++; } while (start &lt; end &amp;&amp; str.charAt(end) == ' ') { end--; } if (str.charAt(start) == ' ') { return \"\"; } return str.substring(start, end + 1); } return null; } // 第2题 // 方式一： public String reverse1(String str, int start, int end) {// start:2,end:5 if (str != null) { // 1. char[] charArray = str.toCharArray(); // 2. for (int i = start, j = end; i &lt; j; i++, j--) { char temp = charArray[i]; charArray[i] = charArray[j]; charArray[j] = temp; } // 3. return new String(charArray); } return null; } // 方式二： public String reverse2(String str, int start, int end) { // 1. String newStr = str.substring(0, start);// ab // 2. for (int i = end; i &gt;= start; i--) { newStr += str.charAt(i); } // abfedc // 3. newStr += str.substring(end + 1); return newStr; } // 方式三：推荐 （相较于方式二做的改进） public String reverse3(String str, int start, int end) {// ArrayList list = new ArrayList(80); // 1. StringBuffer s = new StringBuffer(str.length()); // 2. s.append(str.substring(0, start));// ab // 3. for (int i = end; i &gt;= start; i--) { s.append(str.charAt(i)); } // 4. s.append(str.substring(end + 1)); // 5. return s.toString(); } @Test public void testReverse() { String str = \"abcdefg\"; String str1 = reverse3(str, 2, 5); System.out.println(str1);// abfedcg } // 第3题 // 判断str2在str1中出现的次数 public int getCount(String mainStr, String subStr) { if (mainStr.length() &gt;= subStr.length()) { int count = 0; int index = 0; // while((index = mainStr.indexOf(subStr)) != -1){ // count++; // mainStr = mainStr.substring(index + subStr.length()); // } // 改进： while ((index = mainStr.indexOf(subStr, index)) != -1) { index += subStr.length(); count++; } return count; } else { return 0; } } @Test public void testGetCount() { String str1 = \"cdabkkcadkabkebfkabkskab\"; String str2 = \"ab\"; int count = getCount(str1, str2); System.out.println(count); } @Test public void testMyTrim() { String str = \" a \"; // str = \" \"; String newStr = myTrim(str); System.out.println(\"---\" + newStr + \"---\"); } // 第4题 // 如果只存在一个最大长度的相同子串 public String getMaxSameSubString(String str1, String str2) { if (str1 != null &amp;&amp; str2 != null) { String maxStr = (str1.length() &gt; str2.length()) ? str1 : str2; String minStr = (str1.length() &gt; str2.length()) ? str2 : str1; int len = minStr.length(); for (int i = 0; i &lt; len; i++) {// 0 1 2 3 4 此层循环决定要去几个字符 for (int x = 0, y = len - i; y &lt;= len; x++, y++) { if (maxStr.contains(minStr.substring(x, y))) { return minStr.substring(x, y); } } } } return null; } // 如果存在多个长度相同的最大相同子串 // 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便 public String[] getMaxSameSubString1(String str1, String str2) { if (str1 != null &amp;&amp; str2 != null) { StringBuffer sBuffer = new StringBuffer(); String maxString = (str1.length() &gt; str2.length()) ? str1 : str2; String minString = (str1.length() &gt; str2.length()) ? str2 : str1; int len = minString.length(); for (int i = 0; i &lt; len; i++) { for (int x = 0, y = len - i; y &lt;= len; x++, y++) { String subString = minString.substring(x, y); if (maxString.contains(subString)) { sBuffer.append(subString + \",\"); } } System.out.println(sBuffer); if (sBuffer.length() != 0) { break; } } String[] split = sBuffer.toString().replaceAll(\",$\", \"\").split(\"\\\\,\"); return split; } return null; } // 如果存在多个长度相同的最大相同子串：使用ArrayList// public List&lt;String&gt; getMaxSameSubString1(String str1, String str2) {// if (str1 != null &amp;&amp; str2 != null) {// List&lt;String&gt; list = new ArrayList&lt;String&gt;();// String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;// String minString = (str1.length() &gt; str2.length()) ? str2 : str1;//// int len = minString.length();// for (int i = 0; i &lt; len; i++) {// for (int x = 0, y = len - i; y &lt;= len; x++, y++) {// String subString = minString.substring(x, y);// if (maxString.contains(subString)) {// list.add(subString);// }// }// if (list.size() != 0) {// break;// }// }// return list;// }//// return null;// } @Test public void testGetMaxSameSubString() { String str1 = \"abcwerthelloyuiodef\"; String str2 = \"cvhellobnmiodef\"; String[] strs = getMaxSameSubString1(str1, str2); System.out.println(Arrays.toString(strs)); } // 第5题 @Test public void testSort() { String str = \"abcwerthelloyuiodef\"; char[] arr = str.toCharArray(); Arrays.sort(arr); String newStr = new String(arr); System.out.println(newStr); }} 19.StringBuffer和StringBuilder的介绍 String、StringBuffer、StringBuilder三者的异同？ String:不可变的字符序列；底层使用char[]存储 StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储 StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储 原字符上变 20.StringBuffer的源码分析 源码分析： String str = new String();//char[] value = new char[0]; length=0 ​ String str1 = new String(“abc”);//char[] value = new char[]{‘a’,’b’,’c’};​ StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。​ System.out.println(sb1.length());//​ sb1.append(‘a’);//value[0] = ‘a’;​ sb1.append(‘b’);//value[1] = ‘b’; ​ StringBuffer sb2 = new StringBuffer(“abc”);//char[] value = new char[“abc”.length() + 16]; 问题1. System.out.println(sb2.length());//3 //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。 指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)vlane&lt;&lt;1 == *2 append 多少次 21.StringBuffer中的常用方法 substring 需要返回值 setCharAt 指定字符改成新的 总结: 增删改查 插 长度 遍历 总结： 增：append(xxx) 删：delete(int start,int end) 改：setCharAt(int n ,char ch) / replace(int start, int end, String str) 查：charAt(int n ) 插：insert(int offset, xxx) 长度：length(); *遍历：for() + charAt() / toString() 22.对比String、StringBuffer、StringBuilder三者的效率 从高到低排列：StringBuilder &gt; StringBuffer &gt; String 1234567891011121314151617181920212223242526272829303132333435/* 对比String、StringBuffer、StringBuilder三者的效率： 从高到低排列：StringBuilder &gt; StringBuffer &gt; String */ @Test public void test3(){ //初始设置 long startTime = 0L; long endTime = 0L; String text = \"\"; StringBuffer buffer = new StringBuffer(\"\"); StringBuilder builder = new StringBuilder(\"\"); //开始对比 startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) { buffer.append(String.valueOf(i)); } endTime = System.currentTimeMillis(); System.out.println(\"StringBuffer的执行时间：\" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) { builder.append(String.valueOf(i)); } endTime = System.currentTimeMillis(); System.out.println(\"StringBuilder的执行时间：\" + (endTime - startTime)); startTime = System.currentTimeMillis(); for (int i = 0; i &lt; 20000; i++) { text = text + i; } endTime = System.currentTimeMillis(); System.out.println(\"String的执行时间：\" + (endTime - startTime)); } 9.2 JDK8之前的日期时间APISystem静态方法、Date类、Calender类、SimpleDateFormat类 23.System类中获取时间戳的方法 12345678//1.System类中的currentTimeMillis()@Testpublic void test1(){ long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。 //称为时间戳 System.out.println(time);} 24.Java中两个Date类的使用 java.util.Date类 |—java.sql.Date类 123456789101.两个构造器的使用 &gt;构造器一：Date()：创建一个对应当前时间的Date对象 &gt;构造器二：创建指定毫秒数的Date对象2.两个方法的使用 &gt;toString():显示当前的年、月、日、时、分、秒 &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）3.java.sql.Date对应着数据库中的日期类型的变量 &gt;如何实例化 &gt;如何将java.util.Date对象转换为java.sql.Date对象 情况一 9.3 JDK8中新日期时间APILocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter、其他类 9.4 Java 比较器Comparable接口Comparator接口 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"常用类","slug":"常用类","permalink":"http://zhenqk.github.io/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/"}]},{"title":"多线程（补1）多","date":"2016-07-01T02:10:40.000Z","path":"2016/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/","text":"1.每日一考 1.谈谈你对程序、进程、线程的理解。 说出来 程序:为完成特定任务、用某种语言编写的一组指令的集合 进程:正在运行的程序 线程:程序内部一条执行路径 2.代码完成继承Thread的方式创建分线程，并遍历100以内的自然数. 3.代码完成实现Runnable接口的方法创建分线程，并遍历100以内的自然数 4.对比两种创建方式开发中如何选择什么时候用这些 他们有啥不同呀 5.说说你对IDEA中Project 和Module的理解。2.IDEA的使用和多线程的概念 01.程序(programm)概念: 是为完成持定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。| 02.进程(process)概念:程序的一次执行过程,或是正在运行的一个程序。 说明:进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程(thread)概念:进程可进一步细化为线程,是一-个程序内部的一一条执行路径。 说明:线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc),线程切换的开销小 01.单核CPU与多核CPU的理解 02.并行与并发的理解并行:多个CPU同时执行多个任务。比如:多个人同时做不同的事。并发:一个CPU(采用时间片)同时执行多个任务。比如:秒杀、多个人做同一件事 3.线程的创建与常用方法方式一:继承Thread类的方式:1.创建一个继承于Thread类的子类2.重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中3.创建Thread类的子类的对象4.通过此对象调用start()说明两个问题:①启动当前线程 ②调用当前线程的run() 问题一:我们启动一个线程，必须调用start(), 不能调用run()的方式启动线程。问题二:如果再启动-一个线程，必须重新创建一个Thread子类的对象， 调用此对象的start(). 方式二:实现Runnable接口的方式:1.创建一个实现了Runnable接口的类2.实现类去实现Runnable中的抽象方法: run()3.创建实现类的对象4.将此对象作为参数传递到Thread类的构造器中， 创建Thread类的对象5.通过Thread类的对象调用start() 两种方式的对比:开发中:优先选择:实现Runnable接口的方式原因:1.实现的方式没类的单继承性的局限性2.实现的方式更适合来处理多个线程共享数据的情况。联系: public class Thread implements Runnable相同点:两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。目前两种方式，要想启动线程，都是调用的Thread类中的start()。 Thread类中的常用方法:1.start():启动当前线程;调用当前线程的run()2.run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中3.currentThread(): 静态方法，返回执行当前代码的线程4.getName(): 获取当前线程的名字5.setName(): 设置当前线程的名字6.yield(): 释放当前cpu的执行权7.join(): 在线程a中调用线程b的join(),此时线程a就进入阻塞状态,直到线程b完全执行完以后，线程a才结束阻塞状态。8.stop():已过时。 当执行此方法时，强制结束当前线程。9.sleep(long millitime): 让当前线程“睡眠”指定的millitime毫秒。在指定的millitime 毫秒时间内,当前线程是阻塞状态。10.isAlive():判断当前线程是否存活 线程的优先级:1.MAX_ PRIORITY: 10MIN_ PRIORITY: 1NORM PRIORITY: 5 –&gt;默认优先级2.如何获取和设置当前线程的优先级:getPriority():获取线程的优先级setPriority(int p): 设置线程的优先级说明:高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲,高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。 线程通信: wait() / notify() / notifyAll() ::此三个方法定义在0bject类中的。 进程可以细化为多个线程，每个线程，拥有自己独立的:栈、程序计数器多个线程，共享同一个进程中的结构:方法区、堆 补充线程分类: 主线程 就是用户线程‘ 守护线程:gc垃圾回收线程 守护线程依赖主线程 用户线程死了 守护线程就没用了 同步机制 线程的生命周期8-3 线程的生命周期 五种状态的转换 8-4 线程的同步(难点) 安全5.理解线程安全问题 6..理解线程安全问题举例和解决措施例子：创建三个窗口卖票，总票数为100张.使用实现Runnable接口的方式1.问题：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 打比方–&gt;厕所4.在Java中，我们通过同步机制，来解决线程的安全问题。 5.同步的方式，解决了线程的安全问题。—好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 —局限性 方式一：同步代码块 synchronized(同步监视器){ //需要被同步的代码 } 说明：1.操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。任意 要求：多个线程必须要共用同一把锁。 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 7.同步代码块处理实现Runnable的线程安全问题 方式二 ：可把obj 改成this 8.同步代码块处理继承Thread类的线程安全问题 —注意用同一把锁 上面的不能解决 下图解决 对象加个static 就可以了 第二手段 把obj改成Windows2.class，因为Windows2.class只会加载一次 错误this 代表着t1，t2，t3三个对象 补充:在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 9. 同步方法处理实现Runnable的线程安全问题.方式二：同步方法。 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 同步监视器就是this 10.同步方法处理继承Thread类的线程安全问题 同步方法的总结: 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 非静态的同步方法，同步监视器是：this静态的同步方法，同步监视器是：当前类本身 理解下，自己把它写一下 11.线程安全的单例模式之懒汉式 问题: 修改如下: 方式一 上面的效率差 打比方: 抢苹果手机 效率超高 12.死锁的问题 }.start(); new Thread（code ).start(); 1.死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁2.说明：1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续2）我们使用同步时，要避免出现死锁。 修改线程名字 Thread.currentThread().setName(“线程名字”) 13.Lock方式解决线程安全问题 解决线程安全问题的方式三：Lock锁 — JDK5.0新增 * 面试题：synchronized 与 Lock的异同？ 相同：二者都可以解决线程安全问题 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()） 2.使用的优先顺序： synchronized使用多Lock -&gt; 同步代码块（已经进入了方法体，分配了相应资源） -&gt;同步方法（在方法体之外） 面试题:如何解决线程安全问题?有几种方式 公平是先进先出的 括号里面true 默认是false 抢占式 2-3之间类似单线程的 14.同步机制的课后练习有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 分析： 1.是否是多线程问题？ 是，两个储户线程 2.是否有共享数据？ 有，账户（或账户余额） 3.是否有线程安全问题？有 4.需要考虑如何解决线程安全问题？同步机制：有三种方式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.atguigu.exer;/** * 银行有一个账户。 有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。 分析： 1.是否是多线程问题？ 是，两个储户线程 2.是否有共享数据？ 有，账户（或账户余额） 3.是否有线程安全问题？有 4.需要考虑如何解决线程安全问题？同步机制：有三种方式。 * @author shkstart * @create 2019-02-15 下午 3:54 */class Account{ private double balance; public Account(double balance) { this.balance = balance; } //存钱 public synchronized void deposit(double amt){ if(amt &gt; 0){ balance += amt; try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":存钱成功。余额为：\" + balance); } }}class Customer extends Thread{ private Account acct; public Customer(Account acct) { this.acct = acct; } @Override public void run() { for (int i = 0; i &lt; 3; i++) { acct.deposit(1000); } }}public class AccountTest { public static void main(String[] args) { Account acct = new Account(0); Customer c1 = new Customer(acct); Customer c2 = new Customer(acct); c1.setName(\"甲\"); c2.setName(\"乙\"); c1.start(); c2.start(); }} 写 extends，lock 要生成静态的，，在这里是使用了this 15.线程通讯的例题8-5 线程的通信两个线程之间并行 有交流 例题: 使用两个线程打印1-100。线程1,线程2交替打印 一旦执行wait 就会释放锁 涉及到的三个方法：wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。 说明：1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常 外面生成一个object 要是同一把锁 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。 16.sleep() 和 wait()的异同 面试题：sleep() 和 wait()的异同？1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。2.不同点： 1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait() 2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中 3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。 17.线程通讯 生产消费者例子 线程通信的应用:经典例题:生产者/消费者问题生产者(Productor)将产品交给店员(Clerk),而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20)，如果生产者试图生产更多的产品，店员会叫生产者停-下,如果店中有空位放产品了再通知生产者继续生产;如果店中没有产品了,店员会告诉消费者等一下， 如果店中有产品了再通知消费者来取走产品。分析:1.是否是多线程问题?是，生产者线程，消费者线程2.是否有共享数据?是，店员(或产品)3.如何解决线程的安全问题?同步机制,有三种方法4.是否涉及线程的通信?是 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108class Clerk{ private int productCount = 0; //生产产品 public synchronized void produceProduct() { if(productCount &lt; 20){ productCount++; System.out.println(Thread.currentThread().getName() + \":开始生产第\" + productCount + \"个产品\"); notify(); }else{ //等待 try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } //消费产品 public synchronized void consumeProduct() { if(productCount &gt; 0){ System.out.println(Thread.currentThread().getName() + \":开始消费第\" + productCount + \"个产品\"); productCount--; notify(); }else{ //等待 try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } } }}class Producer extends Thread{//生产者 private Clerk clerk; public Producer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(getName() + \":开始生产产品.....\"); while(true){ try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } clerk.produceProduct(); } }}class Consumer extends Thread{//消费者 private Clerk clerk; public Consumer(Clerk clerk) { this.clerk = clerk; } @Override public void run() { System.out.println(getName() + \":开始消费产品.....\"); while(true){ try { Thread.sleep(20); } catch (InterruptedException e) { e.printStackTrace(); } clerk.consumeProduct(); } }}public class ProductTest { public static void main(String[] args) { Clerk clerk = new Clerk(); Producer p1 = new Producer(clerk); p1.setName(\"生产者1\"); Consumer c1 = new Consumer(clerk); c1.setName(\"消费者1\"); Consumer c2 = new Consumer(clerk); c2.setName(\"消费者2\"); p1.start(); c1.start(); c2.start(); }} 18.创建多线程的方式三:实现Callable接口8-6 JDK5.0新增线程创建方式真正开发用线程池 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ call()可以有返回值的。 call()可以抛出异常，被外面的操作捕获，获取异常的信息 Callable是支持泛型的 19.使用线程池的好处 重复利用坐车去北京天安门 20.创建多线程的方式四:使用线程池 很多时候用框架就实现了 面试题：创建多线程有几种方式？四种！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://zhenqk.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"IDEA学习与多线程","date":"2016-06-30T03:30:13.000Z","path":"2016/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/","text":"1.java语言高级概述完成具体功能该怎么做 集合替换数组 做 具体的事情 如何使用API 2. idea卸载 配置文件 删除又是最新的 system 缓存文件 索引 使用control–&gt;卸载 重装 建议重启电脑 3.idea的介绍STS 2018.3.4 学技术 必须先找官网 4.idea的安装5.启动IDEA 并实现helloWorld “hellow”.sout 6.module的理解和创建 点击工程 new Module 每个功能建立模块 7.idea 常用配置五 悬浮提示 自动导报 8.快捷键的设置9.模板的使用和配置 live tem 是可以做修改和添加的 psvm sout for i iter itar list.for list.fori 普通 list.forr 逆序 ifn inn xxx.nn xxx.null prsf 单例 psf psfs psfi soutp形参 m方法名 v变量 thr 10.程序进程线程的概念8-1 基本概念程序、进程、线程 程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码， 静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是-一个动态的过程:有它自身的产生、存在和消亡的过程.——–生 命周期➢如:运行中的QQ，运行中的MP3播放器➢程序是静态的，进程是动态的➢进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程(thread)，进程可进一步细化为线程， 是一个程序内部的一条执行路径。➢若一个进程同一时间并行执行多个线程，就是支持多线程的➢线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小➢一个进程中的多个线程共享相同的内存单元/内存地址空间≥它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。同时在执行，需要解决线程同步的安全问题 11 单核CPU和多核CPU的理解 单核CPU，其实是一种假的多线程，因为在-一个时间单元内，也只能执行一个线程的任务。例如:虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”(晾着他， 等他想通了，准备好了钱，再去收费)。但是因为CPU时间单元特别短，因此感觉不出来。 如果是多核的话，才能更好的发挥多线程的效率。 (现在的服务器都是多核的) 一个Java应用程序java.exe， 其实至少有三个线程: main()主线程， gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 并行与并发 并行:多个CPU同时执行多个任务。比如:多个人同时做不同的事。 每个车道开自己的，篮球场 并发:一个CPU(采用时间片)同时执行多个任务。比如:秒杀、多个人做同一件事。 抢火车票 12使用 多线程的优点背景:以单核CPU为例， 只使用单个线程先后完成多个任务(调用多个方法)，肯定比用多个线程来完成用的时间更短，为何仍需多线程呢?多线程程序的优点: 1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验。2.提高计算机系统CPU的利用率3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 何时需要多线程 程序需要同时执行两个或多个任务。 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。 需要一些后台运行的程序时。 java gc美团外卖往上划图片8-2 线程的创建和使用(重点)13 创建多线程方式一 继承Thread类 看能不能那一条线划出来 Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。 Thread类的特性➢ 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体➢ 通过该Thread对象的star()方法来启动这个线程，而非直接调用run()重写人家的看人家怎么生成多线程的创建，方式一：继承于Thread类 创建一个继承于Thread类的子类 重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start() 3，4 主线程做 怀孕 run 独立去执行 14.创建过程中两个问题的说明4.通过此对象调用start():@启动当前线程②调用当前线程的run()| 若只调t1.run() 不会开启线程 Thread.currentThread().getName() 获取当前线程名字 15.继承方式的课后练习src下建立包 练习:创建两个分线程，其中一一个线程遍历100 以内的偶数，另一个线程遍历100以内的奇数(两个线程做事不一样) 创建2个子类对象，实现就可以了。提供各自的run 第二种方法 创建两个匿名子类 重写run方法， new的是子类对象，Thread充当的 16.线程的常用方法 void start():启动线程，并执行对象的run()方法 run():线程在被调度时执行的操作 String getName():返回线程的名称 void setName(String name):设置该线程名称 static Thread currentThread():返回当前线程。在Thread子 类中就是this，通常用于主线程和Runnable实现类 测试Thread中的常用方法：1.start():启动当前线程；调用当前线程的run()2.run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中3.currentThread():静态方法，返回执行当前代码的线程4.getName():获取当前线程的名字5.setName():设置当前线程的名字 第二种 通过构造方法来修改 6.yield():释放当前cpu的执行权 this 可省略或改成 Thread.currentThread().getName() 7.join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。 下图的线程a就是主线程 h1执行完后才会执行主线程 应用 场景，一个正在执行线程需要另外一个线程的数据 大比方，领导蹭饭 8.stop():已过时。不推荐使用 当执行此方法时，强制结束当前线程。9.sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。 应用场景:倒计时 …. 10.isAlive():判断当前线程是否存活 17.线程优先级的设置 抢占式 打比方 银行排队 线程的优先级：1.MAX_PRIORITY：10MIN _PRIORITY：1NORM_PRIORITY：5 –&gt;默认优先级2.如何获取和设置当前线程的优先级： getPriority():获取线程的优先级 setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。 18.继承Thread方式,多窗口卖票创建三个窗口卖票，总票数100张 方法一: private static int ticket=100 ；出现线程安全问题 19.创建多线程方式二，实现Runnable接口创建多线程的方式二：实现Runnable接口 创建一个实现了Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 调用了Runnable类型的target的run() 代理模式 再次创建一个线程 只能这样写 获取进程名字 t1.setName(“线程1”) 20.实现Runnable方式,多窗口卖票 alt+enter 也存在线程安全问题，100张票，因为制造了一个对象 21.两种创建方式的对比比较创建线程的两种方式。开发中：优先选择：实现Runnable接口的方式原因：1. 实现的方式没有类的单继承性的局限性 2. 实现的方式更适合来处理多个线程有共享数据的情况。联系：public class Thread implements Runnable相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://zhenqk.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"IDEA","slug":"IDEA","permalink":"http://zhenqk.github.io/tags/IDEA/"}]},{"title":"异常处理","date":"2016-06-29T22:58:49.000Z","path":"2016/06/30/2016-06-30-yi-chang-chu-li/","text":"1.每日一考抽象和接口是中心 1.abstract 能修饰哪些结构?修饰以后， 有什么特点?类、方法static final abstract类不能实例化，提供子类 extends抽象方法，，只定义了一种功能的标准。具体的执行,需要子类去实现。 2.接口是否能继承接口?抽象类是否能实现(implements)接口?抽象类是否能继承非抽象的类?。能；能；能（object） 3.声明抽象类，并包含抽象方法。测试类中创建 一个继承抽象类的匿名子类的对象匿名子类的对象。abstract AA{public abstract void m();}main(){AAa = new AA(){public void m(){ }};a.m();} 4.抽象类和接口有哪些共同点和区别?不能实例化不同类:抽象类 有构造器 ，接口没有多继承VS单继承接口往类方向靠近5.如何创建静态成员内部类和非静态成员内部类的对象?Person static Dog BirdPerson.Dog dog = new Person.Dog();Person p = new Person();Person.Bird bird = p.new Bird();理解没用 还是要做些2遍 2.抽象类abstract:抽象的1.可以用来修饰:类、方法2.具体的:abstract修饰类:抽象类 此类不能实例化 抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化的全过程) 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作—&gt;抽象的使用前提:继承性 abstract修饰方法:抽象方法 抽象方法只方法的声明，没方法体 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。 若子类重写了父类中的所的抽象方法后，此子类方可实例化 若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰 3.注意点:1.abstract不能用来修饰:属性、构造器等结构2.abstract不能用来修饰私方法、静态方法、final的方法、final的类今天方法不能被重写 abstract的应用举例:public void method(Person p){}交通工具 举例二 求面积IO流 想继承必须要重写举例三: I0流中设计到的抽象类: InputStream/outputStream|Reader /Writer在内部定义类抽象的read(）) 模板方法的设计模式1.解决的问题在软件开发中实现-一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。2.举例花费了多长时间原来就是模板3.应用场景 3. 复习 接口interface:接口1.使用说明:比较清楚理解这个事就可以 ，主要是多写代码2.举例: U盘插电脑 体会: 1.接口使用，上也满足多态性 2.接口，实际上就是定义了一种规范 3.开发中，体会面向接口编程! 3.体会面向接口编程的思想 JDBC 技术 操作数据库的规范 sun定义规范 面向接口编程:我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个数据库厂商的API。 4.Java8中关于接口的新规范 对大家要求不高 //知识点1:接口中定义的静态方法，只能通过接口来调用。//知识点2:通过实现类的对象，可以调用接口中的默认方法。.//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法//知识点3:如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则//知识点4:如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，//那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。//这就需要我们必须在实现类中重写此方法 //知识点5:如何在子类(或实现类)的方法中调用父类、接口中被重写的方法public void myMethod(){method3();//调用自己定义的重写的方法.super . method3();//调用的是父类中声明的//调用接口中的默认方法CompareA. super . method3();CompareB . super . method3();} 5.面试题: 抽象类和接口的异同 往新特征靠 java7 定义常量和方法 java8 静态方法 Java 9 私有方法 抽象类和接口的异同?相同点:不能实例化;都可以包含抽象方法的。.不同点:1)把抽象类和接口(java7, java8, java9)的定义、内部结构解释说明2)类:单继承性接口:多继承类与接口:多实现 代理模式1.解决的问题代理模式是Java开发中使用较多的-种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。2.举例 代理上网，明星经纪人 3.应用场景 工厂模式工厂方法 抽象工厂 1.解决的问题实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。2.具体模式 简单工厂模式:用来生产同一等级结构中的任意产品。(对于增加新的产品， 需要修改已有代码) 厂方法模式:用来生产同一等级结构中的固定产品。(支持增加任意产品 抽象工厂模式:用来生产不同产品族的全部产品。(对于增加新的产品， 无能为力;支持增加产品族4 复习内部类内部类:类的第五个成员 1.定义:Java中允许将-一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.2.内部类的分类:成员内部类(静态、非静态)Vs局部内部类(方法内、代码块内、构造器内) 3.成员内部类的理解: 4.成员内部类:4.1如何创建成员内部类的对象?(静态的，非静态的)//创建静态的Dog内部类的实例(静态的成员内部类):Person.Dog dog = new Person.Dog();//创建非静态的Bird内部类的实例(非静态的成员内部类)://Person.Bird bird = new Person. Bird();//错误的Person p = new Person() ;Person.Bird bird = p.new Bird(); 4.2如何在成员内部类中调用外部类的结构?dlass Bird{String name =“杜鹃”;public void display(String name ){System. out . println(name);//方法的形参System. out. print1n( this. name);//内部类的属性System. out . print1n(Person. this . name);//外部类的属性} 5.局部内部类的使用:/ /返回一个实现了Comparable接口的类的对象public Comparable getComparable(){注意点：前台开发 android 在局部内部类的方法中（比如：show）如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,要求此局部变量声明为final的。 副本不能更改，只能用本身 jdk 7及之前版本：要求此局部变量显式的声明为final的jdk 8及之后的版本：可以省略final的声明 总结:成员内部类和局部内部类，在编译以后，都会生成字节码文件。格式:成员内部类:外部类$内部类名.class局部内部类:外部类$数字内部类名.class 6.异常概述7-1异常概述与异常体系结构在使用计算机语言进行项目开发的过程中，即序员把代码写得 尽善美 ， 在系统的运行过程中仍然会遇到一些问题，因为很多不是靠代码能够避免的，比如:客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。 异常:在Java语言中，将程序执行中发生的不正常情况称为“异常’。(开发过程中的语法错误和逻辑错误不是异常) Java程序在执行过程中所发生的异常事件可分为两类:➢Error: Java虛 拟机无法解决的严重问题。如: JVM系统内部错误、资源.耗尽等严重情况。比如: StackOverflowError和OOM。一般不编写针对性的代码进行处理。➢Exception:其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如: 空指针访问 试图读取不存在的文件 网络连接中断 数组角标越界 Error:Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性的代码进行处理。 123456789public class ErrorTest { public static void main(String[] args) { //1.栈溢出：java.lang.StackOverflowError// main(args); //2.堆溢出：java.lang.OutOfMemoryError OOM Integer[] arr = new Integer[1024*1024*1024]; }} 7.异常的分类 对于这些错误，一 般有两种解决方法:一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。 （打比方 生病了 ，工作做不了的;提前拿药；过高速路口 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。比如:除数为0，数组下标越界等 ➢分类:编译时异常和运行时异常Throwable 顶级父类Exception7-2常见异常一、异常体系结构 java.lang.Throwable |—–java.lang.Error:一般不编写针对性的代码进行处理。 |—–java.lang.Exception:可以进行异常的处理 |——编译时异常(checked) |—–IOException |—–FileNotFoundException |—–ClassNotFoundException |——运行时异常(unchecked,RuntimeException) |—–NullPointerException |—–ArrayIndexOutOfBoundsException |—–ClassCastException |—–NumberFormatException |—–InputMismatchException |—–ArithmeticException 面试题：常见的异常都有哪些？举例说明 8.常见异常的举例编译时异常举例 9.异常处理方式概述7-3异常处理机制一: try- catch-fially(自己可以搞定) Java提供的是异常处理的抓拋模型。 Java程序的执行过程中如出现异常，会生成一一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。 异常对象的生成➢由虚拟机自动生成:程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出————自动抛出➢由开发人员手动创建: Exception exception = new ClassCastException();一创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样 一、异常的处理：抓抛模型 过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出,一旦抛出对象以后，其后的代码就不再执行关于异常对象的产生：① 系统自动生成的异常对象② 手动的生成一个异常对象，并抛出（throw）过程二：”抓”：可以理解为异常的处理方式：① try-catch-finally ② throws 10.try-catch 方式二、try-catch-finally的使用 try{ //可能出现异常的代码 }catch(异常类型1 变量名1){ //处理异常的方式1}catch(异常类型2 变量名2){ //处理异常的方式2}catch(异常类型3 变量名3){ //处理异常的方式3}….finally{ //一定会执行的代码} 说明： finally是可选的。 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的 try-catch结构（在没有写finally的情况）。继续执行其后的代码 catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 常用的异常对象处理的方式： ① String getMessage() ② printStackTrace() 详细 在try结构中声明的变量，再出了try结构以后，就不能再被调用 try-catch-finally结构可以嵌套 体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。 针对于编译时异常，我们说一定要考虑异常的处理。 11.finally的使用try-catch-finally中finally的使用： 1.finally是可选的 2.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。 3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。 垃圾回收机制只回收JVM堆内存里的对象空间。对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力 需要自己关流 编译器自己surround With try/cath 12.编译时异常和运行时异常订单不同处理运行时异常 不考虑try-catch处理 编译时异常 考虑 13.处理异常:throws 方式7-4异常处理机制二: throws(搞不定，找别人 往上报)异常处理的方式二：throws + 异常类型 “throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。 异常代码后续的代码，就不再执行！ 体会：try-catch-finally:真正的将异常给处理掉了。 throws的方式只是将异常抛给了方法的调用者。 并没有真正将异常处理掉。 开发中如何选择使用try-catch-finally 还是使用throws？ 3.1 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。 3.2 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 二选择一 往上扑出，往上剖 ，异常并没有解决掉 14.重写方法抛出的规则方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 15.开发中如何选择那中方式处理异常16.手动抛出异常对象7-5手动抛出异常: throw 产生手动 throw 抛出异常 throws 异常处理的一种方式 new RuntimeException或Exception throw new Exception(“ns”) 需要做处理 throws一下throws 体现异常处理，在方法声明处 生成一个异常对象，在方法里面 17.如何自动义异常7-6用户自定义异常类如何自定义异常类?1.继承于现有的异常结构: RuntimeException、Exception2.提供全局常量: serialVersionUID3.提供重载的构造器 只有异常体系才能throw 18.基本使用 19.异常处理的练习 20.异常处理章节总结异常1.异常的体系结构 2.从程序执行过程，看编译时异常和运行时异常 编译时异常:执行javac . exe命名时，可能出现的异常 运行时异常:执行java. exe命名时，可能出现的异常I 3.常见的异常类型，请举例说明: 异常的处理 java异常处理的抓抛模型过程一:“抛”:程序在正常执行的过程中，一一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。关于异常对象的产生:①系统自动生成的异常对象②手动的生成一个异常对象，并抛出(throw)|过程二:“抓”: 可以理解为异常的处理方式:①try-catch-finally ② throws 2.2.异常处理方式一try-cakch-finally|2.1使用说明: 、try-catch-finally的使用 try{ //可能出现异常的代码 }catch(异常类型1 变量名1){ //处理异常的方式1}catch(异常类型2 变量名2){ //处理异常的方式2}catch(异常类型3 变量名3){ //处理异常的方式3}….finally{ //一定会执行的代码} 说明： finally是可选的。 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的 try-catch结构（在没有写finally的情况）。继续执行其后的代码 catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 常用的异常对象处理的方式： ① String getMessage() ② printStackTrace() 详细 在try结构中声明的变量，再出了try结构以后，就不能再被调用 try-catch-finally结构可以嵌套 总结:如何看待代码中的编译时异常和运行时异常? 体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。 针对于编译时异常，我们说一定要考虑异常的处理。 编译时异常 必须进行处理 2.2: finally的再 说明: 1.finally是可省略的 2.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。 3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。I 2.3: [面试题]final、finally. finalize三者的区别? 类似: throw和throwsCollection和CollectionsString、StringBuffer. StringBuilderArrayList、LinkedListHashMap、LinkedHashMap重写、重载 结构不相似的:抽象类、接口==、equals()sleep()、wait() 3.异常处理方式二: “throws +异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成-一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行! 4.对比两种处理方式try-catch-finally: 真正的将异常给处理掉了throws的方式只是将异常抛给了方法的调用者。|并没真正将异常处理掉。 5.体会开发中应该如何选择两种处理方式?5.1 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理.5.2 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。 补充:方法重写的规则之一:子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 手动抛出异常对象1.使用说明在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw-个异常类的对象。 2.[面试题]throw和throws 区别:throw表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。throws属于异常处理的一种方式，声明在方法的声明处。 3.典型例题; 自定义异常对象如何自定义一个异常类? 项目三开发团队人员调度软件 项目三软件架构 处理语言的能力 throw new TeamException(“找不到指定的员工”) 各个详情不一样， 多态 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"异常处理","slug":"异常处理","permalink":"http://zhenqk.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"面向对象(下)补1","date":"2016-06-29T03:17:18.000Z","path":"2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/","text":"1. 每日一考1.static修饰的属性，相较于实例变量，有哪些特别之处(&gt;=3点)随着类的加载而加载:早于对象的创建;只要权限允许，可以通过”对象.static属性”的方式进行调用:存在于方法区的静态域。 2.final可以用来修饰哪些结构，分别表示什么意思。3.代码实现单例模式的饿汉式44.代码实现单例模式的懒汉式5.类的属性赋值的位置有哪些?先后顺序为何?默认初始化显式初始化、代码块中初始化构造器中初始化通过”对象.属性”或”对象.方法”的方式赋值 2.复习staticstatic:静态的1.可以用来修饰的结构:主要用来修饰类的内部结构属性、方法、代码块、内部类 2.static修饰属性: 静态变量(或类变量)​2.1 属性，按是否使用static修饰，又分为：静态属性vs 非静态属性(实例变量) 实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。2.2 static修饰属性的其他说明：① 静态变量随着类的加载而加载。可以通过\"类.静态变量\"的方式进行调用② 静态变量的加载要早于对象的创建。③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。④ 类变量 实例变量类 yes no对象 yes yes2.3 静态属性举例：System.out; Math.PI; 3.静态变量内存解析:4.static修饰方法: 静态方法、类方法 ① 随着类的加载而加载，可以通过”类.静态方法”的方式进行调用② 静态方法 非静态方法 类 yes no 对象 yes yes③ 静态方法中，只能调用静态的方法或属性 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 5.static的注意点: 5.1在静态的方法内，不能使用this关键字、super关键字5.2关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。 6.如何判定属性和方法应该使用static关键字: 身份证号加final 构造中赋值 static 6.1关于属性 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。类中的常量也常常声明为static 6.2关于方法 操作静态属性的方法，通常设置为static的工具类中的方法，习惯上声明为static的。 比如: Math、 Arrays、 Collections 7.使用举例:举例一: Arrays、 Math、Collections等工具类举例二:单例模式举例三:class Circle{private double radius ;private int id;//自动赋值public Circle(){id = init++; .total++;}public Circle(double radius){this();//id = init++;//total++;this.radius = radius;} 3.单例模式1.设计模式的说明1.1 理解设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。1.2常用设计模式— 23种经典的设计模式创建型模式，共5种: 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。结构型模式，共种:适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。行为型模式，共11种:策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。GOF工作上手了 ，，那数据结构、设计模式 、JVM 2.单例模式2.1要解决的问题:所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 2.2具体代码的实现:饿汉式懒汉式;2.3两种方式的对比:饿汉式:坏处:对象加载时间过长。好处:饿汉式是线程安全的懒汉式:好处:延迟对象的创建。目前的写法坏处:线程不安全。—&gt;到多线程内容时，再修改 效率差 4.复习main()1.main()方法作为程序的入口2.main()方法也是一个普通的静态方法3.main()方法可以作为我们与控制台交互的方式。 (之.前: 使用Scanner 如何将控制台获取的数据传给形参: String[] args?运行时: java 类名’Tom” “Jerry” “123” “true“sysout(args[0]);//“Tomsysout(args[3]);//“true”– &gt;Boolean. parseBoolean(args[3]);sysout(args[4])//报异常 最好 length-1 方法体:来体现方法的功能 你哪知道他有多少子类 所以传入父类就可以了 5.代码块和final类的成员之四:代码块(初始化块) (重要性较属性、方法、构造器差一些)1.代码块的作用:用来初始化类、对象的信息 2.分类 :代码块要是使用修饰符，只能使用static 分类:静态代码块 VS 非静态代码块 3. 静态代码块: 内部可以输出语句随着类的加载而执行，而且只执行一次作用:初始化类的信息如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行静态代码块的执行要优先于非静态代码块的执行静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块: 内部可以输出语句随着对象的创建而执行每创建一个对象，就执行一-次非静态代码块作用:可以在创建对象时，对对象的属性等进行初始化如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、静态的方法 4.实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序: 对应的练习: LeafTest. java /I Son. java 由父及子，静态先行。 ①默认初始化②显式初始化/⑤在代码块中赋值③构造器中初始化④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值执行的先后顺序:①-②/⑤-③-④ final:最终的1.可以用来修饰: 可以用来修饰:类、方法、变量 2.具体的: final 用来修饰一个类:此类不能被其他类所继承。比如：String类、System类、StringBuffer类 final 用来修饰方法：表明此方法不可以被重写比如：Object类中getClass(); final 用来修饰变量：此时的”变量”就称为是一个常量3.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化 3.2 final修饰局部变量： 尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final 用来修饰属性：全局常量 6. 抽象类和抽象方法的使用 老大不在做事了，交给下面做 abstract关键字的使用1.abstract:抽象的2.abstract可以用来修饰的结构：类、方法 抽象 类不能实例化3.abstract修饰类：抽象类 &gt; 此类不能实例化 &gt; 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程） &gt; 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 abstract修饰方法：抽象方法/ /抽象方法Tpublic abstract void eat(); 抽象方法只有方法的声明，没有方法体包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。若子类重写了父类中的所有的抽象方法后，此子类方可实例化若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰 6 -7 抽象的应用场景提示必须进行方法的重写抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。 8.abstract使用中的注意点abstract使用上的注意点：1.abstract不能用来修饰：属性、构造器等结构 2.abstract不能用来修饰私有方法、静态方法、final的方法、final的类 9. 基本操作—抽象性的练习大四 过去 努力不一定成功 不努力一定不成功 问题 1：为什么抽象类不可以使用 final 关键字声明？问题 2：一个抽象类中可以定义构造器 吗？ 可以问题 3：是否可以这样理解：抽象类就比普通多定义 了抽象方 法，除了不能直接 进行类的 实例化操作之外，并没有任何的不同? 编写一个 Employee Employee Employee 类，声明为抽象类，包含如下三个 属性： name ，id ，salary。提供必要的构造器和抽象方法： work()对于 Manager Manager Manager 类来说，他既是员工还具有奖金 (bonus (bonus )的属性。请使用继承的思想，设计CommonEmployee类和 Manager Manager类 ，要求中提供必要的方法进行属性访问。 10.创建抽象类的匿名子类对象 匿名子类 person 子类的重写 method(p) 匿名只用一次，省事， 懒得像这样，用一次new 一次对象 q 最省事的匿名子类的匿名对象 能看懂别人写代码的意图就可以了 11. 模板方法的设计模式及应用场景 多态的应用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.atguigu.java;/* * 抽象类的应用：模板方法的设计模式 * */public class TemplateTest { public static void main(String[] args) { SubTemplate t = new SubTemplate(); t.spendTime(); }}abstract class Template{ //计算某段代码执行所需要花费的时间 public void spendTime(){ long start = System.currentTimeMillis(); //像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码 this.code();//不确定的部分、易变的部分 long end = System.currentTimeMillis(); System.out.println(\"花费的时间为：\" + (end - start)); } public abstract void code(); }class SubTemplate extends Template{ @Override public void code() { for(int i = 2;i &lt;= 1000;i++){ boolean isFlag = true; for(int j = 2;j &lt;= Math.sqrt(i);j++){ if(i % j == 0){ isFlag = false; break; } } if(isFlag){ System.out.println(i); } } } } 模板方法 12.抽象方法的课后练习13.接口的理解 一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。 另一方面，有时必须从几个类中抽取出一-些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如:鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。 接口就是规范，定义的是- -组规则，体现了现实世界中“如果你是/要..则必须能..”的思想。继承是一个\"是不是\"的关系，而接口实现则是\"能不能\" 的关系。 接口的本质是契约，标准，规范，就像我们的法律- -样。制定好后大家都要遵守。 if 要飞，必须实现 举例 虚线 类和接口的关系实现 is a的关系 14.接口的定义和引用接口的使用1.接口使用interface来定义2.Java中，接口和类是并列的两个结构3.如何定义接口：定义接口中的成员 3.1 JDK7及以前：只能定义全局常量和抽象方法 &gt;全局常量：public static final的.但是书写时，可以省略不写 &gt;抽象方法：public abstract的 可省略 publicabstract 的 3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略） 接口中不能定义构造器的！意味着接口不可以实例化 Java开发中，接口通过让类去实现(implements)的方式来使用.如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类abstract class A{ } Java类可以实现多个接口 —&gt;弥补了Java单继承性的局限性 格式：class AA extends BB implements CC,DD,EE 接口与接口之间可以继承，而且可以多继承 接口的具体使用，体现多态性 接口，实际上可以看做是一种规范 面试题：抽象类与接口有哪些异同？ 15.接口的多实现和接口的继承性（多态性的体现 接口和抽象类） 16.实例演示接口是一种规范不同的USB接口 传输速率不一样，不知道用途 ，定义了抽象方法 以后任何方法 都要接受规范 实现类的集合 就是驱动 接口的使用 1.体现了接口的多态性 2.接口实际上定义了一种规范 3.开发中，体会面向接口编程 JDBC 如何操作数据库的规范 MySQL Driver 是接口实现类的集合 面向接口的编程 项目的具体需求是多变的,我们必须以不变应万变才能从容开发,此处的”不变”就是”规范”。因此,我们开发项目往往都是面向接口编程? 接口的主要用途就是被实现类实现 17.创建接口匿名实体类的对象 匿名实现类没有用所以用 new USB代替 com.transferDate(phone) phone 可以多次使用 没有名用父类对象名充当的 —&gt; 上面是匿名实现类 18.接口的应用–&gt;代理模式实用性为主 用着用着感觉 ，，还真是？ 代理类 和 被代理类 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.atguigu.java1;/* * 接口的应用：代理模式 * */public class NetWorkTest { public static void main(String[] args) { Server server = new Server();// server.browse(); ProxyServer proxyServer = new ProxyServer(server); proxyServer.browse(); }}interface NetWork{ public void browse(); }//被代理类class Server implements NetWork{ @Override public void browse() { System.out.println(\"真实的服务器访问网络\"); }}//代理类class ProxyServer implements NetWork{ private NetWork work; public ProxyServer(NetWork work){ this.work = work; } public void check(){ System.out.println(\"联网之前的检查工作\"); } @Override public void browse() { check(); work.browse(); } } 上面静态代理类 19.接口应用：工厂模式— 一个了解的例子工厂模式:实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。小其实设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维护，解决方式就是一个“分工”。。社会的发展也是这样，分工越来越细。小原始社会的人:人什么都要会，自己种，自己打猎，自己织衣服，自己治病现在的人:可以只会一样，其他都不会，只会Java也能活，不会做饭，不会开车，不会….. 只是创建者 上面也叫静态工厂 缺点:对于增加新产品，不修改代码的话，是无法扩展的。违反了开闭原则(对扩展开放:对修改封闭)。 需要对现有代码进行修改 工厂方法模式 抽象工厂 了解下就可以了 ，，主要是对接口的使用 接口和抽象类的对比 20. 接口课后两道笔试题 pX() 有误 编译有误，由于X是不确定的 没毛病的 football 常量是final 静态的 21.接口练习—- 比较对象的大小 这个对象按照什么顺序排；对象是可排序的 22.Java8中接口的新特性 父类中重写 method3(sup) 要是都没有方法体 或抽象的 确定有问题 public inteface CompareB{ default void method3(){ sout(“compre:上肢”) } } 解决办法:必须在实现类中重写此方法 目前静态方法非常少 23.Java8 接口新特性的应用 而第二种 第三种 谁都没听 –&gt;第五个知识点 关于接口的改进 24.内部类的分类(实际开发很少写 应用型差) 当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。 在Java中，允许-一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。 Innerclass–般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。➢Innerclass的名字不能与包含它的外部类类名相同; 分类:成员内部类(static成员内部类和非static成员内部类)局部内部类(不谈修饰符)、匿名内部类person 与大脑 1.Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类2.内部类的分类：成员内部类（静态、非静态） vs 局部内部类(方法内、代码块内、构造器内)3.成员内部类： 一方面，作为外部类的成员： 调用外部类的结构 可以被static修饰 可以被4种不同的权限修饰 另一方面，作为一个类： 类内可以定义属性、方法、构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 4.关注如下的3个问题 4.1 如何实例化成员内部类的对象 4.2 如何在成员内部类中区分调用外部类的结构 4.3 开发中局部内部类的使用 见《InnerClassTest1.java》 局部内部类 25.成员内部类的特点 26. 如何实例化成员内部类 27. 成员内部类中调用外部类的结构 28.开发中局部内部类的使用 能看懂就可以 自己定义内部类不多 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(下)","date":"2016-06-28T23:27:18.000Z","path":"2016/06/29/2016-06-29-mian-xiang-dui-xiang-xia/","text":"1. 每日一考向上转型就是多态1.如何实现向下转型?需要注意什么问题?如何解决此问题?Person p = new Man();使用强转符: ()Man m = (Man)p;可能ClassCastException异常。使用instanceof在进行向下转型前判断。if(p instanceof Man){Man m = (Man)p;} ==和equals()有何区别? 目前我要是过来咱们做什么项目，需要我参与做什么，项目架构 什么技术先描述，开发中怎么用 class User{4String name;int age;e//重写其equals()方法。if(obj == this){return true;}if(obj instanceof User){User u = (User)obj;return this . age== u.age &amp;&amp; this . name . equals(u. name);}return false;} } 4.写出8种基本数据类型及其对应的包装类。 integercharacter IF5.基本数据类型、包装类与String三者之间如何转换。基本数据类型、包装类 自动装箱基本数据类型、包装类–》 String: valueOf()String–》 基本数据类型 、包装类 parseInt(String s) 2. 复习 多态性7.关于向.上转型与向下转型:7.1向上转型: 多态7.2向下转型:7.2.1为什么使用向下转型:有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法?使用向下转型。7.2.2如何实现向下转型:使用强制类型转换符。()7.2.3使用时的注意点:①使用强转时，可能出现ClassCastException的异常。②为了避免在向下转型时出现ClassCastException的异常， 我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false,不进行向下转型。 7.2.4 instanceof的使用:①a instanceof A:判断对象a是否是类A的实例。如果是，返回true; 如果不是，返回false.②如果a instanceof A返回true,则a instanceof B也返回true.其中， 类B是类A的父类。③要求a所属的类与类A必须是子类和父类的关系，否则编译错误。8.面试题:8.1谈谈你对多态性的理解? 想实例 怎么用代码的通用性①实现代码的通用性。②object类中定义的public boolean equals(Object obj){}JDBC:使用java程序操作(获取数据库连接、CRUD数据库(sql db2 oracle )③抽象类、接口的使用肯定体现了多态性。 (抽象类、接口不能实例化) 8.2多态是编译时行为还是运行时行为?运行时行为 3. object 类及其内部方法 java.lang.Object类的说明 java. lang . object类 object类是所有Java类的根父类2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java . lang. object类 object类中的功能(属性、方法)就具有通用性。属性:无方法: equals() / toString() / getClass() /hashCode() / clone() / finalize( )wait()、notify()、 notifyA1l( ) Object类只声明了一个空参的构造器 2.equals()方法2.1 equals()的使用: 1.是一个方法，而非运算符2.只能适用于引用数据类型3.object类中equals()的定义:public boolean equals (object obi){return (this == obi);}说明:object类中定义的equals()和==的作用是相同的:比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体4.像String、 Date、 File、 包装类等都重写了object类中的equals()方法。 重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。5.通常情况下，我们自定义的类如果使用equals()的话， 也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对object类中的equals()进行重写.重写的原则:比较两个对象的实体内容是否相同. 2.2如何重写equals()2.2.1手动重写举例:int age;//重写其equals()方法public boolean equals(Object obj){if(obj == this){return true;}if(obj instancec User){User u = (User )obj;return this.age == u.age &amp;&amp; this .name. equals(u. name) ;return false;}} 2.2.2开发中如何实现:2.3回顾==运算符的使用:==:运算符1.可以使用在基本数据类型变量和引用数据类型变量中2.如果比较的是基本数据类型变量:比较两个变量保存的数据是否相等。(不一 定类型要相同)如果比较的是引用数据类型变量:比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 补充: == 符号使用时，必须保证符号左右两边的变量类型一致。 toString()方法3.1 toString()的使用:1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString() I / /关于toString()@Testpublic void test3(){String s = “abc”;s = nu11;System. out . println(s);//null 有保护机制System. out. println(“*****);System. out . println(s. toString( ));/ /出现NullPointerException} object类 中toString()的定义:public String toString() {return getClass(). getName() + “@” + Integer . toHexString(hashCode());}3.像String、 Date、 File、 包装类等都重写了object类中的toString()方法，使得在调用对象的toString()时，返回”实体内容”信息4.自定义类也可以重写toString()方法， 当调用此方法时，返回对象的”实体内容”3.2如何重写toString()V/自动实现@Overridepublic String toString() {return “Customer[ name=” + name +”，age=” + age +“]”; 4.面试题:①final、 finally、 finalize的区别?②==和equals()区别 4. 单元测试方法与包装类 Java中的JUnit单元测试步骤:1.中当前工程-右键择: build path - add libraries - JUnit 4一下一步2.创建Java类，进行单元测试。此时的Java类要求:①此类是public的@此类提 供公共的无参的构造器3.此类中声明单元测试方法。此时的单元测试方法:方法的权限是public,没返回值，没形参4.此单元测试方法.上需要声明注解: @Test,并在单 元测试类中导入: import org. junit. Test;5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。6.写完代码以后，左键双击单元测试方法名，右键: runas一JUnit Test说明:1.如果执行结果没任何异常:绿条2.如果执行结果出现异常:红条 ###包装类1.为什么要有包装类(或封装类)为了使基本数据类型的变量具有类的特征，引入包装类。 2.基本数据类型与对应的包装类:表格3.需要掌握的类型间的转换: (基本数据类型、包装类、String) 看图基本数据类型&lt;—&gt;包装类: JDK 5.0新特性:自动装箱与自动拆箱基本数据类型、包装类—&gt;String:调用String重载的value0f(Xxx xxx)String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)注意:转换时，可能会报NumberFormatException| I 简易版:应用场景举例:①Vector类中关于添加元素，只定义了形参为0bject类型的方法:v.addElement(Object obj); //基 本数据类型–&gt;包装类–&gt;使用多态 5.static 关键字的引入当我们编写一个类时，其实就是在描述对象的属性和行为而并没有产生质上 的对象，只有通过 new new关键字才会产生出对象， 这时系统分配内存空间给关键字才会产生出对象， 这时系统分配内存空间给其方法才可以供外部调用。我们有时候希望无论是否产生了对象或多少对象的情况下， 某些特定的数据在内存空间里只有一份 ，例如所有的中国人都个 国家名称，每一个中人都共享这不必在的实例对象都单独分配一个用于代表国家名称的 变量 。由于每造一个有个chinese—&gt;大家共享的 6.静态变量和实例变量的对比1.static:静态的2.static可以用来修饰：属性、方法、代码块、内部类3.使用static修饰属性：静态变量（或类变量） 3.1 属性，按是否使用static修饰，又分为：静态属性vs 非静态属性(实例变量) 实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。3.2 static修饰属性的其他说明：① 静态变量随着类的加载而加载。可以通过\"类.静态变量\"的方式进行调用② 静态变量的加载要早于对象的创建。③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。④ 类变量 实例变量类 yes no对象 yes yes3.3 静态属性举例：System.out; Math.PI;4.使用static修饰方法：静态方法① 随着类的加载而加载，可以通过\"类.静态方法\"的方式进行调用 ② 静态方法 非静态方法 类 yes no 对象 yes yes③ 静态方法中，只能调用静态的方法或属性 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 static注意点：5.1 在静态的方法内，不能使用this关键字、super关键字 5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。 开发中，如何确定一个属性是否要声明为static的？ 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。类中的常量也常常声明为static 开发中，如何确定一个方法是否要声明为static的 Math.PI 操作静态属性的方法，通常设置为static的工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections 7.static修饰属性的其他说明 8.类变量和实例变量的内存解析 9.static 修饰方法 静态方法只能调用静态属性和方法 生命的周期不够 类的加载 —– 类的结束 非静态和对象是同步的‘ 静态和类是同步的 打比方，你可以给你爸借钱，当时不能给你儿子借钱 10.判断属性或方法是否应该static 公共的部分 ，此例子中 利率和最小余额是static，大家公用的 工具类适当加static 11.自定义ArrayUtil 工具类的优化12.static 应用举例 共享 下一次 1002 把static 去掉 以后每次都一样 static 声明的属性被所有对象共享 total 创建圆的个数 14.设计模式与单例设计模式(static 应用) 单例 —单独的一个实例–只想让类造一个对象 独立于语言 创建型模式,共5种:I方法模式、抽象工厂 模式、单例模式、 建造者模式、原型模式。结构型模式，共7种:适配器模式、装饰器模式、代理模式、外观模式桥接模式、组合模式、享元模式。行为型模式，共11种:策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 工作的时候看 大话设计模式—&gt;23种设计模式-&gt;深入浅出设计模式 15.单例的恶汉式实现单例设计模式： 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 如何实现？饿汉式 vs 懒汉式 区分饿汉式 和 懒汉式饿汉式： 坏处：对象加载时间过长。 好处：饿汉式是线程安全的懒汉式：好处：延迟对象的创建。 目前的写法坏处：线程不安全。---&gt;到多线程内容时，再修改 16.单例的懒汉式实现 啥时候用啥时候造 懒——-不知道不给你造 饿一上来 就造好——-比较饿 上来就new 17.懒汉式和恶汉式的区分有可能不用 ，占用内存空间 ，加载时间过长 恶汉式:加载时间过长 恶汉式 线程安全，买火车票 笔试 线程安全。选择恶汉式 18.单例模式的应用场景 单例模式的优点:由于单例模式只生成一个实例，减少了系统性能开销，当-一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生-一个单例对象，然后永久驻留内存的方式来解决。 应用场景 数据库 一个池子里面有10个 不够再扩充 19.理解main()方法的语法main()方法的使用说明： main()方法作为程序的入口 main()方法也是一个普通的静态方法 main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner） 每个类可以写各自的main方法 静态里面调用静态 空格隔开 int num = Integer . parseInt(args[i]);System. out . println(“ #####”+ num) ;| 加不加引号都可以，输入变量的时候 运行的时候 20.类中代码块结构的使用代码块.. 代码块的作用：用来初始化类、对象 代码块如果有修饰的话，只能使用static. 分类：静态代码块 vs 非静态代码块 静态方法随着类的加载而加载，但是没有使用，没有通过 类.方法使用 静态代码块 内部可以有输出语句随着类的加载而执行,而且只执行一次作用：初始化类的信息如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行静态代码块的执行要优先于非静态代码块的执行静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块 内部可以有输出语句随着对象的创建而执行每创建一个对象，就执行一次非静态代码块作用：可以在创建对象时，对对象的属性等进行初始化如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 没有必要写多个代码块 21.开发中代码块的使用举例 22.代码块的课后练习构造模式 super() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.atguigu.java3;//总结：由父及子，静态先行class Root{ static{ System.out.println(\"Root的静态初始化块\"); } { System.out.println(\"Root的普通初始化块\"); } public Root(){ super(); System.out.println(\"Root的无参数的构造器\"); }}class Mid extends Root{ static{ System.out.println(\"Mid的静态初始化块\"); } { System.out.println(\"Mid的普通初始化块\"); } public Mid(){ super(); System.out.println(\"Mid的无参数的构造器\"); } public Mid(String msg){ //通过this调用同一类中重载的构造器 this(); System.out.println(\"Mid的带参数构造器，其参数值：\" + msg); }}class Leaf extends Mid{ static{ System.out.println(\"Leaf的静态初始化块\"); } { System.out.println(\"Leaf的普通初始化块\"); } public Leaf(){ //通过super调用父类中有一个字符串参数的构造器 super(\"尚硅谷\"); System.out.println(\"Leaf的构造器\"); }}public class LeafTest{ public static void main(String[] args){ new Leaf(); System.out.println(); new Leaf(); }} 12345678910111213141516171819202122232425262728293031323334353637383940package com.atguigu.java3;class Father { static { System.out.println(\"11111111111\"); } { System.out.println(\"22222222222\"); } public Father() { System.out.println(\"33333333333\"); }}public class Son extends Father { static { System.out.println(\"44444444444\"); } { System.out.println(\"55555555555\"); } public Son() { System.out.println(\"66666666666\"); } public static void main(String[] args) { // 由父及子 静态先行 System.out.println(\"77777777777\"); System.out.println(\"************************\"); new Son(); System.out.println(\"************************\"); new Son(); System.out.println(\"************************\"); new Father(); }} 111 444 777 *** 22 33 55 66 23.属性赋值的先后顺序对属性可以赋值的位置：①默认初始化②显式初始化/⑤在代码块中赋值③构造器中初始化④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值 执行的先后顺序：① - ② / ⑤ - ③ - ④ 12345678910111213141516171819202122232425262728public class OrderTest { public static void main(String[] args) { Order order = new Order(); System.out.println(order.orderId); }}class Order{ int orderId = 3; { orderId = 4; } }orderId=4or { orderId = 4; } int orderId = 3;orderId=3 24.final修饰类和方法6-4 final 关键字final:最终的 final可以用来修饰的结构：类、方法、变量 final 用来修饰一个类:此类不能被其他类所继承。比如：String类、System类、StringBuffer类 final 用来修饰方法：表明此方法不可以被重写比如：Object类中getClass(); final 用来修饰变量：此时的”变量”就称为是一个常量4.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化 4.2 final修饰局部变量： 尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值 以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final 用来修饰属性：全局常量 native 调用底层c语言和c++语言代码 加载创建对象 核心? 每个人的常量不一样 用构造器赋值常量 赋值 可能还需要处理，放在代码块中就可以 2 6. final 修饰局部变量方法内修饰形参 或者构造器 形参调用的时候才会赋值 final修饰局部变量 接口属性都是 static final 平时用很少 final修饰方法 27.final 课后练习题目一 注释的对 题目二 第6行 对的 打比方 最后的妻子，但是她的属性是可以变得 //错误 重建了对象 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(中)补2","date":"2016-06-28T07:02:45.000Z","path":"2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/","text":"1.每日一问1.什么是多态性?什么是虚拟方法调用?对象的多态性:父类的引用指向子类的对象。Person p = new Man();p.eat();调用方法时，编译时看左边，运行时看右边。先会写代码，后面慢慢来 2.一个类可以有几个直接父类?(一个 )一个父类可有多少个子类?子类能获取直接父类的父类中的结构吗?(可以)子类能否获取父类中private 权限的属性或方法?。(可以 getset 方法) 封装解决的能不能调的问题，继承性是能不能获取的问题Ais B 是不是true 可继承 3.方法的重写(override/overwrite)的具体规则有哪些。(非static方法)方法名，形参列表相同。权限修饰符。返回值w抛出的异常 4.super调用构造器，有哪些具体的注意点this(形参列表):本类重载的其它的构造器。super(形参列表):调用父类中指定的构造器。n n-11 5.在下面的代码结构中:使用关键字: this,super;方法的重 写;继承; 2.重写与superdebug 调试 重载1.什么是方法的重写(override或overwrite)? (父类的方法不适合子类)子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。2.应用: 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。 3.举例:cylinder 4.重写的规则:方法的声明:权限修饰符 返回值类型 方法名 (形参列表) throws 异常的类型{//方法体约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法②子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同2子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符事 特殊情况:子类不能重写父类中声明为private权限的方法③返回值类型:父类被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类父类被重写的方法的返回值类型是基本数据类型(比如: double)， 则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)日子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型(具体放到异常处理时候讲)子类和父类中的同名同参数的方法要么都声明为非static的(考虑重写，要么都声明为static的(不是重写). 5.面试题:区分方法的重写和重载?重载 ，可以在同一个类中可以使用相同方法名和形参列表不同相同相同方法，彼此之间构成重载，构造器可以重载动态绑定 答:①二者的概念:②重载和重写的具体规则③重载:不表现为多 态性。重写:表现为多态性。重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它石的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同參数的方法。所以:对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为早绑定或静态绑定”;而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定或动态绑定”。引用一句Bruce Eckel的话:“不要犯傻，如果它不是晚绑定，它就不是多态。” super1.super关键字可以理解为: 父类的2.可以用来调用的结构:属性、方法、构造器 3.super调用属性、方法:3.1我们可以在子类的方法或构造器中。通过使用”super展性”或“super .方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”superA”3.2特殊情况:当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。3.3特殊情况:当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。 4.super调用构造器: 4.1我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器4.2 “super(形参 列表)”的使用，必须声明在子类构造器的首行!4.3我们在类的构造器中，针对于”this(形参列表)”或” super(形参列表)”只能二一，不能同时出现4.4在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的in构造器: super()4.5在类的多个构造器中，至少-一个类的构造器中使用了”super(形参列表)”， 调用父类中的构造器 渐渐领悟 3.子类对象实例化过程及多态性1.从结果上看:继承性 子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所父类中声明的属性。 2.从过程上看:当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，… 直到调用了java. lang . object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。 3.强调说明为什么super(… )或this(..)调用语句只能作为构造器中的第- - -句出现? 无论通过哪个构造器创建子类对象，需要保证先初始化父类。目的:当子类继承父类后，“继承”父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化。 多调性的理解1.多态性的理解:可以理解为一个事物的多种形态。 2.何为多态性:对象的多态性:父类的引用指向子类的对象(或子类的对象赋给父类的引用)举例:Person p = new Man();objlect obj = new Date();3.多态性的使用: 虚拟方法调用有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。总结:编译，看左边;运行，看右边。4.多态性的使用前提:①类的继承关系②方法的重写5.多态性的应用举例:猫狗6.多态性使用的注意点:对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边 4. 向下转型的使用/ /不能调用子类所特有的方法、属性:编译时，p2是Person类型。p2. earnMoney();//有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致/ /编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。 / /如何才能调用子类特有的属性和方法?/ /向下转型:使用强制类型转换符。Man m1 = (Man)p2;m1. earnMoney(); |m1. isSmoking = true; 有可能转不成功Woman w1=(Woman)p2;w1. goShopping();p2是男的 你把他误以为女的 / /使用强转时，可能出现ClassCast Exception的异常。Woman W1 = (Woman)p2;w1. goShopping(); 5.instanceof 关键字的使用instanceof关键字的使用 a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false 使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先 进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。 如果 a instanceof A返回true,则 a instanceof B也返回true. 父类放着也对其中，类B是类A的父类。 Person p2=new Man(); 6.向下转型的几个常用问题//练习:, /问题一:编译时通过，运行时不通过//举例一:Person p3 = new Woman( ) ;Man m3 = (Man)p3;/ /举例二:Person p4 = new Person( ) ;Man m4= (Man)p4;/ /问题二:编译通过，运行时也通过object obj = new Woman( );Person p = (Person)obj;/ /问题三:编译不通过Man m5 = new Woman();String str = new Date();开发中向下转型用的比较少 7.多态练习—调用属性和方法引用类型是地址值 开发中不要定义同名的 1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。编译看左边 运行看右边2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量，编译运行都看左边 8-9.基本操作–多态性各种图形的面积 可以利用多态来实现 求面积 重写父类中的面积公式 sub-1 认为是重写 sub_1 确定的优先调用 11 object 类的使用5.7 object 类的使用 Object类是所有Java类的根父类 Order order = new Order( ) ;System. out . println(order .getClass() . getSuperclass()); 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类public class Person {}等价于:public class Person extends Object {} 例: method(Object obj){.. } /可以接收任何类作为其参数Person o=new Person();method(0); java.lang.Object类 1.Object类是所有Java类的根父类 2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 3.Object类中的功能(属性、方法)就具有通用性。 属性：无 方法：equals() / toString() / getClass() /hashCode() / clone() / finalize() wait() 、 notify()、notifyAll() Object类只声明了一个空参的构造器 clone 复制对象 finalize() 垃圾回收期 面试题： final、finally、finalize的区别？ 关键字前面2个 finalize 方法名 12. ==运算符的回顾面试题:==和equals()的区别一、回顾 == 的使用： == ：运算符 可以使用在基本数据类型变量和引用数据类型变量中 10=10.0 char c=10 10=10 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 自动类型提升如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 1补充： == 符号使用时，必须保证符号左右两边的变量类型一致。 二、equals()方法的使用： 是一个方法，而非运算符 只能适用于引用数据类型 Object类中equals()的定义：public boolean equals(Object obj) {return (this == obj); }说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同. —-ppt ==: 基本类型比较值:只要两个变量的值相等，即为true。int a=5; if(a==6)..} 引用类型比较引用(是否指向同一个对象):只有指向同一个对象时，==才返回true。Person p1 =new Person();Person p2=new Person();if (p1==p2)…} 用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错 equals();所有类都继承了Object,也就获得了equals()方法。还可以重写。➢只能比较引用类型，其作用与“卜=”相同,比较是否指向同一个对象。➢格式:obj1.equals(obj2) 特例:当用equals()方法进行比较时，对类File、String、 Date 及包装类.(Wrapper Class)来说，是比较类型及内容而不考虑引用的是否是同一个对象;➢原因:在这些类中重写了Object类的equals()方法。 当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等 重写equals()方法的原则. 对称性:如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是“true” 自反性: x.equals(x)必须返回是“true 传递性:如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”那么z.equals(x)也应该返回是“true”。 一 致性:如果x.equals(y)返回是“true” ，只要x和y内容一直不变， 不管你重复x.equals(y)多少次，返回都是“true” 。 任何情况下，x.equal(null)， 永远返回是“falsex.equals(和x不同类型的对象)永远返回是“false” 从我面试的反馈，85%的求职者“理直气壮”的回答错误…1.==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址2.equals的话， 它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。3.具体要看自定义类里有没有重写Object的equals方法来判断。4通常情况下，重写equals方法， 会比较类中的相应属性是否都相等。 13.equals()的使用 14.重写equals() 方法找例子 String 重写equals 源代码 字符串等引用类型 equals() 方法2 自动生成 General 代码自动生成逻辑性更强 15. 总结==与equals()16.equals 方法的练习对象之间不能用 == 因为new的会改变地址 ，==比较的是地址 自定义的类也要重写equals ，当在子类中需要的时候 17.toString()的使用 Object类中toString()的使用： 1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString() 2.Object类中toString()的定义： public String toString() { return getClass().getName() + “@” + Integer.toHexString(hashCode()); } 3.像String、Date、File、包装类等都重写了Object类中的toString()方法。 使得在调用对象的toString()时，返回”实体内容”信息 4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容” 自定义 手动 系统生成 19 objetc类的练习if(obj instanceof Circcle){ Circle c=(Circle)obj; return this.radius==c.radius; } 20.单元测试方法的使用新建类 JUnitTest.java 选中当前工程-&gt;右键build Path-&gt;add libraries-&gt;JUnit-&gt;finish Java中的JUnit单元测试 步骤： 1.选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步 2.创建Java类，进行单元测试。 此时的Java类要求：① 此类是public的 ②此类提供公共的无参的构造器 3.此类中声明单元测试方法。 此时的单元测试方法：方法的权限是public,没有返回值，没有形参 4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test; 5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。 6.写完代码以后，左键双击单元测试方法名，右键：run as -&gt; JUnit Test 说明： 1.如果执行结果没有任何异常：绿条 2.如果执行结果出现异常：红条 把测试方法当成静态的了 真正开发 @test 导包就可以 21.包装类的理解5.8 包装类的使用 针对八种基本数据类型定义相应的引用类型一包装类(封装类) 有了类的特点，就可以调用类中的方法，Java才是真正的面向对象 基本数据类型包装成包装类的实例__装箱 通过包装类的构造器实现:int i= 500; Integer t = new Integer(); 还可以通过字符串参数构造包装类对象:Float f= new Float(“4. 56”);Long I = new Long(“asdf” ); //NumberFormatException 获得包装类对象中包装的基本类型变量–拆箱-调用包装类的.xxxValue()方法:boolean b = bObj .booleanValue(); JDK1.5之后，支持自动裝箱，自动拆箱。但类型必须匹配。 字符串转换成基本数据类型 通过包装类的构造器实现:int i = new Integer(“12”); 通过包装类的parseXxx(String s)静态方法:Float f= Float.parseFloat(“12.1”); 基本数据类型转换成字符串 调用字符串重载的valueOf()方法: .String fstr = String.valueOf(2.34f); 更直接的方式:String intStr= 5 +“” 22.基本数据类型转化为包装类包装类的使用 1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征 2.掌握的：基本数据类型、包装类、String三者之间的相互转换 //基本数据类型 —&gt;包装类：调用包装类的构造器 boolean isMale; Boolean isFemale; 是个类 23.包装类转化基本数据类型​ //包装类—&gt;基本数据类型:调用包装类Xxx的xxxValue() 123456789101112@Test public void test2(){ Integer in1 = new Integer(12); int i1 = in1.intValue(); System.out.println(i1 + 1); Float f1 = new Float(12.3); float f2 = f1.floatValue(); System.out.println(f2 + 1); } 24.自动装箱和拆箱12345678910111213141516171819202122232425 // JDK 5.0 新特性：自动装箱 与自动拆箱 / @Test public void test3(){// int num1 = 10;// //基本数据类型--&gt;包装类的对象// method(num1);//上面独立 //自动装箱：基本数据类型 ---&gt;包装类 int num2 = 10; Integer in1 = num2;//自动装箱 boolean b1 = true; Boolean b2 = b1;//自动装箱 //自动拆箱：包装类---&gt;基本数据类型 System.out.println(in1.toString()); int num3 = in1;//自动拆箱 } public void method(Object obj){ System.out.println(obj); } 25.基本数据类型、包装类与String间的相互转化//基本数据类型、包装类—&gt;String类型：调用String重载的valueOf(Xxx xxx) @Test ​ 1234567891011121314public void test4(){ int num1 = 10; //方式1：连接运算 String str1 = num1 + \"\"; //方式2：调用String的valueOf(Xxx xxx) float f1 = 12.3f; String str2 = String.valueOf(f1);//\"12.3\" Double d1 = new Double(12.4); String str3 = String.valueOf(d1); System.out.println(str2); System.out.println(str3);//\"12.4\" } // //String类型 —&gt;基本数据类型、包装类：调用包装类的parseXxx(String s) 1234567891011121314@Test public void test5(){ String str1 = \"123\"; //错误的情况：// int num1 = (int)str1;// Integer in1 = (Integer)str1; //可能会报NumberFormatException int num2 = Integer.parseInt(str1); System.out.println(num2 + 1); String str2 = \"true1\"; 不是标准的true 都是false boolean b1 = Boolean.parseBoolean(str2); System.out.println(b1); } 26.包装类常见面试题 第一题 1.0 由于类型提升，要求统一类型 第二题: 1 没有要求统一类型 false 地址 true false 有个缓存数组 1-127 new 的 27 包装类的练习 想放多少放多少 先写思路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.exer4;import java.util.Scanner;import java.util.Vector; 练习/* * 利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级。 提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。 而向量类java.util.Vector可以根据需要动态伸缩。 创建Vector对象：Vector v=new Vector(); 给向量添加元素：v.addElement(Object obj); //obj必须是对象 取出向量中的元素：Object obj=v.elementAt(0); 注意第一个元素的下标是0，返回值是Object类型的。 计算向量的长度：v.size(); 若与最高分相差10分内：A等；20分内：B等； 30分内：C等；其它：D等 * * * * */public class ScoreTest { public static void main(String[] args) { //1.实例化Scanner，用于从键盘获取学生成绩 Scanner scan = new Scanner(System.in); //2.创建Vector对象：Vector v=new Vector();相当于原来的数组 Vector v = new Vector(); //3.通过for(;;)或while(true)方式，给Vector中添加数组 int maxScore = 0; for(;;){ System.out.println(\"请输入学生成绩（以负数代表输入结束）\"); int score = scan.nextInt(); //3.2 当输入是负数时，跳出循环 if(score &lt; 0){ break; } if(score &gt; 100){ System.out.println(\"输入的数据非法，请重新输入\"); continue; } //3.1 添加操作：：v.addElement(Object obj) //jdk5.0之前：// Integer inScore = new Integer(score);// v.addElement(inScore);//多态 //jdk5.0之后： v.addElement(score);//自动装箱 //4.获取学生成绩的最大值 if(maxScore &lt; score){ maxScore = score; } } //5.遍历Vector，得到每个学生的成绩，并与最大成绩比较，得到每个学生的等级。 char level; for(int i = 0;i &lt; v.size();i++){ Object obj = v.elementAt(i); //jdk 5.0之前：// Integer inScore = (Integer)obj;// int score = inScore.intValue(); //jdk 5.0之后： int score = (int)obj; if(maxScore - score &lt;= 10){ level = 'A'; }else if(maxScore - score &lt;= 20){ level = 'B'; }else if(maxScore - score &lt;= 30){ level = 'C'; }else{ level = 'D'; } System.out.println(\"student-\" + i + \" score is \" + score + \",level is \" + level); } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(中)补1","date":"2016-06-28T03:55:22.000Z","path":"2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/","text":"1. 每日一考Arraylist 替换数组 可扩展长度— 2.复习项目要求1.看着一边写 一边理解，2.自己去写 试着自己去完成，写不动看文档修饰 看源码 试着独立完成全屏看，看完这个类以后 ，收起来，自己去写，写的时候写不动 看文档提示，再去写，在写不动， 看源码 ，指导咋写 在手些 手写来，在接着写3. 至少独立完成一遍以 上的项目代码 积累完成项目的过程中常见的bug的调试方式一‘“硬”看，必要时，添加输出语句。方式二：Debug 逻辑 业务 捋顺思路,强化逻辑 对象、数组等内存结构的解析 遵守编码的规范,标识符的命名规范等 在类前，方法前，方法内具体逻辑的实现步骤等添加必要的注释.文档注释逻辑步骤： 单行和多行注释 3.继承性 为什么要有类的继承性? (继承性的好处)①减少了代码的冗余，提高代码复用性②便于功能的扩展③为之后多态性的使用，提供了前提图示: 继承性的格式: class A extends B{ }A:子类、派生类、subclass .B:父类、超类、基类、superclass 子类继承父类以后有哪些不同? 3.1体现: 一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。*特别的， 父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。3.2子类继承父类以后，还可以声明自己特有的属性或方法:实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。extends:延展、扩展 Java中继承性的说明 1.一个类可以被多个子类继承。2.Java中类的单继承性:一个类只能有一个父类3.子父类是相对的概念。4.子类直接继承的父类，称为:直接父类。间接继承的父类称为:间接父类5.子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法 图示: java. lang . object类的理解1.如果我们没显式的声明一个类的父类的话，则此类继承于java.1ang . object类2.所的java类(除java.1ang. object类之外都直接或间接的继承于java. lang. object类3.意味着，所的java类具有java. lang. object类声明的功能。 4-5. 继承性的练习，基本操作（练习）紫色的箭头表示继承 6-7Eclipse Debug的使用 System.out.println(). 适合小项目 Eclipse - Debug调试 1.设置断点 关卡 2.debug as–》 java application 3.操 做 –》进入透视图 f6 一行代i码 一行代码走—&gt;执行 f5 函数方法里面 到方法实现哪一行用F7 跳出方法resume 到下一个断点进入tdrop into 方法的初始部分 8.解决Debug中step into功能失灵问题配置debug Configuration 9.方法重写的理解override/overwrite 定义：在子类中可以根据需要对从父继承来的方法进行改造， 在程序执行时，子类的方法将覆盖父。 在程序执行时，子类的方法将覆盖父。 要求: 子类重写的方法 必须 和父类被重写的方法 具有相同的 方法名称、 参数 列表 子类重写的方法返回值型 不能大于 父类被重写的方法返回值型 子类重写的方法使用访问权限 不能小于 父类被重写的方法访问权限子类不能重写父中声明为 private 权限的方法 子类方法抛出的异常不能大于父被重写方法的异常 注意子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的(不是重写)。因为static方法是属于类的，子类无法覆盖父类的方法。 1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。10. 方法重写的细节3.重写的规定：方法的声明： 权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{ //方法体 } 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 —-摊煎饼 特殊情况：子类不能重写父类中声明为private权限的方法权限修饰 除了 private 都是重写③ 返回值类型： &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类 父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写） 静态方法不能被重写，随着类的加载而加载— 开发中直接粘贴就可以了—重写wal+ alt+/ 11 f方法重写的练习12. 测试4种不同的权限修饰/ /同一个包中的其他类，不可以调用Order类中私有的属性、方法order.orderPrivate = 4;order . methodPrivate( ) ; //在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法orderDefault = 3;orderPrivate = 4; //不同包下的普通类(非子类)要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法order. orderPrivate = 2;order. orderDefault = 3;order. orderProtected = 4; 对于class的权限修饰只可以用public利和Idefault(缺省)。public类可以在任意地方被访问。default类只可以被同一个包内部的类访问。用的最多是public private 13.super调用属性和方法关键字super用父类被重写的属性和方法 1.super理解为：父类的 2.super可以用来调用：属性、方法、构造器 3.super的使用：调用属性和方法3.1 我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用 父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.” –子类没有3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的 使用”super.属性”的方式，表明调用的是父类中声明的属性。 往上找3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的 使用”super.方法”的方式，表明调用的是父类中被重写的方法。4.super调用构造器 4.1 我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器 4.2 “super(形参列表)”的使用，必须声明在子类构造器的首行！ 4.3 我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现 4.4 在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super() 4.5 在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器 输出结果是一样的由于子类中没有age ，只有父类有System. out . println(“name = “ + this.name + “，age = “ + super.age); 14. super调用构造器 15.子类对象实例化的全过程5.5子类对象实例化的过程 为什么能用？ 从结果上来看：（继承性）子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。 从过程上来看： 123 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，... 直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。 子类 间接或直接调用父类构造器 16 继承和super练习银行 17.多态性的使用 多态性，是面向对象中最重要的概念 ，在Java 中的体现:对象 的多态性：父类的引用指向子对象 可以 直接应用在抽象类和接口上 Java引用变量有两个类型:编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称: 编译时，看左边;运行时，看右边。 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphi sm) 多态情况下，“看左边”:看的是父类的引用(父类中不具备子类特有的方法)“看右边”:看的是子类的对象(实际运行的是子类重写父类的方法) 对象的多态一 - —-在Java中,子类的对象可以替代父类的对象使用 一个变量只能有一种确定的数据类型 一个引用类型变量可能指向(引用)侈种不同类型的对象Person p = new Student();Object 0 = new Person();//Object类型的变量o，指向Person类型的对象o = new Student(); //Object类型的变量o，指向Student类型的对象 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象:向上转型(upcasting)。 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法:Student m = new Student();m.school =“pku”; //合法,Student类有school成员变量Person e = new Student();e.school =“pku”; //非法,Person类没 有school成员变量属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。 1.理解多态性：可以理解为一个事物的多种形态。2.何为多态性： 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用） 多态的使用：虚拟方法调用有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。总结：编译，看左边；运行，看右边。 4.多态性的使用前提： ① 类的继承关系 ② 方法的重写 5.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） 多态性的使用 秘书给我找个人，他能吃东西，结果她找的是男人， p2.earnMony(); 不能使用 ，父类没有什么这个方法 编译生成什么类型就能点出什么类型，p2只调用person里面有的方法 执行的时候是子类重写的 p2.eat() 点到父类了 p2 是个person 18.多态性的使用举例 有了多态性 没有多态性 会造成很多重载的方法 equals （子类类型） 举例 Driver 先建立连接 三种数据库的连接 19.多态性不适合于属性20 虚拟方法调用的再理解虚拟方法调用(Virtual Method Invocation) 正常的方法调用Person e = new Person();e.getInfo();Student e = new Student();e.getlInfo(); 虚拟方法调用(多态情况下)子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。Person e = new Student();e.getInfo();调 用Student类的getInfo()方法 编译时类型和运行时类型编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getlnfo()方法。一-动态绑定 面试题:多态是编译时行为还是运行时行为 若随机呢? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.atguigu.java5;import java.util.Random;//面试题：多态是编译时行为还是运行时行为？//证明如下：class Animal { protected void eat() { System.out.println(\"animal eat food\"); }}class Cat extends Animal { protected void eat() { System.out.println(\"cat eat fish\"); }}class Dog extends Animal { public void eat() { System.out.println(\"Dog eat bone\"); }}class Sheep extends Animal { public void eat() { System.out.println(\"Sheep eat grass\"); } }public class InterviewTest { public static Animal getInstance(int key) { switch (key) { case 0: return new Cat (); case 1: return new Dog (); default: return new Sheep (); } } public static void main(String[] args) { int key = new Random().nextInt(3); System.out.println(key); Animal animal = getInstance(key); animal.eat(); }} 多态小结 多态作用:提高了代码的通用性，常称作接口重用 前提:需要存在继承或者实现关系有方法的重写 成员方法:编译时:要查看引用变量所声明的类中是否有所调用的方法。运行时:调用实际new的对象所属的类中的重写方法。 成员变量:不具备多态性，只看引用变量所声明的类。 代码 123456789101112131415161718192021222324252627282930class animal{ public void eat() { System.out.println(\"吃饭\"); }}class dog extends animal{ @Override //4.吃骨头 public void eat() { System.out.println(\"吃骨头\"); }}class cat extends animal{ public void eat() { System.out.println(\"吃老鼠\"); }}public class duotai { //3.调用子类的相应方法 ,如传入new dog()public void func(animal d) { d.eat();} public static void main(String[] args) { //1.类的实体化 duotai dt=new duotai(); //2.调dt里面的方法，传入子类 new 对象，调谁用谁 dt.func(new dog()); dt.func(new cat()); }} 可以实现不同子类间的相同方法图解 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(中)","date":"2016-06-28T01:17:34.000Z","path":"2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/","text":"1. 每日一考1.构造器的作用是什么?使用中有哪些注意点(&gt;=3条)①创建对象②初始化对象结构 2.关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，默认初始化显式初始化构造器中初始化-对象方法或对象属性给属性赋值+ 3. this 关键字可以用来调用哪些结构，简单说明一下其使用。this:属性、方法、构造器。this:理解为当前对象，当前正在创建的对象。 4. Java中目前学习涉及到的四种权限修饰符都有什么?并说明各自的权限范围。public protect 缺省 private 5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。2.复习:封装性和构造器封装性 为什么要引入封装性?我们程序设计追求“高内聚，低耦合” 高内聚:类的内部数据操作细节自己完成，不允许外部干涉; 低耦合:仅对外暴露少量的方法用于使用。 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。 问题引入:当我们创建一一个类的对 象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。 (比如: setLegs()同时， 我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).–&gt;此时，针对于属性就体现了封装性。| 封装性思想具体的代码体现:体现一-:体现一:将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值体现二:不对外暴露的私有的方法体现三:单例模式(将构造器私有化)体现四:如果不希望类在包外被调用，可以将类设置为缺省的。 Java规定的四种权限修饰符4.1权限从小到大顺序为:4.2具体的修饰范围: 构造器 构造器(或构造方法) : Constructor构造器的作用:1.创建对象 2.初始化对象的信息 使用说明:1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器2.定义构造器的格式:权限修饰符类名(形参 列表){}]|3.一个类中定义的多个构造器，彼此构成重载4.-旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器5.一个类中，至少会有一个构造器。 3.举例: 属性赋值顺序默认初始化 赋值初始化 显性赋值初始化 |||| 构造器赋值 对象.方法 JAVABean所谓JavaBean，是指符合如下标准的Java类: 类是公共的 一个无参的公共的构造器 属性，且对应的get、set方法 3.复习 关键字 this package importthis1.可以调用的结构:属性、方法:构造器 this调用属性、方法:this理解为:前对象或当前正在创建的对象 this调用构造器: ①我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器②构造器中不能通过”this(形参列表)”方式调用自己③如果一个类中有n个构造器，则最多有n - 1构造器中使用了”this(形参列表)”④规定: “this(形参列表)”必须声明在当前构造器的首行⑤构造器内部，最多只能声明一一个”this(形参列表)”， 用来调用其他的构造器 package的使用1使用说明:*1.为了更好的实现项目中类的管理，提供包的概念.*2.使用package声 明类或接口所属的包，声明在源文件的首行*3.包，属于标识符，遵循标识符的命名规则、规范(xxyyyzzz)、 “见名知意”*4.每”.”一次，就代表一层文件目录。1.2 举例:航运系统MVC1.3JDK中的主要包介绍:. java都是写网页 写客户端很少用 import 关键紫的使用import:导入 1.在源文件中显式的使用import结构导入指定包下的类、接口 2.声明在包的声明和类的声明之间3.如果需要导入多个结构，则并列写出即可 4.可以使用”xxx. *”的方式，表示可以导入xxx包下的所结构5.如果使用的类或接口是java.lang包下定义的，则可以省略import结构 6.如果使用的类或接口是本包下定义的，则可以省略import结构 7.如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。 8.使用”xxx.*”方式表明可以调用Xxxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 import static:导入指定类或接口中的静态结构:属性或方法。 4-6 Eclispe 常用快捷键Eclipse中的快捷键： 1.补全代码的声明：alt + / abcdefg-z* 2.快速修复: ctrl + 1 3.批量导包：ctrl + shift + o 4.使用单行注释：ctrl + / 5.使用多行注释： ctrl + shift + / 6.取消多行注释：ctrl + shift + 修改快捷键 Prefer –keys 7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up 8.删除指定行的代码：ctrl + d 9.上下移动代码：alt + up 或 alt + down 10.切换到下一行代码空位：shift + enter 11.切换到上一行代码空位：ctrl + shift + enter 12.如何查看源码：ctrl + 选中指定的结构 或 ctrl + shift + t 13.退回到前一个编辑的页面：alt + left 14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right 15.光标选中指定的类，查看继承树结构：ctrl + t —– 16.复制代码： ctrl + c 17.撤销： ctrl + z 18.反撤销： ctrl + y 19.剪切：ctrl + x 20.粘贴：ctrl + v 21.保存： ctrl + s 22.全选：ctrl + a 23.格式化代码： ctrl + shift + f 24.选中数行，整体往后移动：tab 25.选中数行，整体往前移动：shift + tab 26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o 27.批量修改指定的变量名、方法名、类名等：alt + shift + r 28.选中的结构的大小写的切换：变成大写： ctrl + shift + x 29.选中的结构的大小写的切换：变成小写：ctrl + shift + y 30.调出生成getter/setter/构造器等结构： alt + shift + s 31.显示当前选择资源(工程 or 文件)的属性：alt + enter 32.快速查找：参照选中的Word快速定位到下一个 ：ctrl + k 用的少 33.关闭当前窗口：ctrl + w 34.关闭所有的窗口：ctrl + shift + w 35.查看指定的结构使用过的地方：ctrl + alt + g 36.查找与替换：ctrl + f 37.最大化当前的View：ctrl + m 38.直接定位到当前行的首位：home 39.直接定位到当前行的末位：end 7. bank 练习的难点 Accout 关联关系类型数组链式结构 123456789101112131415161718192021222324252627282930private Customer[] customers;// 存放多个客户的数组private int numberOfCustomers;// 记录客户的个数public Bank() { customers = new Customer[10];}// 添加客户public void addCustomer(String f, String l) { Customer cust = new Customer(f, l); // customers[numberOfCustomers] = cust; // numberOfCustomers++; // 或 customers[numberOfCustomers++] = cust;}// 获取客户的个数public int getNumOfCustomers() { return numberOfCustomers;}// 获取指定位置上的客户public Customer getCustomer(int index) { // return customers[index];//可能报异常 if (index &gt;= 0 &amp;&amp; index &lt; numberOfCustomers) { return customers[index]; } return null;} 8..项目二 客户信息管理软件 功能演示●模拟实现一个基于文本界面的《客户信息管理软件》●进一步掌握编程技巧和调试技巧，熟悉面向对象编程;●主要涉及以下知识点:➢类结构的使用:属性、方法及构造器➢对象的创建与使用➢类的封装性➢声明和使用数组➢数组的插入、删除和替换➢关键字的使用: this结构.com.atguigu.p2CMUtilityjavaCustomerjavaCustomerLstjavaCustomerViewjava 9. 软件架构设计 10.CMUtility工具类的介绍可用来方便地实现键盘访问 public static char readMenuSelection()用途：该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。 public static char readChar() 和 public static char readChar(char defaultValue)用途：这两个方法功能相同，均从键盘读取一个字符，并将其作为方法的返回值。参数： defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。（提示：此方法可在修改客户时调用） public static int readInt() 和public static int readInt(int defaultValue)用途：这两个方法功能相同，均从键盘读取一个长度不超过2位的 整数，并将其作为方法的返回值。参数： defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 public static String readString(int limit) 和public static String readString(int limit, String defaultValue)用途：这两个方法功能相同，均从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。参数：limit — 指定字符串的最大长度 defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 public static char readConfirmSelection()用途：从键盘读取‘Y’或’N’，并将其作为方法的返回值 11.Customer类的设计2 .3 w行 12.CustomerList类的设计操作数组之前一定要初始化 在结构体里面代码要有注释 13.CustomerView的整体设计的构建 char a=‘1’； 14.CustomerView 退出功能的实现15.CustomerView 客户列表的实现 16.CustomerView 添加客户的实现控制读取字符的长度 17.CustomerView 修改客户的实现 找不到返回主页面 局部变量 18.CustomerView 删除客户的实现19.独立写一下 收获很大 总结认知能力 别停 听了一个月就死了 去写 去熟悉 写多就会了 第五章20.继承性的理解一、继承性的好处 why①减少了代码的冗余，提高代码的复用性②便于功能的扩展③为之后多态性的使用，提供了前提 21.继承性的使用二、继承性的格式： class A extends B{} A:子类、派生类、subclass B:父类、超类、基类、superclass 2.1体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。不可以直接调 只有因为封装性的影响，使得子类不能直接调用父类的结构而已。2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。 —-自类更强大 子类和父类的关系，不同于子集和集合的关系。 extends：延展、扩展 21.继承性的再说明三、Java中关于继承性的规定：11.一个类可以被多个子类继承。 2.Java中类的单继承性：一个类只能有一个父类 3.子父类是相对的概念。 4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 23 Object类的理解四 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类 意味着，所有的java类具有java.lang.Object类声明的功能。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(上)补2","date":"2016-06-27T23:25:46.000Z","path":"2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/","text":"1. 每天一问 什么是方法的重载?两同一不同”:同一个类、相同方法名;参数列表不同如何调用确定的方法:方法名→参数列表。 说明Java方法中的参数传递机制的具体体现?基本数据类型:数据值+引用数据类型:地址值(含变量的数据类型)。Person p1 = new Person( );eat();age+User u1 = p1;//编译错误(逆向思维、反证法)u1. eat()u1.age 成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同? 谈谈return关键字的使用。①结束方法②针对于有返回值的方法，return +返回数据。 提供如下代码的内存解析。 内存结构:栈(局部变量)、堆(new出来的结构:对象(非static成员变量)、数组)2.变量:成员变量vs局部变量(方法内、方法形参、构造器内、构造器形参、代码块内) 1-2. 复习 重载 匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象特点:匿名对象只能调用一次。举例:new Phone() . sendEmail();new Phone( ) . playGame();new Phone() .price = 1999;new Phone() . showPrice();//0.0 万事万物皆对象3.方法的重载概念定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。总结: “两同一不同”:同一个类、相同方法名；参数列表不同:参数个数不同，参数类型不同 构成重载的举例:举例一: Arrays类中 重载的sort() / binarySearch(); PrintStream中 的println()举例/ /如下的4个方法构成了重载public void getSum(int i,int j){System. out. println(“1”);public void getSum( double d1, double d2){System . out . print1n(“2”);}public void getSum(String s， int i){System. out . println(“3”);}public void getSum(int i,String s){System. out . println(“4”);} 不构成重载的举例://如下的3个方法不能与上述4个方法构成重载// public int getSum(int i,int j){//return 0;// }// public void getSum(int m,int n){//// }I// private void getSum(int i,int j){//// }5.如何判断是否构成方法的重载?严格按照定义判断:两同一不同。跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系!6.如何确定类中某-一个方法的调用:方法名—&gt;参数列表面试题:方法的重载与重写的区别throws \\throwString\\StringBuffer\\StringBuilderCollection\\Collectionsfinal \\finally\\finalize 抽象类、接口sleep()/wait( ) 7.可变个数形参的方法 使用说明 1.jdk 5.0新增的内容 2.具体使用: 2.1 可变个数形参的格式:数据类型… 变量名 2.2当调用可变个数形参的方法时，传入的参数个数可以是: 0个，1个,2个， 2.3可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。 2.5可变个数形参在方法的形参中，必须声明在末尾 2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参。 举例说明 调用时 test. show( “he1lo”);test. show( “hello”, “world”);test. show();test. show(new String[ ]{“AA”, “BB”, “CC”}); 3.值传递和递归方法 针对于方法内变量的赋值举例规则 :如果变量是基本数据类型，此时赋值的是变量所保存的数据值。如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。 针对于方法的参数概念 形参:方法定义时，声明的小括号内的参数 实参:方法调用时，实际传递给形参的数据| java中参数传递机制: 值传递规则:如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。推广:如果变量是基本数据类型，此时赋值的是变量所保存的数据值。如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。 String 只想常量方法区 引用数据类型 递归方法 定义递归方法:一个方法体内调用它自身。 如何理解递归方法 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。- 递归一定要向己知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 举例//例1: 计算1-n之间所有自然数的和public int getSum(int n) {//if (n==1) {return 1;}else{return n + getSum(n - 1);}}面试题 面试题 4.封装性的引入IO 验证 和使用面向对象的过程，后面加深理解 面向对象特征之一: 封装与隐藏 为什么需要封装？封装的作用和含义？ 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？ 我要开车， … 我们程序设计追求“高内聚，低耦合”。 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合 ： 仅对外暴露少量的方法用于使用。 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说， 把该隐藏的隐藏起来，该暴露的暴露出来。 这就是封装性的设计思想。 代码 若a.legs=-4 不符合常理 加入条件如下: 让a.leg 不能被调用 private int leg； 一、问题的引入：当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值,加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()）同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private). –&gt;此时，针对于属性就体现了封装性。 二、封装性的体现： 我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值 拓展：封装性的体现：① 如上 ② 不对外暴露的私有的方法 ③ 单例模式（构造器私有） … 三、封装性的体现，需要权限修饰符来配合。1.Java规定的4种权限（从小到大排列）：private、缺省、protected 、public2.4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类3.具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类修饰类的话，只能使用：缺省、public总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。 封装性的提现 public int getAge(){ return age; } 5.封装性的提现6.四种权限修饰的理解 Java权限修饰符public、 protected、 (缺省)、 private置于类的成员定义前，用来限定对象对该类成员的访问权限。 对于class的权限修饰只可以用public和default(缺省)。 public类可以在任意地方被访问。 default类只可以被同一个包内部的类访问。 7.四种权限修饰符的测试权限的大小 打比方公司的秘密 8.封装类的练习 - 表示私有 + 表示public 9.类的成员类的成员之三：构造器(或构造方法) 构造器的特征 它具有与类相同的名称 它不声明返回值类型。（与声明为void不同） 不能被static、 final、 synchronized、 abstract、 native修饰，不能有return语句返回值 构造器的作用： 创建对象；给对象进行初始化 如： Order o = new Order(); Person p = new Person(“Peter”,15); 如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人” 的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了 语法格式：修饰符 类名 (参数列表) {初始化语句；} 举例说明: 根据参数不同，构造器可以分为如下两类： 隐式无参构造器（系统默认提供） 显式定义一个或多个构造器（无参、有参） 注 意：Java语言中，每个类都至少有一个构造器默认构造器的修饰符与所属类的修饰符一致一旦显式定义了构造器， 则系统不再提供默认构造器一个类可以创建多个重载的构造器父类的构造器不可被子类继承 构造器 construct：建设、建造。 construction:CCB constructor:建设者 一、构造器的作用： 1.创建对象 / /创建类的对象:new +构造器 构造器是一种独立的结构 2.初始化对象的信息 ————— 二、说明： 1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器 2.定义构造器的格式：权限修饰符 类名(形参列表){} 3.一个类中定义的多个构造器，彼此构成重载 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器(一旦结婚了，就不给饭吃了 ) 5.一个类中，至少会有一个构造器。 10.构造器使用的细节说明 11-12 .构造器的练习 三角形的练习13 总结属性赋值的过程截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位置，并指明赋值的先后顺序。 赋值的位置:①默认初始化 0.0②显式初始化 1.0③构造器中初始化 123 是一次性的④通过“对象.属性“或“对象.方法”的方式赋值 赋值的先后顺序:①.②-③-④ 14. JavaBean的使用 JavaBean是一种Java语言写成的可重用组件。 所谓javaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、 set方法 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、 Servlet、其他JavaBean、 applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。 一个类就是一个jAVABean—&gt;反射造对象 15. UML类图 16. this调用属性和方法this是什么？ 在Java中， this关键字比较难理解，它的作用和其词义很接近。 它在方法内部使用，即这个方法所属对象的引用； 它在构造器内部使用，表示该构造器正在初始化的对象。 this 可以调用类的属性、方法和构造器 什么时候使用this关键字呢？ 当在方法内需要用到调用该方法的对象时，就用this。具体的：我们可以用this来区分属性和局部变量。比如： this.name = name; 使用this，调用属性、方法 说明 在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添this，增强程序的阅读性。不过，通常我们都习惯省略this。 当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量 3.使用this访问属性和方法时，如果在本类中未找到，会从父类中查找 4.this可以作为一个类中构造器相互调用的特殊格式 使用this调用本类的构造器 注意 可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！ 明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器 如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)” “this(形参列表)”必须声明在类的构造器的首行！ 在类的一个构造器中，最多只能声明一个”this(形参列表) www what(是什么) why(为什么要用) how. 代码中 this关键字的使用 this可以用来修饰、调用：属性、方法、构造器 this修饰属性和方法：this理解为：当前对象 或 当前正在创建的对象 （构造器） 在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 this调用构造器① 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器② 构造器中不能通过”this(形参列表)”方式调用自己 ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”④ 规定：”this(形参列表)”必须声明在当前构造器的首行 ⑤ 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器 17.this调用构造器–减少冗余了构造器里面调用构造器 18 练习boyand girl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.atguigu.exer2;public class Boy { private String name; private int age; public Boy() { } public Boy(String name) { this.name = name; } public Boy(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void marry(Girl girl){ System.out.println(\"我想娶\" + girl.getName()); } public void shout(){ if(this.age &gt;= 22){ System.out.println(\"你可以去合法登记结婚了！\"); }else{ System.out.println(\"先多谈谈恋爱~~\"); } }}*-*----------------- package com.atguigu.exer2;public class Girl { private String name; private int age; public Girl() { } public Girl(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void marry(Boy boy){ System.out.println(\"我想嫁给\" + boy.getName()); boy.marry(this); } /** * * @Description 比较两个对象的大小 * @author shkstart * @date 2019年1月18日下午4:02:09 * @param girl * @return 正数：当前对象大； 负数：当前对象小 ； 0：当前对象与形参对象相等 */ public int compare(Girl girl){// if(this.age &gt; girl.age){// return 1;// }else if(this.age &lt; girl.age){// return -1;// }else{// return 0;// } return this.age - girl.age; } }------------- package com.atguigu.exer2;public class BoyGirlTest { public static void main(String[] args) { Boy boy = new Boy(\"罗密欧\", 21); boy.shout(); Girl girl = new Girl(\"朱丽叶\", 18); girl.marry(boy); Girl girl1 = new Girl(\"祝英台\",19); int compare = girl.compare(girl1); if(compare &gt; 0){ System.out.println(girl.getName() + \"大\"); }else if(compare &lt; 0){ System.out.println(girl1.getName() + \"大\"); }else{ System.out.println(\"一样大\"); } }} 19. 练习Account123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.atguigu.exer3;public class Account { private int id;//账号 private double balance;//余额 private double annualInterestRate;//年利率 public Account (int id, double balance, double annualInterestRate ){ this.id = id; this.balance = balance; this.annualInterestRate = annualInterestRate; } public int getId() { return id; } public void setId(int id) { this.id = id; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } public double getAnnualInterestRate() { return annualInterestRate; } public void setAnnualInterestRate(double annualInterestRate) { this.annualInterestRate = annualInterestRate; } //在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。 public void withdraw (double amount){//取钱 if(balance &lt; amount){ System.out.println(\"余额不足，取款失败\"); return; } balance -= amount; System.out.println(\"成功取出：\" + amount); } public void deposit (double amount){//存钱 if(amount &gt; 0){ balance += amount; System.out.println(\"成功存入：\" + amount); } }}----------package com.atguigu.exer3;public class Customer { private String firstName; private String lastName; private Account account; public Customer(String f,String l){ this.firstName = f; this.lastName = l; } public Account getAccount() { return account; } public void setAccount(Account account) { this.account = account; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } }----------package com.atguigu.exer3;/* * 写一个测试程序。（1） 创建一个Customer ，名字叫 Jane Smith, 他有一个账号为1000，余额为2000元，年利率为 1.23％ 的账户。（2） 对Jane Smith操作。存入 100 元，再取出960元。再取出2000元。打印出Jane Smith 的基本信息成功存入 ：100.0成功取出：960.0余额不足，取款失败Customer [Smith, Jane] has a account: id is 1000, annualInterestRate is 1.23％, balance is 1140.0 */public class CustomerTest { public static void main(String[] args) { Customer cust = new Customer(\"Jane\", \"Smith\"); Account acct = new Account(1000, 2000, 0.0123); cust.setAccount(acct); cust.getAccount().deposit(100); cust.getAccount().withdraw(960); cust.getAccount().withdraw(2000); System.out.println(\"Customer[\" + cust.getLastName() + \",\" + cust.getFirstName() + \"] has a account: id is \" + cust.getAccount().getId() + \",annualInterestRate is \"+ cust.getAccount().getAnnualInterestRate() * 100 + \"% ,balance is \" + cust.getAccount().getBalance()); }} 20. 练习对象数组每加顾客+1或customers [ numberOfCustomers++] = cust; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.atguigu.exer4;public class Account { private double balance; public Account(double init_balance){ this.balance = init_balance; } public double getBalance(){ return balance; } //存钱操作 public void deposit(double amt){ if(amt &gt; 0){ balance += amt; System.out.println(\"存钱成功\"); } } //取钱操作 public void withdraw(double amt){ if(balance &gt;= amt){ balance -= amt; System.out.println(\"取钱成功\"); }else{ System.out.println(\"余额不足\"); } }}---package com.atguigu.exer4;public class Customer { private String firstName; private String lastName; private Account account; public Customer(String f, String l) { this.firstName = f; this.lastName = l; } public Account getAccount() { return account; } public void setAccount(Account account) { this.account = account; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } }----package com.atguigu.exer4;public class Bank { private Customer[] customers;// 存放多个客户的数组 private int numberOfCustomers;// 记录客户的个数 public Bank() { customers = new Customer[10]; } // 添加客户 public void addCustomer(String f, String l) { Customer cust = new Customer(f, l); // customers[numberOfCustomers] = cust; // numberOfCustomers++; // 或 customers[numberOfCustomers++] = cust; } // 获取客户的个数 public int getNumOfCustomers() { return numberOfCustomers; } // 获取指定位置上的客户 public Customer getCustomer(int index) { // return customers[index];//可能报异常 if (index &gt;= 0 &amp;&amp; index &lt; numberOfCustomers) { return customers[index]; } return null; }}+-++++++package com.atguigu.exer4;public class BankTest { public static void main(String[] args) { Bank bank = new Bank(); bank.addCustomer(\"Jane\", \"Smith\"); //连续操作 bank.getCustomer(0).setAccount(new Account(2000)); bank.getCustomer(0).getAccount().withdraw(500); double balance = bank.getCustomer(0).getAccount().getBalance(); System.out.println(\"客户：\" + bank.getCustomer(0).getFirstName() + \"的账户余额为：\" + balance); System.out.println(\"***********************\"); bank.addCustomer(\"万里\", \"杨\"); System.out.println(\"银行客户的个数为：\" + bank.getNumOfCustomers()); }}------- 21.package关键字的使用 package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。 (若缺省该语句，则指定为无名包)。它的格式为：package 顶层包名.子包名 包对应于文件系统的目录， package语句中，用 “.” 来指明包(目录)的层次； 包通常用小写单词标识。通常使用所在公司域名的倒置： com.atguigu.xxx 包的作用： 包帮助管理大型软件系统： 将功能相近的类划分到同一个包中。 比如： MVC的设计模式 包可以包含类和子包， 划分项目层次， 便于管理 解决类命名冲突的问题 控制访问权限 一、package关键字的使用1.为了更好的实现项目中类的管理，提供包的概念2.使用package声明类或接口所属的包，声明在源文件的首行3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”4.每”.”一次，就代表一层文件目录。 补充：同一个包下，不能命名同名的接口、类。 不同的包下，可以命名同名的接口、类。JDK中主要的包介绍 22.MVC设计模式的理解​ MVC是常用的设计模式之一，将整个程序分为三个层次： 视图模型层，控制器层，与数据模型层。 这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性 23 import 关键字的使用二、import关键字的使用import:导入 在源文件中显式的使用import结构导入指定包下的类、接口 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用”xxx.*”的方式，表示可以导入xxx包下的所有结构 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果使用的类或接口是本包下定义的，则可以省略import结构 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。————***** 使用”xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 * 不代表子包 import static:导入指定类或接口中的静态结构:属性或方法。 eg import static java.lang.System.*； out.print(“121”) 为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(.*)。 import语句告诉编译器到哪里去寻找类。 语法格式：import 包名. 类名; 应用举例：import pack1.pack2.Test; //import pack1.pack2.*;表示引入pack1.pack2包中的所有结构 注意： 在源文件中使用import显式的导入指定包下的类或接口 声明在包的声明和类的声明之间。 如果需要导入多个类或接口，那么就并列显式多个import语句即可 举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。 如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。 如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。 import static组合的使用：调用指定类或接口下的静态的属性或方法 两个date # document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(上)补1","date":"2016-06-27T02:57:13.000Z","path":"2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/","text":"1-2. 每天一问不是获取文件，而是过程，抄别人没有意义 1.面向对象思想编程内容的三条主线分别是什么 ①类及类的成员:属性、方法、构造器;代码块、内部类②面向对象的三大特征:封装、继承、多态。 ③其它关键字: this,super,abstract,interface,static,final,package,import 面向对象的编程思想?(类、对象;面向对象的三大特征…) 2.谈谈你对面向对象中类和对象的理解，并指出二者的关系 类:抽象的、概念上的内容。对象:实实在在存在的一个个体。对象是由类派生出来的。 3.面向对象思想的体现一:类和对象的创建和执行操作有哪三步? ①创建类②类的实例化。③调用对象的结构: “对象，属性” “对象.方法’ 4.类的方法内是否可以定义变量?是否可以调用属性?是否可以定义方法?是否可以调用方法? 是;是;否;是 3-4 复习学习 1个月 就可以工作了 1.面向对象学习的三条主线:①类及类的成员:属性、方法、构造器;代码块、内部类②面向对象的三大特征:封装、继承、多态。③其它关键字: this,super,abstract,interface,static,final,package,import “大处着眼，小处着手”2.面向对象与面向过程(理解)1.面向过程: 强调的是功能行为，以函数为最小单位，考虑怎么做。2.面向对象: 强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。 举例: 把大象装进冰箱3.完成一一个项目(或功能)的思路: 根据问题需要，选择问题所针对的现实世界中的实体。 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。 把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。 将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。 4.面向对象中两个重要的概念: 类:对一类事物的描述，是抽象的、概念上的定义 对象:是实际存在的该类事物的每个个体，因而也称为实例(instance)面向对象程字设计的重点是类的设计设计类，就是设计类的成员。 二者的关系:对象，是由类new出来的，派生出来的。 5.面向对象思想落地实现的规则一 1.创建类，设计类的成员 2.创建类的对象 3.通过“对象.属性”或“对象.方法”调用对象的结构 补充:几个概念的使用说明属性=成员变量=fie]d=域、字段方法=成员方法=函数= method创建类的对象=类的实例化=实例化类 6.对象的创建与对象的内存解析 典型代码:Person p1 = new Person();Person p2 = new Person();Person p3 = p1;//没有新创建-一个对象，共用一个堆空间中的对象实体。 说明:如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非static的)意味着:如果我们修改一-个对象的属性a，则不影响另外–个对象属性a的值。 7. JVM 内存结果《JVI规范》 虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中 堆，我们将nev出来的结构(比如:数组、对象)加载在对空间中。补充:对象的属性(非static的)加载在堆空间中。 方法区:类的加载信息、常量池、静态域 5. 属性和方法局部变量和属性 相同点和不同点 补充: 回顾变量的分类 1.按照数据类型分 2.按照类中声明的位置 方法复习关键字return方法的使用6. 万物皆对象一、理解“万事万物皆对象”1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构Scanner,String等文件：File网络资源：URL2.涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。 7. 对象数组的内存解析内存解析的说明1.引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型） 8. 匿名对象的使用 （可以看到这个）有名的对象eg 匿名对象 1.理解我们创建的对象，没有显式的赋给一个变量名。即为匿名对象 2.特征匿名对象只能调用一次。 3.实现代码 PhoneMall p104类比，你给别人的匿名信，他写上名字了mall.show(new Phone()); class PhoneMall{ public void show(Phone phone){ phone.sendEmail(); phone.playGame(); } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class InstanceTest { public static void main(String[] args) { Phone p = new Phone();// p = null; System.out.println(p); p.sendEmail(); p.playGame(); //匿名对象// new Phone().sendEmail();// new Phone().playGame(); new Phone().price = 1999; new Phone().showPrice();//0.0 //********************************** PhoneMall mall = new PhoneMall();// mall.show(p); //匿名对象的使用 mall.show(new Phone()); }}class PhoneMall{ public void show(Phone phone){ phone.sendEmail(); phone.playGame(); } }class Phone{ double price;//价格 public void sendEmail(){ System.out.println(\"发送邮件\"); } public void playGame(){ System.out.println(\"玩游戏\"); } public void showPrice(){ System.out.println(\"手机价格为：\" + price); } } 9.自定义数据工具类合理 整洁 复用性 –工具类的封装 10.理解方法的重载10.1方法的重载 重载的概念overload 参数列表在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 “两同一不同”:同一个类、相同方法名 参数列表不同：参数个数不同，参数类型不同 重载的特点:与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。 重载示例://返回两个整数的和int add(int x,int y){return x+y;}//返回三个整数的和int add(int x,int y,int z){return x+y+Z;}1返回两个小数的和double add(double x,double y){return x+y;} 11.方法的重载细节介绍 重载的判断跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！ 在通过对象调用方法时，如何确定某一个指定的方法：方法名 —&gt; 参数列表(还要看) 12.重载的举例与判断使用重载，可以为编程带来便捷a nb y 不要看返回值类型c yd yee yf ng n 13.编程实现duplicate 重复的 多重的 14.可变个数的形参的方法可变形参的方法JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。//JDK 5.0以前:采用数组形参来定义方法，传入多个同一类型变量public static void test(int a ,String[] books);//JDK5.0:采用可变个数形参来定义方法，传入多个同一类型变量public static void test(int a ,String…books); 具体使用 1.可变个数形参的格式：数据类型 … 变量名 2.当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。 3.可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 9-11 4.可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。图9-12 5.可变个数形参在方法的形参中，必须声明在末尾String .. .strs必须声明在末尾 public void show(int i,String .. .strs)； 6.可变个数形参在方法的形参中,最多只能声明一个可变形参。 一山不容二虎打比方:万能备胎王 ；任何找不到 都不可以找到他；解说都要是String类型 才可以 原来的时候 123test.show(new String[]{\"AA\",\"BB\",\"CC\"});public void show(String[] strs){} 现在 123456789101112不用newtest.show(\"AA\",“BB”)；这样做也对test.show(new String[]{\"AA\",\"BB\",\"CC\"}); public void show(String ... strs){ System.out.println(\"show(String ... strs)\"); for(int i = 0;i &lt; strs.length;i++){ System.out.println(strs[i]); } } 应用: SQL 查条件 where 之后条件不知道要写几个 15.理解变量的赋值** 难点方法参数的值传递机制 方法，必须由其所在类或对象调用才有意义。若方法含有参数: 形参:方法声明时的参数 实参:方法调用时实际传给形参的参数值 Java的实参值如何传入方法呢?Java里方法的参数传递方式只有一种:值传递。即将实际参数值的副本(复制品)传入方法内，而参数本身不受影响。 形参是基本数据类型:将实参基本数据类型变量的“数据值”传递给形参 形参是引用数据类型:将实参引用数据类型变量的“地址值”传递给形参每天坚持 不停去写真是存的数字给它了，自己没有动 order o1=o2；一个对象的值修改了会影响到另一个对象Order o2 = o1;//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。 关于变量赋值如果变量是基本数据类型，此时赋值的是变量所保存的数据值。如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。 16.方法的形参的传递机制：值传递12形参：方法定义时，声明的小括号内的参数实参：方法调用时，实际传递给形参的数据 值传递机制：如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。 17.方法的形参的传递机制：引用数据类型传递 ###引用数据类型 赋值了地址 交换两个数组元素的值 18.画图19.探讨网红题目 20 参数传递的联系21 递归方法的使用递归方法 –理解 递归方法：一个方法体内调用它自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。eg//计算1-100之间所有自然数的和public int sum(int num){if(num == 1){return 1;}else{return num + sum(num - 1);}} 22 递归方法的使用递归的练习 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(上)","date":"2016-06-26T22:49:32.000Z","path":"2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/","text":"Java语言的基本元素 类与对象5. 面向对象的思想概述 类(Class)和对象(Object)是面向对象的核心概念。 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。 万事万物皆对象 可以理解为:类=抽象概念的人;对象=实实在在的某个人 面向对象程序设计的重点是类的设计（图纸） 类的设计，其实就是类的成员的设计 6.类的结构: 属性和方法Java类及类的成员 现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多个不同功能的类构成的。 现实生物世界中的细胞又是由什么构成的呢?细胞核、细胞质、..那么,Java中用类class来描述事物也是如此。常见的类的成员有: 属性:对应类中的成员变量 行为:对应类中的成员方法 Field=属性=成员变量=域，字段，Method= (成员)方法=函数eg： 生活中描述事物无非就是描述事物的属性和行为。如:人有身高，体重等属性，有说话,打球等行为。类的成员构成version 1.0 类的成员构成version 2.0 7.类和对象的创建 创建类的对象=类的实例化=实例化类 创建对象语法： 类名 对象名 = new 类名(); 使用“对象名.对象成员”的方式访问对象成员（包括属性和方法） 二、类和对象的使用(面向对象思想落地的实现) 创建类，设计类的成员（多） 创建类的对象 通过““对象.属性或“对象.方法”调用对象的结构123456789101112131415161718192021222324252627282930313233343536class Person{ //属性 String name; int age = 1; boolean isMale; //方法 public void eat( ) { System.out.println(\"人可以吃饭\"); } public void sleep() { System.out.println(\"人可以睡觉\"); } public void talk(String language) { System.out.println(\"人可以说话,使用的是: \" + language); }}//测试类public class PersonTest {public static void main(String[] args) {//创建Person类的对象Person p1 = new Person( ) ;//Scanner scanner = new Scanner(System.in);//调用对象的结构:属性、方法//调用属性:“对象.属性”p1.name = \"Tom\";p1. isMale = true;System. out . println(p1. name);//调用方法:“对象。方法”p1.eat();p1.sleep();p1. talk(\"Chinese\"); } } 8.对类和对象创建的再理解有了对象反推出类—&gt;反射9.类多个对象的关系== 打比方 简历的模板 ，谁填是谁的信息 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非static的) 意味着:如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。 123//将p1变量保存的对象地址值赋给p3 ,导致p1和p3指向了堆空间中的同一个对象实体。Person p3=p1;System. out. println(p3.name);/ /Tom 10.对象的内存解析 方法中定义的变量都是局部变量 11.属性与局部变量的对比11-12属性(成员变量) VS 局部变量 （打比方 放的位置不同 蜂王和工蜂） 1.相同点 定义变量的格式:数据类型变量名=变量值 先声明，后作用 变量都有其对应的作用域、 2.不同点 在类中声明的位置的不同 属性：直接定义在类的一对{}内 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、public、缺省、protected ---&gt;封装性 作用域的大小 目前，大家声明属性时，都使用缺省就可以了。 局部变量：不可以使用权限修饰符，并没有默认初始化值（也就是理解方法代替了） 默认初始化值的情况: 属性:类的属性，根据其类型，都有默认初始化值。整型(byte、short、int、long):0浮点型(float、double) 0.0字符型(char):0或’\\u0000’ )布尔型(boolean) : false引用数据类型(类、数组、接口) : null 局部变量:没有默认初始化值。意味着，我们在调用局部变量之前，一定要显式赋值。特别地:形参在调用时，我们赋值即可。（下图） 在内存中加载的位置:属性:加载到堆空间中(非static 存在 方法区)局部变量:加载到栈空间 13. 类中方法举例与声明的格式方法：描述类应该具有的功能比如 Math类的sqrt() 举例public void eat(){}public void sleep(int hour){}public String getName(){}public String getNation(String nation){} 方法的声明：权限修饰符 返回值类型 方法名(形参列表){ 方法体 };注意：static、final、abstract 来修饰的方法，后面再讲。 14. 方法声明的说明14-15 说明： 3.1 关于权限修饰符：默认方法的权限修饰符先都使用publicJava规定的4种权限修饰符：private、public、缺省、protected –&gt;封装性再细说 3.2 返回值类型： 有返回值 vs 没有返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：“return 数据”。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。 3.2.2 我们定义方法该不该有返回值？① 题目要求② 凭经验：具体问题具体分析 3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 3.4 形参列表： 方法可以声明0个，1个或多个形参。 3.5 方法体：方法功能的体现。 16 return关键字的使用 return关键字的使用： 1.使用范围：使用在方法体中 2.作用：① 结束方法 ② 针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。 3.注意点：return关键字后面不可以声明执行语句。17. 方法使用中的注意点 方法的使用中，可以调用当前类的属性或方法特殊的：方法A中又调用了方法A:递归方法。方法中，不可以定义方法。 18-19-20. 类的设计 练习21-22 test 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* * 4. 对象数组题目：定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。问题一：打印出3年级(state值为3）的学生信息。问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息提示：1) 生成随机数：Math.random()，返回值类型double; 2) 四舍五入取整：Math.round(double d)，返回值类型long。 * * * * */public class StudentTest { public static void main(String[] args) {// Student s1 = new Student();// Student s1 = new Student();// Student s1 = new Student();// Student s1 = new Student();// Student s1 = new Student();// Student s1 = new Student(); //声明Student类型的数组 Student[] stus = new Student[20]; //String[] arr = new String[10]; for(int i = 0;i &lt; stus.length;i++){ //给数组元素赋值 stus[i] = new Student(); //给Student对象的属性赋值 stus[i].number = (i + 1); //年级：[1,6] stus[i].state = (int)(Math.random() * (6 - 1 + 1) + 1); //成绩：[0,100] stus[i].score = (int)(Math.random() * (100 - 0 + 1)); } //遍历学生数组 for(int i = 0;i &lt;stus.length;i++){// System.out.println(stus[i].number + \",\" + stus[i].state // + \",\" + stus[i].score); System.out.println(stus[i].info()); } System.out.println(\"********************\"); //问题一：打印出3年级(state值为3）的学生信息。 for(int i = 0;i &lt;stus.length;i++){ if(stus[i].state == 3){ System.out.println(stus[i].info()); } } System.out.println(\"********************\"); //问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息 for(int i = 0;i &lt; stus.length - 1;i++){ for(int j = 0;j &lt; stus.length - 1 - i;j++){ if(stus[j].score &gt; stus[j + 1].score){ //如果需要换序，交换的是数组的元素：Student对象！！！ Student temp = stus[j]; stus[j] = stus[j + 1]; stus[j + 1] = temp; } } } //遍历学生数组 for(int i = 0;i &lt;stus.length;i++){ System.out.println(stus[i].info()); } }}class Student{ int number;//学号 int state;//年级 int score;//成绩 //显示学生信息的方法 public String info(){ return \"学号：\" + number + \",年级：\" + state + \",成绩：\" + score; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* * 4. 对象数组题目： 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。问题一：打印出3年级(state值为3）的学生信息。问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息提示：1) 生成随机数：Math.random()，返回值类型double; 2) 四舍五入取整：Math.round(double d)，返回值类型long。 * * * 此代码是对StudentTest.java的改进：将操作数组的功能封装到方法中。 * */public class StudentTest1 { public static void main(String[] args) { //声明Student类型的数组 Student1[] stus = new Student1[20]; for(int i = 0;i &lt; stus.length;i++){ //给数组元素赋值 stus[i] = new Student1(); //给Student对象的属性赋值 stus[i].number = (i + 1); //年级：[1,6] stus[i].state = (int)(Math.random() * (6 - 1 + 1) + 1); //成绩：[0,100] stus[i].score = (int)(Math.random() * (100 - 0 + 1)); } StudentTest1 test = new StudentTest1(); //遍历学生数组 test.print(stus); System.out.println(\"********************\"); //问题一：打印出3年级(state值为3）的学生信息。 test.searchState(stus, 3); System.out.println(\"********************\"); //问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息 test.sort(stus); //遍历学生数组 test.print(stus); } /** * * @Description 遍历Student1[]数组的操作 * @author shkstart * @date 2019年1月15日下午5:10:19 * @param stus */ public void print(Student1[] stus){ for(int i = 0;i &lt;stus.length;i++){ System.out.println(stus[i].info()); } } /** * * @Description 查找Stduent数组中指定年级的学生信息 * @author shkstart * @date 2019年1月15日下午5:08:08 * @param stus 要查找的数组 * @param state 要找的年级 */ public void searchState(Student1[] stus,int state){ for(int i = 0;i &lt;stus.length;i++){ if(stus[i].state == state){ System.out.println(stus[i].info()); } } } /** * * @Description 给Student1数组排序 * @author shkstart * @date 2019年1月15日下午5:09:46 * @param stus */ public void sort(Student1[] stus){ for(int i = 0;i &lt; stus.length - 1;i++){ for(int j = 0;j &lt; stus.length - 1 - i;j++){ if(stus[j].score &gt; stus[j + 1].score){ //如果需要换序，交换的是数组的元素：Student对象！！！ Student1 temp = stus[j]; stus[j] = stus[j + 1]; stus[j + 1] = temp; } } } } }class Student1{ int number;//学号 int state;//年级 int score;//成绩 //显示学生信息的方法 public String info(){ return \"学号：\" + number + \",年级：\" + state + \",成绩：\" + score; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"基本数据类型","date":"2016-06-24T12:08:07.000Z","path":"2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/","text":"1. Java 语言基础-基本数据类型1. HelloWorld程序的讲解 public、class、static、 void为关键字，固定写法 HelloWord 为类名，可以任意写 main 为函数或方法名，每个程序都有一个main函数做为入口，如同房间，需要有个门一样 main方法后面括号的内容称为参数 System. out. println(“HelloWord” )向控制台输入内容 注意:类名第一个字母要使用大写，花括号是成对出现的 2. 常量的概述和使用什么是常量在程序执行的过程中其值不可以发生改变 Java中常量的分类①字面值常量②自定义常量(面向对象部分讲) 字面值常量的分类①字符串常量用双引号括起来的内容 “Java”②整数常量所有整数 1000③小数常量所有小数 3.14 有效数字 float 6-7 double 15-16④字符常量用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号 ‘c’⑤布尔常量较为特殊，只有true和false⑥空常量null [数组部分]win10 快速访问 3. 二,八,十六进制什么是进制 进制是一种进位方法。对于任何一种进制 X进制，就表示某-位置上的数 运算时逢X进一一位。 二进制就是逢二进一， 八逆制是逢八进一， 十进制是逢十进一， 十六进制是逢十六进-一。 不同进制数据的Java表现形式 二进制的数据表现形式 -一 由0,1组成。以0b(b可大小写)开头2= 10System.out.print(0b10); 八进制的数据表现形式— 由0,1,…7组成。 以0开头[8= 10] System.out.print(011); 十进制的数据表现形式—由0,1-9组成。整数默认是十进制的[10= 10] 十六进制的数据表现形式—由,1,–9,a,b,c,d,e,f(大小写均可)。以0x开头[16= 10] System.out.print(0X16); 注意:只有JDK1.7版本以上可以使用0b2来表示二进制 二进制 在计算机中，只能识别二进制的数据，二进制就是0和1来表示的 如上图表示1个字节，一个字节有8个比特位(1lbyte =8bit) 字节是数据存储的基本单位 数据存储单位计算1byte=8bit (比特)1kb = 1024byte1M = 1024kb1G = 1024M1T=1024G 二进制和十进制的转换 任意进制到十进制的转换原理 系数:就是每一位上的数据。 基数: x进制，基数就是X. 权:在右边，从0开始编号，对应位上的编号即为该位的权。 结果:把系数*基数的权次幂相加即可。 图解 八进制到十进制的转换 十六进制到十进制的转换 原码反码补码 有符号数据表示法的几种方式 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 左边是最高位，右边最低位 1111 1111 255 - 通过一个字节,也就是8个二进制位表示+7和-7 - 0(符号位) 0000111 +7 - 1(符号位) 0000111 -7 反码正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 eg. -7 1 000 0111（原码） 反码 11111 000 补码正数的补码与其原码相同；负数的补码是在其反码的末位加1 -7的补码 1111 1001 原码反码补码练习 已知原码求补码* 0b10110100 11001011+1 1100 1100 已知补码求原码* 0b11101110 1110 1110 1110 1101 -&gt;1001 0010 4. 变量和数据类型 变量的概述及格式 什么是变量在程序执行的过程中，在某个范围内其值可以发生改变的量 变量的定义格式，[如同数据方程式xyz, 求值]数据类型 变量名=变量值;byte b= 127; 为什么要定义变量用来不断的存放同类型的常量,并可以重复使用 5. 基本数据类型的定义 为什么有数据类型 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型， 每一种数据类型在内存中分配了不同大小的内存空间 这样做是为了充分高效的利用内存空间 -&gt; 2m的人 2m床 Java中数据类型的分类①基本数据类型②引用数据类型(面向对象部分) 基本数据类型分类(4类8种) 整数型:byte (字节类型) 占一个字节 -2^72^7-1[-128127] 不能把一个int 型转换为byte型 short 占两个字 -2^15~ 2^15-1 [ -3276832767]int 占四个字节-2^312^31-1 [-2^31=2147483647]1ong 占八个字节- 2^63~ 2^63-1 [ -2^63=9223372036854775807]写长整型时，加个L标识,可以写小写的l,但小写的l像一，不建议写 long d = -922L; System.out.println(d); 浮点型:float单精度占四个字节 -3.403E38~3.403E38单精度型使用F标识,不加F,默认就是双精度 float e = 1.87312343F;//单精度型使用F标识 System.out.println(e); double双精度占八个字节-1.798E308~1.798E308 字符型: char占两个字节0~65535 布尔型: boolean java中boolean类型没有明确指定他的大小 基本数据类型定义的注意事项 赋值时候注意float类型,long类型，加大写的F和L 作用域问题:同一个区域不能使用相同的变量名 初始化值问题:局部变量在使用之前必须赋值 一条语句可以定义几个变量 eg: int a,b,c 6.数据类型转换 Java中 的默认转换规则 取值范围小的数据类型与取值范围大的数据类型进行运算会先将小的数据类型提升为大的.再运算 Java的运算是以补码形式运算的得到了结果是1000 0010 == -2 再转换为补码强制类型转换会损失精度 数据类型相加的细节 进行混合运算的时候,byte,short,char不会相互转换都会自动类型提升为int类型 byte,short,char与其他类型进行混合运算的是小的数据类型提升为大的 7.面试题:long与float的取值范園谁大谁小 重点 8.字符和字符串参与运算字符 字符是指计算机中使用的字母、数字、字和符号，包括: 1、2、3、A、B、C、~，( )一一+等等。 在ASCII编码中，一个英文字母字符存储需要1个字节。 在GB2312编码或GBK编码中，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母存储需要1个字节，一个汉字储存需要3到4个字节。 字符的定义 使用char来定义字符类型 给char赋值时，如果是字母或者其它字符使用单引用号如: char c=‘a’ 给char 赋值时，可以直接使用asci表的数字如: char c= 97 在ascii表中大写的与小写的相差32 告白12345678char c1 = 73;char c2 = 76;char c3 = 111;char c4 = 118;char c5 = 101;char c6 = 89;char c7 = 111;char c8 = 117; 字符的相加 字符相加会把字符对应的ascii数字相加 记住ASCII码的三个值：‘0’ 48‘A’ 65‘a’ 97 字符与字符串相加 char数据与中文 char数据类型char 在ascii编码中占1个字节 取值在0到127char 在unicode编码中占2个字节 取值在0到65535 面试题:Java语言中的字符char可以存储一个中文汉字吗?为什么呢?1可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节，utf-8编码是unicode中的一种编码，所以，Java中的字符可以存储一个中文汉字 注:可以把编码类型改成ascii再打印中文给学生看，讲解为什么GBK编码 ： 只能显示简体中文GB2312编码:只能显示简体、繁体中文Unicode编码：不仅可以存中文，还有可存日文，韩文(万国码)-UTF-8 (万国码)-UTF-16 Unicode码 Unicode是一种字符集，中、日、韩的三种文字占用了Unicode中0x3000到0x9FFF的部分 Unicode采用的是UCS-2,用两个字节表示一个字符，2的16次方等于65536，最多能编码65536个字符 比如汉字“经”的编码是0x7ECF （字符码一般用16进制表示），转换成10进制就是32463 unicode编码从0到127的字符与ASCII编码的字符一样 比如字母”a”的Unicode 编码是0x0061,十进制是97 而”a”的ASCII编码是0x61,十进制也是97 对于汉字的编码，事实上Unicode对汉字支持不怎么好 因为简体和繁体总共有六七万个汉字，而UCS-2最多能表示65536个，才六万 多个 所以Unicode只能排除一些几乎不用的汉字 好在常用的简体汉字 也不过七千多个 为了能表示所有汉字，Unicode也有UCS-4规范，就是用 4个字节来编码字符 UTF-8编码 UTF-8(8-bit Unicode Transformation Format)是一种针对Unicode的可变长度字符编码,又称万国码。项目开发中常用utf-8 查看部分unicode码表http://baike.baidu.com/item/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8/12022016?sefr=cr 在线unicode码转换 网址: http://tool.chinaz.com/tools/unicode.aspx 演示a的unicode \\u0061 0x61 演示中的unicode \\u4e2d 熟记中文在unicode的范围 \\u4E00-\\u9FA5 19968 ~ 40869 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"引言:为什么学习Java以及怎么学习Java","date":"2016-06-24T10:11:03.000Z","path":"2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/","text":"1认识Java+1. Java在公司里是用于干啥的?(主要1和3)①Java web: 银行系统&amp;银行网站&amp;酒店系统&amp;N多后台管理系统 主要②App: android是 用java写的，今年出了新的kotlin语言③接口:为android、i0S等App提供数据访问接口 主要④大数据(马云说过“大”是计算的意思)⑤桌面应用(比较少开发桌面应用)⑥…. 2. Java的招聘需求及薪资 拉钩 3. Java的职业规划发展方向 首席java程序员 项目组组长:管理一个小团队 技术总监:主要把控项目中技术一块 软件系统架构师:负责整个项目的架构和技术实施方案（服务器 运维 并发 5年） 技术合伙人:公司的技术一把手，以技术来占公司股份，不需要花钱买（以技术入股） 软件营销:成为一个软件方面的销售高手 当IT讲师:传授你的工作经验 创业:与其他好友同事创业，开自己的公司，接外包或者做自己的产品 赚得一-定财富后，回老家开小店过小日子 (年薪20万 要有副业) 4. Java的就业前景和形势 领域非常广Java技术具有卓越的通用性、高效性、平台移植性和安全性，广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，所以说Java的应用领域非常广，同时拥有全球最大的开发者专业社群 需求量大Java是全球最流行的开发语言，我国的软件开发人才极为缺乏，其中java人才缺口最大，对java软件工程师的需求达到全部需求量的60% -70%，Java又 是安卓开发的基础，所以人才的需求又增加一大波。 就业方向非常广学完可应聘java\\h5\\android\\大数据架构师等职位。。。Java是一一门世界最好的语言，学会了Java再学习其它语言php, ios, python等非常容易上手一个星期或者半个月就可以做项目总结:学了Java,你可以在招聘网上投递的职位非常多需求量巨大 5. Java的学习方法和建议 跟着上课老师的课程大纲学习，掌握课堂知识点。 勤做笔记，如果上课走神或者没听懂的知识点，记下时间，再倒回去看视频。 复习时看视频，尽量1.5~2倍来看视频,课后多练代码。 写多了 就理解多了 尽量老师一边讲课，同学们一边写代码，当场掌握知识点。 不懂的多问老师与同学，因为毕业后，不一定才能能及时帮到你。 要有自己的思维，做一个功能或者需求时，想想有没有另一种方法。 多与同班同学交流，丰富情感生活，以后好互相推荐工作。 脑子累了要休息，尽量不要晚上通宵写代码，身体要紧。 每周或者两周要去参加一个活动,集体打球。 还有一点是学程序开发，有时是枯澡无味的，要忍住无聊和寂寞，特别是Java基础 6. 学习前要谨记一些心态 只要努力掌握课堂知识和老师的建议再加上自己的信心，找份较满意工资的工作是没有问题 一个班不可能每个都拿高薪，工资高的不一定是知识掌握的最好的那位同学。有时高薪看天时地利人和 学习Java找工作，只是你的一一个起点，以后你还会学习其它的语言，或者说不干程序员这份工作也说不定。(sina- 程序员辞职卖水果) 只要学精一门语言，不用怕以后这门语言不值钱，不用怕以后找不到工作。经验是最值钱的 对自己要有信心&amp;工资量&amp;打牢固公司看中经验 2.计算机基础&amp;DOS1. 计算机简介: 计算机(computer) 俗称电脑，是现代一种用于高速计算的电子计算机器，是能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。 计算机由硬件系统和软件系统所组成，没有安装任何软件的计算机称为裸机。 计算机可分为超级计算机、工业控制计算机、网络计算机、个人计算机、嵌入式计算机五类，较先进的计算机有生物计算机、光子计算机、量子计算机等。 计算机发明者约翰.冯，诺依曼。计算机是20世纪最先进的科学技术发明之一 计算机的硬件分成5大组成部件:运算器、控制器、存储器、输入设备和输出设备。 运算器、控制器合称为中央处理单元(Central ProcessingUnit, CPU)或处理器 存储器分为:内部存储器(内存条) -重启电脑数据不在 外部存储器(U盘、硬盘),重启电脑数据还在 输入设备有键盘、 鼠标等 输出设备有显示器、打印机等 2. 计算机的操作系统 操作系统(Operating System, 简称0S)是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在”裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。 常见的操作系统: Windows/Linux/MacOS/ Android/ iOS 3. 计算机软件概念 软件(中国大陆及香港用语，台湾称作软体，英文: Software) app 软件是一系列按照特定顺序组织的计算机数据和指令的集合。 一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件。 系统软件:windows/linux/macOS/ Android/i0S 应用软件:QQ WeChat 浏览器迅雷、后台系统等… 4. 软件开发的概念什么是软件开发借助开发工具与计算机语言制作软件 什么是计算机语言人与计算机之间进行信息交流沟通的一种特殊语言 计算机语言的分类 机器语言:机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。 汇编语言:汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。 高级语言:使用普通英语进行编写源代码，通过编译器将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。高级语言包括C,C++, C#, JAVA，PHP, Py thon 5. DOS命令​ DOS (磁盘操作系统)命令，是DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。常用命令如下: win+e 文件资源管理器 win+r 命令行 1. 查看目录内容命令dir 2. 打开指定目录命令[语法: cd路径] 拖拽 2.1 同盘下(切换路径) 2.2 异盘下(切换到D盘) 2.3 特殊用法 ;返回当前盘的根路径 3. 创建目录命令[语法:md 文件夹名字] —mkdir dir4. 删除当前指定的目录[语法:rd 路径] –remove 1235. 创建文件 echo a&gt; a.txt6. 文件复制命令[语法: copy 源文件路径 目标文件路径] 执行效果相同 7. 显示文本文件内容命令[语法: type 文件名]8. 更改文件名命令[语法: ren a.txt a1.txt]9. 删除文件命令[语法: del a.txt a1.txt] note 😛 同时删除2个10. 清除屏幕命令 cls11. 改变当前盘符命令d:12. 查看环境变量path or echo %path%3.Java 开发环境的准备1. Java语言发展史 詹姆斯.高斯林(James Gosling) 1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得 了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统， 但不受重视。后来转至Sun公司，1990年， 与Patrick, Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak” ，后改名为Java。 SUN (Stanford Uni versity Network, 斯坦福大学网络公司) 卡内基梅隆大学截至2017年卡耐基梅隆大学共培养出了12个图灵奖，20个诺贝尔奖，9个奥斯卡，114个艾米奖，44个托尼奖，非常牛逼的大学。 Java是一 门软件编程语言，可编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 早期Sun公司研发 人员对C++进行改造，开发了一种称为Oak的面向对象语言 1995年，Sun公司将Oak更名为Java 1996年，Sun公司发布了Java的第一个开发工具包(JDK1.0) 1998年，第二代Java平台的企业版J2EE发布 1999年公司发布了第二代Java平台(简称为Java2)的3个版本J2ME (Java2 Micro Edition, Java2平 台的微型版)，应用于移动、无线及有限资源的环境;J2SE (Java 2 Standard Edition, Java 2平台的标准版)，应用于桌面环境;J2EE (Java 2Enterprise Edition, Java 2平台的企业版)，应用于基于Java的应用服务器。 Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。 2009年，甲骨文公司宣布收购Sun。 2010年，Java编程语言的共同创始人之一詹姆斯.高斯林(Java之父)从Oracle公司辞职。 2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。 2014年，甲骨文公司发布了Java8正式版。 2017年，甲骨文公司发布了Java9 2. Java语言版本 老版本稳定，追求稳定 3. Java语言特点​ 简单性、解释性、面向对象、高性能、分布式处理、多线程、健壮性、动态性、安全性、跨平台、移植性注:这是一道笔记题，需要记住 4. Java语言跨平台原理4.1 什么是跨平台性1开发的软件在任何操作系统(mac/window/linux)上都能安装并运行 4.2 Java语言跨平台原理1只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。 4.3 Java语言跨平台图解 4.4 write once ，run anywhere!(一处编译,到处运行)5. JRE和JDK的概述5.1 什么是JRE (Java Runtime Environment) JRE包括Java虛拟机(JVM Java Virtual Machine)和Java程序所需的核心类库(jar 包)等 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。（java-&gt;jar） 总的说JRE = JVM +核心类库 5.2 什么是JDK (Java Development Kit) JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。 所以安装了JDK,就不用在单独安装JRE了。 java的开发工具有:编译工具(javac)、 打包工具(jar)等 JDK=JRE+JAVA的开发工具。 JDK=JVM+核心类库+ Java开发工具(javac, jar..) 5.3 JDK, JRE, JVM的作用和关系 JDK包含JRE，而JRE包含JVM， 总的来说JDK是用于java程序的开发，而jre则是只 5.4 能运行class而没有编译的功能，最后用张网络图片总结下 总结:JDK:主要用于编译JRE:主要作用看运行效果JVM:主要作用跨平台，负责Java程序的调用 6. JDK的下载和安装过程图解6.1 JDK的下载地址 https://www.oracle.com/java/technologies/javase-downloads.html Sun被oracle收购，地址都可以，访问sun会跳转到oracle 6.2 JDK的安装 下载对应操作系统平台的JDK,这里下载1.8的windows平台然后傻瓜式安装，下一步下一步 验证安装是否成功 如果安装 了JDK, JDK的安装路径在C: \\Program Files\\Java\\jdk1.8.0_ 131路径下 在cmd中可以输入java -version来查看jdk的版本 可安装共存:1.7和 1.8 共存 7. JDK的删除和自定义安装路径 删除JDK不能直接把Java的home目录文件夹删除了，这种操作是不正确 正确的删除JDK是要来到 “ 控制面板\\所有控制面板项\\程序和功能”进行删除， JDK安装路径可以自己定义， 个人喜好，我就不喜欢改。 什么时候需要更改jdk的安装路径■当默认的c盘没有空 间的时候，可以改成D盘 8. JDK安装路径下的目录解释 在jdk的Home中，会有如下图的结构 Home 目录路径C: \\Program Fi les\\JavaXjdk1.8.0131,又称jdk主目录 bin:该目录用于存放一些可执行程序，如javac ( java编译器)、java(java运行 工具)，jar(打包工具)和javadoc(文档生成工具)等 db:db目录是一个小型的数据库，从JDK 6. 0开始，Java中引用了一个新的成员JavaDB, 这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4. 0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。 jre: “jre”是Java Runt ime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及-个bin目录，但不包含开发环境中的开发工具。 include: 由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。 1ib: 1ib是1ibrary的缩写， 意为Java 类库或库文件，是开发工具使用的归档包文件。 src. zip文件: src. zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码， 通过该文件可以查看Java基础类的源代码。 9.第一个Java程序， Hel loWord案例的编写与编译(命令行方式) 编写Java源代码，以.java结尾 打开终端cmd,进入到jdk的bin目录，cd “C:\\ Program Files\\Java\\jdk1.8.0_ 131\\bin” 编译java文件，终端中输入javac HelloWorld.java的全路径 执行class文件,终端输入java HelloWorld,不需要加.class后缀Java程序运行流程[记住]①编写java文件②编译java文件，获得一个.class文件③运行.class文件 看到效果 遇到问题 10. Javac&amp;Java命令执行的路径 Javac是一个将. java编译成. class文件命令 javac命令的具体路径是C: \\Program Files\\Java\\jdk1. 8.0_ 131bin 在终端cmd输入java - version, Java的命令执行的路径是在Path的C: \\PrbgramData \\0racl e\\Java\\javapath 如果在命令行执行javac HelloWorld. java 返回‘javac’ 不是内部或外部命令，也不是可运行的程序，或批处理文件。说明在当前路径找不到Javac命令 11. Java环境变量Path配置 目的: 不需要进入到bin目录，也可执行bin目录下的命令javac 方法步骤- windows10的操作: 点击:此电脑-右键属性-高级系统设置-高级-环境变量 在系统变量中新建JAVA_ HOME=C: \\Program Files\\Java\\jdk1.8.0_ 131 在系统变量中编辑Path,在后面追加路径%JAVA_ HOME%\\bin (注:是右斜杠) 在命令行可以输入echo %JAVA HOME%\\bin 来查看环境变量 通过上面的努力， 你就可以在任意目录编译. java文件了MacOs： .bash_profile 12. CLASSPATH变量配置 jvm在 查找class文件时如果没有设置classpath会在当前路径查找，设置classpath后仅在classpath路径下查找class文件即可。 classpath 不是必须配置的 一旦修改了环境变量的东西，一定要重新启动cmd命令行echo %classpath%补: cd.. 切换到上一个路径 4. Java开发工具Eclipse1. 常用的Java IDE开发工具 为什么会有Java IDE开发工具，如果像以前那样在终端通过命令行来编译执行java文件，一旦文件比较多，是件多么折腾的一件事。所以有很多开发工具，来简化我们的开发工作。 集成开发环境(IDE， Integrated Deve lopment Environment )是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。 常见的Java开发工具有，工作中掌握Eclipse即可①Editplus 少②Sublime Text 少③Eclipse (工作中常用，200多M) 免费④MyEclipse(至 少1G)⑤IntelliJ IDEA (500多M) 多 注:掌握了Eclipse, MyEclipse, IDEA也自然会用，因为他们长的两差不多 2. Eclipse历史版本 Neon 3. Eclipse的下载与安装 进入eclipse的 下载页面https://www.eclipse.org/downloads/packages/ 然后在页面中，选择红色框的下载，下载后得到一个eclipse-jee neon-3-win32-x86_ 64.zip文 件 然后解压zip,直接点击解压后文件夹中的eclipse.exe即可使用 -&gt;发送快捷方式注意:下载Eclipse-Neon的版本，一定要安装jdk1.8现在最新版本是eclipse-jee -oxygen-1a-win32 x86_ 64.zip [oxygen:氧气 ]建议项目名格式 wzq_day01_20170206 3. Eclipse的区域与字体调整 调整Eclipse的字体大小 第一种方式: 点击Eclipse的Window Prefernces偏好设置， 找到General-Appearance Colors and Fonts. 再找到Basic 然后点击Text Font来 调字体大小 第二种方式: neon版本的eclipse可以通过[ctrl +、-]来更改文字大小注:有些旧版本不支持这种方式，所以只能使用第一种 4.项目的导入和删除Project Explorer 下 选择 import -&gt;General-&gt;Existing Projects into Workspace 注释 ctrl+shift+/ctrl+/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"DOS命令","slug":"DOS命令","permalink":"http://zhenqk.github.io/tags/DOS%E5%91%BD%E4%BB%A4/"}]},{"title":"Hello World","date":"2016-06-23T21:06:24.000Z","path":"2016/06/24/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]}]