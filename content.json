{"meta":{"title":"程序员Tony","subtitle":"铸就辉煌","description":"","author":"Tony","url":"http://zhenqk.github.io","root":"/"},"pages":[{"title":"about","date":"2020-05-17T09:01:08.000Z","updated":"2020-05-17T09:01:46.903Z","comments":true,"path":"about/index.html","permalink":"http://zhenqk.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-05-17T08:58:27.000Z","updated":"2020-05-17T08:59:26.842Z","comments":true,"path":"categories/index.html","permalink":"http://zhenqk.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"contact","date":"2020-05-17T09:33:35.000Z","updated":"2020-05-17T09:34:40.821Z","comments":true,"path":"contact/index.html","permalink":"http://zhenqk.github.io/contact/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friends","date":"2020-05-17T09:01:27.000Z","updated":"2020-05-17T09:02:01.988Z","comments":true,"path":"friends/index.html","permalink":"http://zhenqk.github.io/friends/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-05-17T09:00:10.000Z","updated":"2020-05-17T09:00:47.248Z","comments":true,"path":"tags/index.html","permalink":"http://zhenqk.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"Ubuntu1810下安装MySQL","slug":"2018-12-02-Ubuntu1810下安装MySQL","date":"2018-12-02T08:33:33.000Z","updated":"2020-05-19T09:13:25.011Z","comments":true,"path":"2018/12/02/2018-12-02-ubuntu1810-xia-an-zhuang-mysql/","link":"","permalink":"http://zhenqk.github.io/2018/12/02/2018-12-02-ubuntu1810-xia-an-zhuang-mysql/","excerpt":"","text":"版本:Ubuntu 18101.切换为root,下载并安装SQL服务器 123456q@q-virtual-machine:~$ su root密码： root@q-virtual-machine:/home/q# wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.debroot@q-virtual-machine:/home/q# dpkg -i mysql-apt-config_0.8.10-1_all.deb root@q-virtual-machine:/home/q# sudo apt updateroot@q-virtual-machine:/home/q# apt-get install mysql-server mysql-client libmysqlclient-dev 查看是否安装成功 1root@q-virtual-machine:/home/q# systemctl status mysql 遇到错误不紧张:重启 2.修改配置设置远程访问及修改密码 12345root@q-virtual-machine:/home/q# mysql mysql&gt; use mysql;select user, plugin from user;mysql&gt; update user set authentication_string=password(\"2557\"),plugin='mysql_native_password' where user='root';mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '456';mysql&gt; flush privileges; 一条语句版: 1mysql&gt;use mysql;select user, plugin from user;update user set authentication_string=password(\"2557\"),plugin='mysql_native_password' where user='root';grant all privileges on *.* to 'root'@'%' identified by '456';flush privileges;commit; 远程登录密码是456本地是2557更改的是本地密码 mysql&gt; set password=password(‘123’);和2557是同等功效 &amp;%只在远端登录(可不做 知识扩充) 12345678910root@q-virtual-machine:/home/q# vi /etc/mysql/mysql.conf.d/mysqld.cnf注释掉 #bind-address = 127.0.0.1root@q-virtual-machine:/etc/mysql/mysql.conf.d# mysql mysql&gt; use mysql mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '456';mysql&gt; flush privileges;commit;q@q-virtual-machine:~$ sudo systemctl restart mysql.service远端可以使用 密码456本地登录依然不需要密码 3.注释掉(要以root权限打开) 1234root@q-virtual-machine:/home/q# cd /etc/mysql/mysql.conf.d/root@q-virtual-machine:/etc/mysql/mysql.conf.d# vi mysqld.cnf注释掉#bind-address = 127.0.0.1 远端登录成功 4.设置utf-8字符集 1234root@q-virtual-machine:/etc/mysql/mysql.conf.d# sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnflc-messages-dir = /usr/share/mysqlcharacter-set-server=utf8 12root@q-virtual-machine:/etc/mysql/mysql.conf.d# gedit /etc/mysql/conf.d/mysql.cnfdefault-character-set=utf8 查看效果 1SHOW VARIABLES LIKE 'char%'; shell脚本 配置ubuntu 3步1.t.shell 1234567891011# 注释 文件复制 用于配置字符集utf-8和远端登录cp t1.cnf /etc/mysql/mysql.conf.d/mysqld.cnfcp t3.cnf /etc/mysql/conf.d/mysql.cnf# 设置本地密码2557 开启远端密码456 刷新权限mysql \"mysql\" -e\"update user set authentication_string=password('2557'),plugin='mysql_native_password' where user='root';grant all privileges on *.* to 'root'@'%' identified by '456';flush privileges;commit;\"echo \"everything is ok\"# 重启服务systemctl restart mysql.servicesystemctl enable mysql.service# 查看字符集utf-8mysql -uroot -p2557 -e\"SHOW VARIABLES LIKE 'char%';\" 2.t1.cnf 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106## The MySQL database server configuration file.## You can copy this to one of:# - \"/etc/mysql/my.cnf\" to set global options,# - \"~/.my.cnf\" to set user-specific options.# # One can use all long options that the program supports.# Run program with --help to get a list of available options and with# --print-defaults to see which it would actually understand and use.## For explanations see# http://dev.mysql.com/doc/mysql/en/server-system-variables.html# This will be passed to all mysql clients# It has been reported that passwords should be enclosed with ticks/quotes# escpecially if they contain \"#\" chars...# Remember to edit /etc/mysql/debian.cnf when changing the socket location.# Here is entries for some specific programs# The following values assume you have at least 32M ram[mysqld_safe]socket = /var/run/mysqld/mysqld.socknice = 0[mysqld]## * Basic Settings#user = mysqlpid-file = /var/run/mysqld/mysqld.pidsocket = /var/run/mysqld/mysqld.sockport = 3306basedir = /usrdatadir = /var/lib/mysqltmpdir = /tmplc-messages-dir = /usr/share/mysqlcharacter-set-server=utf8skip-external-locking## Instead of skip-networking the default is now to listen only on# localhost which is more compatible and is not less secure.# bind-address = 127.0.0.1## * Fine Tuning#key_buffer_size = 16Mmax_allowed_packet = 16Mthread_stack = 192Kthread_cache_size = 8# This replaces the startup script and checks MyISAM tables if needed# the first time they are touchedmyisam-recover-options = BACKUP#max_connections = 100#table_open_cache = 64#thread_concurrency = 10## * Query Cache Configuration#query_cache_limit = 1Mquery_cache_size = 16M## * Logging and Replication## Both location gets rotated by the cronjob.# Be aware that this log type is a performance killer.# As of 5.1 you can enable the log at runtime!#general_log_file = /var/log/mysql/mysql.log#general_log = 1## Error log - should be very few entries.#log_error = /var/log/mysql/error.log## Here you can see queries with especially long duration#slow_query_log = 1#slow_query_log_file = /var/log/mysql/mysql-slow.log#long_query_time = 2#log-queries-not-using-indexes## The following can be used as easy to replay backup logs or for replication.# note: if you are setting up a replication slave, see README.Debian about# other settings you may need to change.#server-id = 1#log_bin = /var/log/mysql/mysql-bin.logexpire_logs_days = 10max_binlog_size = 100M#binlog_do_db = include_database_name#binlog_ignore_db = include_database_name## * InnoDB## InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.# Read the manual for more InnoDB related options. There are many!## * Security Features## Read the manual, too, if you want chroot!# chroot = /var/lib/mysql/## For generating SSL certificates I recommend the OpenSSL GUI \"tinyca\".## ssl-ca=/etc/mysql/cacert.pem# ssl-cert=/etc/mysql/server-cert.pem# ssl-key=/etc/mysql/server-key.pem 3.t3.cnf 12[mysql]default-character-set=utf8 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"安装","slug":"安装","permalink":"http://zhenqk.github.io/categories/%E5%AE%89%E8%A3%85/"},{"name":"Linux","slug":"安装/Linux","permalink":"http://zhenqk.github.io/categories/%E5%AE%89%E8%A3%85/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhenqk.github.io/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhenqk.github.io/tags/MySQL/"}]},{"title":"CentOS 7(18.10)搭建个人网盘和博客","slug":"2018-12-01-CentOS-7-18-10搭建私人网盘和博客","date":"2018-12-01T02:01:01.000Z","updated":"2020-05-19T09:13:46.890Z","comments":true,"path":"2018/12/01/2018-12-01-centos-7-18-10-da-jian-si-ren-wang-pan-he-bo-ke/","link":"","permalink":"http://zhenqk.github.io/2018/12/01/2018-12-01-centos-7-18-10-da-jian-si-ren-wang-pan-he-bo-ke/","excerpt":"","text":"1. java环境 jdk-8u231-linux-x64.tar.gz 由于原先有jdk7版本,故移除更换先上传文件-&gt; 修改环境变量-&gt;解压至此文件下/usr/local/src/java/ 文件名为解压名 jdk1.8.0_231（和下面配置环境变量java_HOME路径一致） 2. 环境变量配置123456[root@NEU java]# vi /etc/profile #set java environment JAVA_HOME=/usr/local/src/java/jdk1.8.0_231 CLASSPATH=.:$JAVA_HOME/lib.tools.jar PATH=$JAVA_HOME/bin:$PATH export JAVA_HOME CLASSPATH PATH 3.使环境变量生效12[root@NEU java]# source /etc/profile[root@NEU java]# java -version 搭建私有网盘解压文件tank-3.0.6.linux-amd64.tar.gz 到/root/blueBall 下执行12[root@NEU blueBall]# cd tank-3.0.6/[root@NEU tank-3.0.6]# ./tank 若执行遇到权限不足，请解压！！！！12[root@NEU ~]# cd blueBall/[root@NEU blueBall]# tar -zxvf tank-3.0.6.linux-amd64.tar.gz 修改默认端口 搭建博客修改端口,数据库,用户名和登录密码 startup.sh1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/bin/bash# executable pathDIR=\"$( cd \"$( dirname \"$0\" )\" &amp;&amp; pwd )\"JAR_PATH=$DIR/blog-1.1.0.jar#configsServerPort=80#mysql configsMysqlPort=3306MysqlHost=192.168.20.20MysqlSchema=blogMysqlUsername=rootMysqlPassword=123MysqlUrl=\"jdbc:mysql://$MysqlHost:$MysqlPort/$MysqlSchema?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false\"#tank configsTankUrl=\"https://tank.eyeblue.cn\"TankEmail=zhenqk@163.comTankPassword=123456#admin configsAdminUsername=TonyAdminNickname=TonyAdminEmail=zhenqk@163.comAdminPassword=123456#email configsMailProtocol=smtpsMailHost=smtp.126.comMailPort=465MailUsername=zhenqk@126.comMailPassword=a4877188MailDefaultEncoding=UTF-8OPTS=\"-Xmx512m -Dserver.port=$ServerPort -Dspring.datasource.url=$MysqlUrl -Dspring.datasource.username=$MysqlUsername -Dspring.datasource.password=$MysqlPassword -Dtank.url=$TankUrl -Dtank.email=$TankEmail -Dtank.password=$TankPassword -Dadmin.username=$AdminUsername -Dadmin.nickname=$AdminNickname -Dadmin.email=$AdminEmail -Dadmin.password=$AdminPassword -Dspring.mail.protocol=$MailProtocol -Dspring.mail.host=$MailHost -Dspring.mail.port=$MailPort -Dspring.mail.username=$MailUsername -Dspring.mail.password=$MailPassword -Dspring.mail.default-encoding=$MailDefaultEncoding\"echo $OPTSJAVA='java'if [ -z `which java` ]; then if [ -z $JAVA_HOME ]; then JAVA=$JAVA_HOME/bin/java else echo 'Cannot find java command and JAVA_HOME.' fifiif [ ! -z `java -version 2&gt;&amp;1 | grep 'java version' | awk '{print $3}' | egrep '1.[8-9].\\d*'` ]; then nohup $JAVA $OPTS -jar $JAR_PATH &gt;/dev/null 2&gt;&amp;1 &amp; echo $JAR_PATH echo 'Started successfully.'else echo 'Java version not support, must be 1.8 or 1.8+.'fi 启动12[root@NEU blueBall]# cd blog-1.1.0/[root@NEU blog-1.1.0]# sh startup.sh 开机软件启动(根目录)12sh /root/blueBall/blog-1.1.0/startup.sh/root/blueBall/tank-3.0.6/tank document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhenqk.github.io/categories/Linux/"}],"tags":[{"name":"blueBall","slug":"blueBall","permalink":"http://zhenqk.github.io/tags/blueBall/"},{"name":"Linux下JDK的安装","slug":"Linux下JDK的安装","permalink":"http://zhenqk.github.io/tags/Linux%E4%B8%8BJDK%E7%9A%84%E5%AE%89%E8%A3%85/"}]},{"title":"面向对象(中)补2","slug":"2016-06-28-面向对象-中-补2","date":"2016-06-28T07:02:45.000Z","updated":"2020-05-19T11:09:45.473Z","comments":true,"path":"2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/","link":"","permalink":"http://zhenqk.github.io/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/","excerpt":"","text":"1.每日一问1.什么是多态性?什么是虚拟方法调用?对象的多态性:父类的引用指向子类的对象。Person p = new Man();p.eat();调用方法时，编译时看左边，运行时看右边。先会写代码，后面慢慢来 2.一个类可以有几个直接父类?(一个 )一个父类可有多少个子类?子类能获取直接父类的父类中的结构吗?(可以)子类能否获取父类中private 权限的属性或方法?。(可以 getset 方法) 封装解决的能不能调的问题，继承性是能不能获取的问题Ais B 是不是true 可继承 3.方法的重写(override/overwrite)的具体规则有哪些。(非static方法)方法名，形参列表相同。权限修饰符。返回值w抛出的异常 4.super调用构造器，有哪些具体的注意点this(形参列表):本类重载的其它的构造器。super(形参列表):调用父类中指定的构造器。n n-11 5.在下面的代码结构中:使用关键字: this,super;方法的重 写;继承; 2.重写与superdebug 调试 重载1.什么是方法的重写(override或overwrite)? (父类的方法不适合子类)子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。2.应用: 重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。 3.举例:cylinder 4.重写的规则:方法的声明:权限修饰符 返回值类型 方法名 (形参列表) throws 异常的类型{//方法体约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法②子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同2子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符事 特殊情况:子类不能重写父类中声明为private权限的方法③返回值类型:父类被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类父类被重写的方法的返回值类型是基本数据类型(比如: double)， 则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)日子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型(具体放到异常处理时候讲)子类和父类中的同名同参数的方法要么都声明为非static的(考虑重写，要么都声明为static的(不是重写). 5.面试题:区分方法的重写和重载?重载 ，可以在同一个类中可以使用相同方法名和形参列表不同相同相同方法，彼此之间构成重载，构造器可以重载动态绑定 答:①二者的概念:②重载和重写的具体规则③重载:不表现为多 态性。重写:表现为多态性。重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它石的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同參数的方法。所以:对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为早绑定或静态绑定”;而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定或动态绑定”。引用一句Bruce Eckel的话:“不要犯傻，如果它不是晚绑定，它就不是多态。” super1.super关键字可以理解为: 父类的2.可以用来调用的结构:属性、方法、构造器 3.super调用属性、方法:3.1我们可以在子类的方法或构造器中。通过使用”super展性”或“super .方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”superA”3.2特殊情况:当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。3.3特殊情况:当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。 4.super调用构造器: 4.1我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器4.2 “super(形参 列表)”的使用，必须声明在子类构造器的首行!4.3我们在类的构造器中，针对于”this(形参列表)”或” super(形参列表)”只能二一，不能同时出现4.4在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的in构造器: super()4.5在类的多个构造器中，至少-一个类的构造器中使用了”super(形参列表)”， 调用父类中的构造器 渐渐领悟 3.子类对象实例化过程及多态性1.从结果上看:继承性 子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所父类中声明的属性。 2.从过程上看:当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，… 直到调用了java. lang . object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。 3.强调说明为什么super(… )或this(..)调用语句只能作为构造器中的第- - -句出现? 无论通过哪个构造器创建子类对象，需要保证先初始化父类。目的:当子类继承父类后，“继承”父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化。 多调性的理解1.多态性的理解:可以理解为一个事物的多种形态。 2.何为多态性:对象的多态性:父类的引用指向子类的对象(或子类的对象赋给父类的引用)举例:Person p = new Man();objlect obj = new Date();3.多态性的使用: 虚拟方法调用有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。总结:编译，看左边;运行，看右边。4.多态性的使用前提:①类的继承关系②方法的重写5.多态性的应用举例:猫狗6.多态性使用的注意点:对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边 4. 向下转型的使用/ /不能调用子类所特有的方法、属性:编译时，p2是Person类型。p2. earnMoney();//有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致/ /编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。 / /如何才能调用子类特有的属性和方法?/ /向下转型:使用强制类型转换符。Man m1 = (Man)p2;m1. earnMoney(); |m1. isSmoking = true; 有可能转不成功Woman w1=(Woman)p2;w1. goShopping();p2是男的 你把他误以为女的 / /使用强转时，可能出现ClassCast Exception的异常。Woman W1 = (Woman)p2;w1. goShopping(); 5.instanceof 关键字的使用instanceof关键字的使用 a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false 使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先 进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。 如果 a instanceof A返回true,则 a instanceof B也返回true. 父类放着也对其中，类B是类A的父类。 Person p2=new Man(); 6.向下转型的几个常用问题//练习:, /问题一:编译时通过，运行时不通过//举例一:Person p3 = new Woman( ) ;Man m3 = (Man)p3;/ /举例二:Person p4 = new Person( ) ;Man m4= (Man)p4;/ /问题二:编译通过，运行时也通过object obj = new Woman( );Person p = (Person)obj;/ /问题三:编译不通过Man m5 = new Woman();String str = new Date();开发中向下转型用的比较少 7.多态练习—调用属性和方法引用类型是地址值 开发中不要定义同名的 1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。编译看左边 运行看右边2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量，编译运行都看左边 8-9.基本操作–多态性各种图形的面积 可以利用多态来实现 求面积 重写父类中的面积公式 sub-1 认为是重写 sub_1 确定的优先调用 11 object 类的使用5.7 object 类的使用 Object类是所有Java类的根父类 Order order = new Order( ) ;System. out . println(order .getClass() . getSuperclass()); 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类public class Person {}等价于:public class Person extends Object {} 例: method(Object obj){.. } /可以接收任何类作为其参数Person o=new Person();method(0); java.lang.Object类 1.Object类是所有Java类的根父类 2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 3.Object类中的功能(属性、方法)就具有通用性。 属性：无 方法：equals() / toString() / getClass() /hashCode() / clone() / finalize() wait() 、 notify()、notifyAll() Object类只声明了一个空参的构造器 clone 复制对象 finalize() 垃圾回收期 面试题： final、finally、finalize的区别？ 关键字前面2个 finalize 方法名 12. ==运算符的回顾面试题:==和equals()的区别一、回顾 == 的使用： == ：运算符 可以使用在基本数据类型变量和引用数据类型变量中 10=10.0 char c=10 10=10 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 自动类型提升如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 1补充： == 符号使用时，必须保证符号左右两边的变量类型一致。 二、equals()方法的使用： 是一个方法，而非运算符 只能适用于引用数据类型 Object类中equals()的定义：public boolean equals(Object obj) {return (this == obj); }说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同. —-ppt ==: 基本类型比较值:只要两个变量的值相等，即为true。int a=5; if(a==6)..} 引用类型比较引用(是否指向同一个对象):只有指向同一个对象时，==才返回true。Person p1 =new Person();Person p2=new Person();if (p1==p2)…} 用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错 equals();所有类都继承了Object,也就获得了equals()方法。还可以重写。➢只能比较引用类型，其作用与“卜=”相同,比较是否指向同一个对象。➢格式:obj1.equals(obj2) 特例:当用equals()方法进行比较时，对类File、String、 Date 及包装类.(Wrapper Class)来说，是比较类型及内容而不考虑引用的是否是同一个对象;➢原因:在这些类中重写了Object类的equals()方法。 当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等 重写equals()方法的原则. 对称性:如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是“true” 自反性: x.equals(x)必须返回是“true 传递性:如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”那么z.equals(x)也应该返回是“true”。 一 致性:如果x.equals(y)返回是“true” ，只要x和y内容一直不变， 不管你重复x.equals(y)多少次，返回都是“true” 。 任何情况下，x.equal(null)， 永远返回是“falsex.equals(和x不同类型的对象)永远返回是“false” 从我面试的反馈，85%的求职者“理直气壮”的回答错误…1.==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址2.equals的话， 它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。3.具体要看自定义类里有没有重写Object的equals方法来判断。4通常情况下，重写equals方法， 会比较类中的相应属性是否都相等。 13.equals()的使用 14.重写equals() 方法找例子 String 重写equals 源代码 字符串等引用类型 equals() 方法2 自动生成 General 代码自动生成逻辑性更强 15. 总结==与equals()16.equals 方法的练习对象之间不能用 == 因为new的会改变地址 ，==比较的是地址 自定义的类也要重写equals ，当在子类中需要的时候 17.toString()的使用 Object类中toString()的使用： 1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString() 2.Object类中toString()的定义： public String toString() { return getClass().getName() + “@” + Integer.toHexString(hashCode()); } 3.像String、Date、File、包装类等都重写了Object类中的toString()方法。 使得在调用对象的toString()时，返回”实体内容”信息 4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容” 自定义 手动 系统生成 19 objetc类的练习if(obj instanceof Circcle){ Circle c=(Circle)obj; return this.radius==c.radius; } 20.单元测试方法的使用新建类 JUnitTest.java 选中当前工程-&gt;右键build Path-&gt;add libraries-&gt;JUnit-&gt;finish Java中的JUnit单元测试 步骤： 1.选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步 2.创建Java类，进行单元测试。 此时的Java类要求：① 此类是public的 ②此类提供公共的无参的构造器 3.此类中声明单元测试方法。 此时的单元测试方法：方法的权限是public,没有返回值，没有形参 4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test; 5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。 6.写完代码以后，左键双击单元测试方法名，右键：run as -&gt; JUnit Test 说明： 1.如果执行结果没有任何异常：绿条 2.如果执行结果出现异常：红条 把测试方法当成静态的了 真正开发 @test 导包就可以 21.包装类的理解5.8 包装类的使用 针对八种基本数据类型定义相应的引用类型一包装类(封装类) 有了类的特点，就可以调用类中的方法，Java才是真正的面向对象 基本数据类型包装成包装类的实例__装箱 通过包装类的构造器实现:int i= 500; Integer t = new Integer(); 还可以通过字符串参数构造包装类对象:Float f= new Float(“4. 56”);Long I = new Long(“asdf” ); //NumberFormatException 获得包装类对象中包装的基本类型变量–拆箱-调用包装类的.xxxValue()方法:boolean b = bObj .booleanValue(); JDK1.5之后，支持自动裝箱，自动拆箱。但类型必须匹配。 字符串转换成基本数据类型 通过包装类的构造器实现:int i = new Integer(“12”); 通过包装类的parseXxx(String s)静态方法:Float f= Float.parseFloat(“12.1”); 基本数据类型转换成字符串 调用字符串重载的valueOf()方法: .String fstr = String.valueOf(2.34f); 更直接的方式:String intStr= 5 +“” 22.基本数据类型转化为包装类包装类的使用 1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征 2.掌握的：基本数据类型、包装类、String三者之间的相互转换 //基本数据类型 —&gt;包装类：调用包装类的构造器 boolean isMale; Boolean isFemale; 是个类 23.包装类转化基本数据类型​ //包装类—&gt;基本数据类型:调用包装类Xxx的xxxValue() 123456789101112@Test public void test2(){ Integer in1 = new Integer(12); int i1 = in1.intValue(); System.out.println(i1 + 1); Float f1 = new Float(12.3); float f2 = f1.floatValue(); System.out.println(f2 + 1); } 24.自动装箱和拆箱12345678910111213141516171819202122232425 // JDK 5.0 新特性：自动装箱 与自动拆箱 / @Test public void test3(){// int num1 = 10;// //基本数据类型--&gt;包装类的对象// method(num1);//上面独立 //自动装箱：基本数据类型 ---&gt;包装类 int num2 = 10; Integer in1 = num2;//自动装箱 boolean b1 = true; Boolean b2 = b1;//自动装箱 //自动拆箱：包装类---&gt;基本数据类型 System.out.println(in1.toString()); int num3 = in1;//自动拆箱 } public void method(Object obj){ System.out.println(obj); } 25.基本数据类型、包装类与String间的相互转化//基本数据类型、包装类—&gt;String类型：调用String重载的valueOf(Xxx xxx) @Test ​ 1234567891011121314public void test4(){ int num1 = 10; //方式1：连接运算 String str1 = num1 + \"\"; //方式2：调用String的valueOf(Xxx xxx) float f1 = 12.3f; String str2 = String.valueOf(f1);//\"12.3\" Double d1 = new Double(12.4); String str3 = String.valueOf(d1); System.out.println(str2); System.out.println(str3);//\"12.4\" } // //String类型 —&gt;基本数据类型、包装类：调用包装类的parseXxx(String s) 1234567891011121314@Test public void test5(){ String str1 = \"123\"; //错误的情况：// int num1 = (int)str1;// Integer in1 = (Integer)str1; //可能会报NumberFormatException int num2 = Integer.parseInt(str1); System.out.println(num2 + 1); String str2 = \"true1\"; 不是标准的true 都是false boolean b1 = Boolean.parseBoolean(str2); System.out.println(b1); } 26.包装类常见面试题 第一题 1.0 由于类型提升，要求统一类型 第二题: 1 没有要求统一类型 false 地址 true false 有个缓存数组 1-127 new 的 27 包装类的练习 想放多少放多少 先写思路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.atguigu.exer4;import java.util.Scanner;import java.util.Vector; 练习/* * 利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级。 提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。 而向量类java.util.Vector可以根据需要动态伸缩。 创建Vector对象：Vector v=new Vector(); 给向量添加元素：v.addElement(Object obj); //obj必须是对象 取出向量中的元素：Object obj=v.elementAt(0); 注意第一个元素的下标是0，返回值是Object类型的。 计算向量的长度：v.size(); 若与最高分相差10分内：A等；20分内：B等； 30分内：C等；其它：D等 * * * * */public class ScoreTest { public static void main(String[] args) { //1.实例化Scanner，用于从键盘获取学生成绩 Scanner scan = new Scanner(System.in); //2.创建Vector对象：Vector v=new Vector();相当于原来的数组 Vector v = new Vector(); //3.通过for(;;)或while(true)方式，给Vector中添加数组 int maxScore = 0; for(;;){ System.out.println(\"请输入学生成绩（以负数代表输入结束）\"); int score = scan.nextInt(); //3.2 当输入是负数时，跳出循环 if(score &lt; 0){ break; } if(score &gt; 100){ System.out.println(\"输入的数据非法，请重新输入\"); continue; } //3.1 添加操作：：v.addElement(Object obj) //jdk5.0之前：// Integer inScore = new Integer(score);// v.addElement(inScore);//多态 //jdk5.0之后： v.addElement(score);//自动装箱 //4.获取学生成绩的最大值 if(maxScore &lt; score){ maxScore = score; } } //5.遍历Vector，得到每个学生的成绩，并与最大成绩比较，得到每个学生的等级。 char level; for(int i = 0;i &lt; v.size();i++){ Object obj = v.elementAt(i); //jdk 5.0之前：// Integer inScore = (Integer)obj;// int score = inScore.intValue(); //jdk 5.0之后： int score = (int)obj; if(maxScore - score &lt;= 10){ level = 'A'; }else if(maxScore - score &lt;= 20){ level = 'B'; }else if(maxScore - score &lt;= 30){ level = 'C'; }else{ level = 'D'; } System.out.println(\"student-\" + i + \" score is \" + score + \",level is \" + level); } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(中)补1","slug":"2016-06-28-面向对象-中-补1","date":"2016-06-28T03:55:22.000Z","updated":"2020-05-19T11:09:34.410Z","comments":true,"path":"2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/","link":"","permalink":"http://zhenqk.github.io/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/","excerpt":"","text":"1. 每日一考Arraylist 替换数组 可扩展长度— 2.复习项目要求1.看着一边写 一边理解，2.自己去写 试着自己去完成，写不动看文档修饰 看源码 试着独立完成全屏看，看完这个类以后 ，收起来，自己去写，写的时候写不动 看文档提示，再去写，在写不动， 看源码 ，指导咋写 在手些 手写来，在接着写3. 至少独立完成一遍以 上的项目代码 积累完成项目的过程中常见的bug的调试方式一‘“硬”看，必要时，添加输出语句。方式二：Debug 逻辑 业务 捋顺思路,强化逻辑 对象、数组等内存结构的解析 遵守编码的规范,标识符的命名规范等 在类前，方法前，方法内具体逻辑的实现步骤等添加必要的注释.文档注释逻辑步骤： 单行和多行注释 3.继承性 为什么要有类的继承性? (继承性的好处)①减少了代码的冗余，提高代码复用性②便于功能的扩展③为之后多态性的使用，提供了前提图示: 继承性的格式: class A extends B{ }A:子类、派生类、subclass .B:父类、超类、基类、superclass 子类继承父类以后有哪些不同? 3.1体现: 一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。*特别的， 父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。3.2子类继承父类以后，还可以声明自己特有的属性或方法:实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。extends:延展、扩展 Java中继承性的说明 1.一个类可以被多个子类继承。2.Java中类的单继承性:一个类只能有一个父类3.子父类是相对的概念。4.子类直接继承的父类，称为:直接父类。间接继承的父类称为:间接父类5.子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法 图示: java. lang . object类的理解1.如果我们没显式的声明一个类的父类的话，则此类继承于java.1ang . object类2.所的java类(除java.1ang. object类之外都直接或间接的继承于java. lang. object类3.意味着，所的java类具有java. lang. object类声明的功能。 4-5. 继承性的练习，基本操作（练习）紫色的箭头表示继承 6-7Eclipse Debug的使用 System.out.println(). 适合小项目 Eclipse - Debug调试 1.设置断点 关卡 2.debug as–》 java application 3.操 做 –》进入透视图 f6 一行代i码 一行代码走—&gt;执行 f5 函数方法里面 到方法实现哪一行用F7 跳出方法resume 到下一个断点进入tdrop into 方法的初始部分 8.解决Debug中step into功能失灵问题配置debug Configuration 9.方法重写的理解override/overwrite 定义：在子类中可以根据需要对从父继承来的方法进行改造， 在程序执行时，子类的方法将覆盖父。 在程序执行时，子类的方法将覆盖父。 要求: 子类重写的方法 必须 和父类被重写的方法 具有相同的 方法名称、 参数 列表 子类重写的方法返回值型 不能大于 父类被重写的方法返回值型 子类重写的方法使用访问权限 不能小于 父类被重写的方法访问权限子类不能重写父中声明为 private 权限的方法 子类方法抛出的异常不能大于父被重写方法的异常 注意子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为static的(不是重写)。因为static方法是属于类的，子类无法覆盖父类的方法。 1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。10. 方法重写的细节3.重写的规定：方法的声明： 权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型{ //方法体 } 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 —-摊煎饼 特殊情况：子类不能重写父类中声明为private权限的方法权限修饰 除了 private 都是重写③ 返回值类型： &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类 父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写） 静态方法不能被重写，随着类的加载而加载— 开发中直接粘贴就可以了—重写wal+ alt+/ 11 f方法重写的练习12. 测试4种不同的权限修饰/ /同一个包中的其他类，不可以调用Order类中私有的属性、方法order.orderPrivate = 4;order . methodPrivate( ) ; //在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法orderDefault = 3;orderPrivate = 4; //不同包下的普通类(非子类)要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法order. orderPrivate = 2;order. orderDefault = 3;order. orderProtected = 4; 对于class的权限修饰只可以用public利和Idefault(缺省)。public类可以在任意地方被访问。default类只可以被同一个包内部的类访问。用的最多是public private 13.super调用属性和方法关键字super用父类被重写的属性和方法 1.super理解为：父类的 2.super可以用来调用：属性、方法、构造器 3.super的使用：调用属性和方法3.1 我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用 父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.” –子类没有3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的 使用”super.属性”的方式，表明调用的是父类中声明的属性。 往上找3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的 使用”super.方法”的方式，表明调用的是父类中被重写的方法。4.super调用构造器 4.1 我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器 4.2 “super(形参列表)”的使用，必须声明在子类构造器的首行！ 4.3 我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现 4.4 在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super() 4.5 在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器 输出结果是一样的由于子类中没有age ，只有父类有System. out . println(“name = “ + this.name + “，age = “ + super.age); 14. super调用构造器 15.子类对象实例化的全过程5.5子类对象实例化的过程 为什么能用？ 从结果上来看：（继承性）子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。 从过程上来看： 123 当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，... 直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。 子类 间接或直接调用父类构造器 16 继承和super练习银行 17.多态性的使用 多态性，是面向对象中最重要的概念 ，在Java 中的体现:对象 的多态性：父类的引用指向子对象 可以 直接应用在抽象类和接口上 Java引用变量有两个类型:编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简称: 编译时，看左边;运行时，看右边。 若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphi sm) 多态情况下，“看左边”:看的是父类的引用(父类中不具备子类特有的方法)“看右边”:看的是子类的对象(实际运行的是子类重写父类的方法) 对象的多态一 - —-在Java中,子类的对象可以替代父类的对象使用 一个变量只能有一种确定的数据类型 一个引用类型变量可能指向(引用)侈种不同类型的对象Person p = new Student();Object 0 = new Person();//Object类型的变量o，指向Person类型的对象o = new Student(); //Object类型的变量o，指向Student类型的对象 子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象:向上转型(upcasting)。 一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法:Student m = new Student();m.school =“pku”; //合法,Student类有school成员变量Person e = new Student();e.school =“pku”; //非法,Person类没 有school成员变量属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。 1.理解多态性：可以理解为一个事物的多种形态。2.何为多态性： 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用） 多态的使用：虚拟方法调用有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。总结：编译，看左边；运行，看右边。 4.多态性的使用前提： ① 类的继承关系 ② 方法的重写 5.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） 多态性的使用 秘书给我找个人，他能吃东西，结果她找的是男人， p2.earnMony(); 不能使用 ，父类没有什么这个方法 编译生成什么类型就能点出什么类型，p2只调用person里面有的方法 执行的时候是子类重写的 p2.eat() 点到父类了 p2 是个person 18.多态性的使用举例 有了多态性 没有多态性 会造成很多重载的方法 equals （子类类型） 举例 Driver 先建立连接 三种数据库的连接 19.多态性不适合于属性20 虚拟方法调用的再理解虚拟方法调用(Virtual Method Invocation) 正常的方法调用Person e = new Person();e.getInfo();Student e = new Student();e.getlInfo(); 虚拟方法调用(多态情况下)子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。Person e = new Student();e.getInfo();调 用Student类的getInfo()方法 编译时类型和运行时类型编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类的getlnfo()方法。一-动态绑定 面试题:多态是编译时行为还是运行时行为 若随机呢? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.atguigu.java5;import java.util.Random;//面试题：多态是编译时行为还是运行时行为？//证明如下：class Animal { protected void eat() { System.out.println(\"animal eat food\"); }}class Cat extends Animal { protected void eat() { System.out.println(\"cat eat fish\"); }}class Dog extends Animal { public void eat() { System.out.println(\"Dog eat bone\"); }}class Sheep extends Animal { public void eat() { System.out.println(\"Sheep eat grass\"); } }public class InterviewTest { public static Animal getInstance(int key) { switch (key) { case 0: return new Cat (); case 1: return new Dog (); default: return new Sheep (); } } public static void main(String[] args) { int key = new Random().nextInt(3); System.out.println(key); Animal animal = getInstance(key); animal.eat(); }} 多态小结 多态作用:提高了代码的通用性，常称作接口重用 前提:需要存在继承或者实现关系有方法的重写 成员方法:编译时:要查看引用变量所声明的类中是否有所调用的方法。运行时:调用实际new的对象所属的类中的重写方法。 成员变量:不具备多态性，只看引用变量所声明的类。 代码 123456789101112131415161718192021222324252627282930class animal{ public void eat() { System.out.println(\"吃饭\"); }}class dog extends animal{ @Override //4.吃骨头 public void eat() { System.out.println(\"吃骨头\"); }}class cat extends animal{ public void eat() { System.out.println(\"吃老鼠\"); }}public class duotai { //3.调用子类的相应方法 ,如传入new dog()public void func(animal d) { d.eat();} public static void main(String[] args) { //1.类的实体化 duotai dt=new duotai(); //2.调dt里面的方法，传入子类 new 对象，调谁用谁 dt.func(new dog()); dt.func(new cat()); }} 可以实现不同子类间的相同方法图解 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(中)","slug":"2016-06-28-面向对象-中","date":"2016-06-28T01:17:34.000Z","updated":"2020-05-19T10:53:22.475Z","comments":true,"path":"2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/","link":"","permalink":"http://zhenqk.github.io/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/","excerpt":"","text":"1. 每日一考1.构造器的作用是什么?使用中有哪些注意点(&gt;=3条)①创建对象②初始化对象结构 2.关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，默认初始化显式初始化构造器中初始化-对象方法或对象属性给属性赋值+ 3. this 关键字可以用来调用哪些结构，简单说明一下其使用。this:属性、方法、构造器。this:理解为当前对象，当前正在创建的对象。 4. Java中目前学习涉及到的四种权限修饰符都有什么?并说明各自的权限范围。public protect 缺省 private 5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。2.复习:封装性和构造器封装性 为什么要引入封装性?我们程序设计追求“高内聚，低耦合” 高内聚:类的内部数据操作细节自己完成，不允许外部干涉; 低耦合:仅对外暴露少量的方法用于使用。 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。 问题引入:当我们创建一一个类的对 象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。 (比如: setLegs()同时， 我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).–&gt;此时，针对于属性就体现了封装性。| 封装性思想具体的代码体现:体现一-:体现一:将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值体现二:不对外暴露的私有的方法体现三:单例模式(将构造器私有化)体现四:如果不希望类在包外被调用，可以将类设置为缺省的。 Java规定的四种权限修饰符4.1权限从小到大顺序为:4.2具体的修饰范围: 构造器 构造器(或构造方法) : Constructor构造器的作用:1.创建对象 2.初始化对象的信息 使用说明:1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器2.定义构造器的格式:权限修饰符类名(形参 列表){}]|3.一个类中定义的多个构造器，彼此构成重载4.-旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器5.一个类中，至少会有一个构造器。 3.举例: 属性赋值顺序默认初始化 赋值初始化 显性赋值初始化 |||| 构造器赋值 对象.方法 JAVABean所谓JavaBean，是指符合如下标准的Java类: 类是公共的 一个无参的公共的构造器 属性，且对应的get、set方法 3.复习 关键字 this package importthis1.可以调用的结构:属性、方法:构造器 this调用属性、方法:this理解为:前对象或当前正在创建的对象 this调用构造器: ①我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器②构造器中不能通过”this(形参列表)”方式调用自己③如果一个类中有n个构造器，则最多有n - 1构造器中使用了”this(形参列表)”④规定: “this(形参列表)”必须声明在当前构造器的首行⑤构造器内部，最多只能声明一一个”this(形参列表)”， 用来调用其他的构造器 package的使用1使用说明:*1.为了更好的实现项目中类的管理，提供包的概念.*2.使用package声 明类或接口所属的包，声明在源文件的首行*3.包，属于标识符，遵循标识符的命名规则、规范(xxyyyzzz)、 “见名知意”*4.每”.”一次，就代表一层文件目录。1.2 举例:航运系统MVC1.3JDK中的主要包介绍:. java都是写网页 写客户端很少用 import 关键紫的使用import:导入 1.在源文件中显式的使用import结构导入指定包下的类、接口 2.声明在包的声明和类的声明之间3.如果需要导入多个结构，则并列写出即可 4.可以使用”xxx. *”的方式，表示可以导入xxx包下的所结构5.如果使用的类或接口是java.lang包下定义的，则可以省略import结构 6.如果使用的类或接口是本包下定义的，则可以省略import结构 7.如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。 8.使用”xxx.*”方式表明可以调用Xxxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 import static:导入指定类或接口中的静态结构:属性或方法。 4-6 Eclispe 常用快捷键Eclipse中的快捷键： 1.补全代码的声明：alt + / abcdefg-z* 2.快速修复: ctrl + 1 3.批量导包：ctrl + shift + o 4.使用单行注释：ctrl + / 5.使用多行注释： ctrl + shift + / 6.取消多行注释：ctrl + shift + 修改快捷键 Prefer –keys 7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up 8.删除指定行的代码：ctrl + d 9.上下移动代码：alt + up 或 alt + down 10.切换到下一行代码空位：shift + enter 11.切换到上一行代码空位：ctrl + shift + enter 12.如何查看源码：ctrl + 选中指定的结构 或 ctrl + shift + t 13.退回到前一个编辑的页面：alt + left 14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right 15.光标选中指定的类，查看继承树结构：ctrl + t —– 16.复制代码： ctrl + c 17.撤销： ctrl + z 18.反撤销： ctrl + y 19.剪切：ctrl + x 20.粘贴：ctrl + v 21.保存： ctrl + s 22.全选：ctrl + a 23.格式化代码： ctrl + shift + f 24.选中数行，整体往后移动：tab 25.选中数行，整体往前移动：shift + tab 26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o 27.批量修改指定的变量名、方法名、类名等：alt + shift + r 28.选中的结构的大小写的切换：变成大写： ctrl + shift + x 29.选中的结构的大小写的切换：变成小写：ctrl + shift + y 30.调出生成getter/setter/构造器等结构： alt + shift + s 31.显示当前选择资源(工程 or 文件)的属性：alt + enter 32.快速查找：参照选中的Word快速定位到下一个 ：ctrl + k 用的少 33.关闭当前窗口：ctrl + w 34.关闭所有的窗口：ctrl + shift + w 35.查看指定的结构使用过的地方：ctrl + alt + g 36.查找与替换：ctrl + f 37.最大化当前的View：ctrl + m 38.直接定位到当前行的首位：home 39.直接定位到当前行的末位：end 7. bank 练习的难点 Accout 关联关系类型数组链式结构 123456789101112131415161718192021222324252627282930private Customer[] customers;// 存放多个客户的数组private int numberOfCustomers;// 记录客户的个数public Bank() { customers = new Customer[10];}// 添加客户public void addCustomer(String f, String l) { Customer cust = new Customer(f, l); // customers[numberOfCustomers] = cust; // numberOfCustomers++; // 或 customers[numberOfCustomers++] = cust;}// 获取客户的个数public int getNumOfCustomers() { return numberOfCustomers;}// 获取指定位置上的客户public Customer getCustomer(int index) { // return customers[index];//可能报异常 if (index &gt;= 0 &amp;&amp; index &lt; numberOfCustomers) { return customers[index]; } return null;} 8..项目二 客户信息管理软件 功能演示●模拟实现一个基于文本界面的《客户信息管理软件》●进一步掌握编程技巧和调试技巧，熟悉面向对象编程;●主要涉及以下知识点:➢类结构的使用:属性、方法及构造器➢对象的创建与使用➢类的封装性➢声明和使用数组➢数组的插入、删除和替换➢关键字的使用: this结构.com.atguigu.p2CMUtilityjavaCustomerjavaCustomerLstjavaCustomerViewjava 9. 软件架构设计 10.CMUtility工具类的介绍可用来方便地实现键盘访问 public static char readMenuSelection()用途：该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。 public static char readChar() 和 public static char readChar(char defaultValue)用途：这两个方法功能相同，均从键盘读取一个字符，并将其作为方法的返回值。参数： defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。（提示：此方法可在修改客户时调用） public static int readInt() 和public static int readInt(int defaultValue)用途：这两个方法功能相同，均从键盘读取一个长度不超过2位的 整数，并将其作为方法的返回值。参数： defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 public static String readString(int limit) 和public static String readString(int limit, String defaultValue)用途：这两个方法功能相同，均从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。参数：limit — 指定字符串的最大长度 defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。 public static char readConfirmSelection()用途：从键盘读取‘Y’或’N’，并将其作为方法的返回值 11.Customer类的设计2 .3 w行 12.CustomerList类的设计操作数组之前一定要初始化 在结构体里面代码要有注释 13.CustomerView的整体设计的构建 char a=‘1’； 14.CustomerView 退出功能的实现15.CustomerView 客户列表的实现 16.CustomerView 添加客户的实现控制读取字符的长度 17.CustomerView 修改客户的实现 找不到返回主页面 局部变量 18.CustomerView 删除客户的实现19.独立写一下 收获很大 总结认知能力 别停 听了一个月就死了 去写 去熟悉 写多就会了 第五章20.继承性的理解一、继承性的好处 why①减少了代码的冗余，提高代码的复用性②便于功能的扩展③为之后多态性的使用，提供了前提 21.继承性的使用二、继承性的格式： class A extends B{} A:子类、派生类、subclass B:父类、超类、基类、superclass 2.1体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。不可以直接调 只有因为封装性的影响，使得子类不能直接调用父类的结构而已。2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。 —-自类更强大 子类和父类的关系，不同于子集和集合的关系。 extends：延展、扩展 21.继承性的再说明三、Java中关于继承性的规定：11.一个类可以被多个子类继承。 2.Java中类的单继承性：一个类只能有一个父类 3.子父类是相对的概念。 4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 23 Object类的理解四 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类 意味着，所有的java类具有java.lang.Object类声明的功能。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(上)补2","slug":"2016-06-28-面向对象-上-补2","date":"2016-06-27T23:25:46.000Z","updated":"2020-05-19T10:53:44.814Z","comments":true,"path":"2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/","link":"","permalink":"http://zhenqk.github.io/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/","excerpt":"","text":"1. 每天一问 什么是方法的重载?两同一不同”:同一个类、相同方法名;参数列表不同如何调用确定的方法:方法名→参数列表。 说明Java方法中的参数传递机制的具体体现?基本数据类型:数据值+引用数据类型:地址值(含变量的数据类型)。Person p1 = new Person( );eat();age+User u1 = p1;//编译错误(逆向思维、反证法)u1. eat()u1.age 成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同? 谈谈return关键字的使用。①结束方法②针对于有返回值的方法，return +返回数据。 提供如下代码的内存解析。 内存结构:栈(局部变量)、堆(new出来的结构:对象(非static成员变量)、数组)2.变量:成员变量vs局部变量(方法内、方法形参、构造器内、构造器形参、代码块内) 1-2. 复习 重载 匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象特点:匿名对象只能调用一次。举例:new Phone() . sendEmail();new Phone( ) . playGame();new Phone() .price = 1999;new Phone() . showPrice();//0.0 万事万物皆对象3.方法的重载概念定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。总结: “两同一不同”:同一个类、相同方法名；参数列表不同:参数个数不同，参数类型不同 构成重载的举例:举例一: Arrays类中 重载的sort() / binarySearch(); PrintStream中 的println()举例/ /如下的4个方法构成了重载public void getSum(int i,int j){System. out. println(“1”);public void getSum( double d1, double d2){System . out . print1n(“2”);}public void getSum(String s， int i){System. out . println(“3”);}public void getSum(int i,String s){System. out . println(“4”);} 不构成重载的举例://如下的3个方法不能与上述4个方法构成重载// public int getSum(int i,int j){//return 0;// }// public void getSum(int m,int n){//// }I// private void getSum(int i,int j){//// }5.如何判断是否构成方法的重载?严格按照定义判断:两同一不同。跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系!6.如何确定类中某-一个方法的调用:方法名—&gt;参数列表面试题:方法的重载与重写的区别throws \\throwString\\StringBuffer\\StringBuilderCollection\\Collectionsfinal \\finally\\finalize 抽象类、接口sleep()/wait( ) 7.可变个数形参的方法 使用说明 1.jdk 5.0新增的内容 2.具体使用: 2.1 可变个数形参的格式:数据类型… 变量名 2.2当调用可变个数形参的方法时，传入的参数个数可以是: 0个，1个,2个， 2.3可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。 2.5可变个数形参在方法的形参中，必须声明在末尾 2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参。 举例说明 调用时 test. show( “he1lo”);test. show( “hello”, “world”);test. show();test. show(new String[ ]{“AA”, “BB”, “CC”}); 3.值传递和递归方法 针对于方法内变量的赋值举例规则 :如果变量是基本数据类型，此时赋值的是变量所保存的数据值。如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。 针对于方法的参数概念 形参:方法定义时，声明的小括号内的参数 实参:方法调用时，实际传递给形参的数据| java中参数传递机制: 值传递规则:如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。推广:如果变量是基本数据类型，此时赋值的是变量所保存的数据值。如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。 String 只想常量方法区 引用数据类型 递归方法 定义递归方法:一个方法体内调用它自身。 如何理解递归方法 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。- 递归一定要向己知方向递归，否则这种递归就变成了无穷递归，类似于死循环。 举例//例1: 计算1-n之间所有自然数的和public int getSum(int n) {//if (n==1) {return 1;}else{return n + getSum(n - 1);}}面试题 面试题 4.封装性的引入IO 验证 和使用面向对象的过程，后面加深理解 面向对象特征之一: 封装与隐藏 为什么需要封装？封装的作用和含义？ 我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内部的结构吗？有必要碰电动机吗？ 我要开车， … 我们程序设计追求“高内聚，低耦合”。 高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉； 低耦合 ： 仅对外暴露少量的方法用于使用。 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说， 把该隐藏的隐藏起来，该暴露的暴露出来。 这就是封装性的设计思想。 代码 若a.legs=-4 不符合常理 加入条件如下: 让a.leg 不能被调用 private int leg； 一、问题的引入：当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值,加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()）同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private). –&gt;此时，针对于属性就体现了封装性。 二、封装性的体现： 我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值 拓展：封装性的体现：① 如上 ② 不对外暴露的私有的方法 ③ 单例模式（构造器私有） … 三、封装性的体现，需要权限修饰符来配合。1.Java规定的4种权限（从小到大排列）：private、缺省、protected 、public2.4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类3.具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类修饰类的话，只能使用：缺省、public总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。 封装性的提现 public int getAge(){ return age; } 5.封装性的提现6.四种权限修饰的理解 Java权限修饰符public、 protected、 (缺省)、 private置于类的成员定义前，用来限定对象对该类成员的访问权限。 对于class的权限修饰只可以用public和default(缺省)。 public类可以在任意地方被访问。 default类只可以被同一个包内部的类访问。 7.四种权限修饰符的测试权限的大小 打比方公司的秘密 8.封装类的练习 - 表示私有 + 表示public 9.类的成员类的成员之三：构造器(或构造方法) 构造器的特征 它具有与类相同的名称 它不声明返回值类型。（与声明为void不同） 不能被static、 final、 synchronized、 abstract、 native修饰，不能有return语句返回值 构造器的作用： 创建对象；给对象进行初始化 如： Order o = new Order(); Person p = new Person(“Peter”,15); 如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人” 的构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们要“洗澡”了 语法格式：修饰符 类名 (参数列表) {初始化语句；} 举例说明: 根据参数不同，构造器可以分为如下两类： 隐式无参构造器（系统默认提供） 显式定义一个或多个构造器（无参、有参） 注 意：Java语言中，每个类都至少有一个构造器默认构造器的修饰符与所属类的修饰符一致一旦显式定义了构造器， 则系统不再提供默认构造器一个类可以创建多个重载的构造器父类的构造器不可被子类继承 构造器 construct：建设、建造。 construction:CCB constructor:建设者 一、构造器的作用： 1.创建对象 / /创建类的对象:new +构造器 构造器是一种独立的结构 2.初始化对象的信息 ————— 二、说明： 1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器 2.定义构造器的格式：权限修饰符 类名(形参列表){} 3.一个类中定义的多个构造器，彼此构成重载 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器(一旦结婚了，就不给饭吃了 ) 5.一个类中，至少会有一个构造器。 10.构造器使用的细节说明 11-12 .构造器的练习 三角形的练习13 总结属性赋值的过程截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位置，并指明赋值的先后顺序。 赋值的位置:①默认初始化 0.0②显式初始化 1.0③构造器中初始化 123 是一次性的④通过“对象.属性“或“对象.方法”的方式赋值 赋值的先后顺序:①.②-③-④ 14. JavaBean的使用 JavaBean是一种Java语言写成的可重用组件。 所谓javaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、 set方法 用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP页面、 Servlet、其他JavaBean、 applet程序或者应用来使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。 一个类就是一个jAVABean—&gt;反射造对象 15. UML类图 16. this调用属性和方法this是什么？ 在Java中， this关键字比较难理解，它的作用和其词义很接近。 它在方法内部使用，即这个方法所属对象的引用； 它在构造器内部使用，表示该构造器正在初始化的对象。 this 可以调用类的属性、方法和构造器 什么时候使用this关键字呢？ 当在方法内需要用到调用该方法的对象时，就用this。具体的：我们可以用this来区分属性和局部变量。比如： this.name = name; 使用this，调用属性、方法 说明 在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添this，增强程序的阅读性。不过，通常我们都习惯省略this。 当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量 3.使用this访问属性和方法时，如果在本类中未找到，会从父类中查找 4.this可以作为一个类中构造器相互调用的特殊格式 使用this调用本类的构造器 注意 可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！ 明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器 如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)” “this(形参列表)”必须声明在类的构造器的首行！ 在类的一个构造器中，最多只能声明一个”this(形参列表) www what(是什么) why(为什么要用) how. 代码中 this关键字的使用 this可以用来修饰、调用：属性、方法、构造器 this修饰属性和方法：this理解为：当前对象 或 当前正在创建的对象 （构造器） 在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 this调用构造器① 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器② 构造器中不能通过”this(形参列表)”方式调用自己 ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”④ 规定：”this(形参列表)”必须声明在当前构造器的首行 ⑤ 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器 17.this调用构造器–减少冗余了构造器里面调用构造器 18 练习boyand girl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.atguigu.exer2;public class Boy { private String name; private int age; public Boy() { } public Boy(String name) { this.name = name; } public Boy(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void marry(Girl girl){ System.out.println(\"我想娶\" + girl.getName()); } public void shout(){ if(this.age &gt;= 22){ System.out.println(\"你可以去合法登记结婚了！\"); }else{ System.out.println(\"先多谈谈恋爱~~\"); } }}*-*----------------- package com.atguigu.exer2;public class Girl { private String name; private int age; public Girl() { } public Girl(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public void marry(Boy boy){ System.out.println(\"我想嫁给\" + boy.getName()); boy.marry(this); } /** * * @Description 比较两个对象的大小 * @author shkstart * @date 2019年1月18日下午4:02:09 * @param girl * @return 正数：当前对象大； 负数：当前对象小 ； 0：当前对象与形参对象相等 */ public int compare(Girl girl){// if(this.age &gt; girl.age){// return 1;// }else if(this.age &lt; girl.age){// return -1;// }else{// return 0;// } return this.age - girl.age; } }------------- package com.atguigu.exer2;public class BoyGirlTest { public static void main(String[] args) { Boy boy = new Boy(\"罗密欧\", 21); boy.shout(); Girl girl = new Girl(\"朱丽叶\", 18); girl.marry(boy); Girl girl1 = new Girl(\"祝英台\",19); int compare = girl.compare(girl1); if(compare &gt; 0){ System.out.println(girl.getName() + \"大\"); }else if(compare &lt; 0){ System.out.println(girl1.getName() + \"大\"); }else{ System.out.println(\"一样大\"); } }} 19. 练习Account123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123package com.atguigu.exer3;public class Account { private int id;//账号 private double balance;//余额 private double annualInterestRate;//年利率 public Account (int id, double balance, double annualInterestRate ){ this.id = id; this.balance = balance; this.annualInterestRate = annualInterestRate; } public int getId() { return id; } public void setId(int id) { this.id = id; } public double getBalance() { return balance; } public void setBalance(double balance) { this.balance = balance; } public double getAnnualInterestRate() { return annualInterestRate; } public void setAnnualInterestRate(double annualInterestRate) { this.annualInterestRate = annualInterestRate; } //在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。 public void withdraw (double amount){//取钱 if(balance &lt; amount){ System.out.println(\"余额不足，取款失败\"); return; } balance -= amount; System.out.println(\"成功取出：\" + amount); } public void deposit (double amount){//存钱 if(amount &gt; 0){ balance += amount; System.out.println(\"成功存入：\" + amount); } }}----------package com.atguigu.exer3;public class Customer { private String firstName; private String lastName; private Account account; public Customer(String f,String l){ this.firstName = f; this.lastName = l; } public Account getAccount() { return account; } public void setAccount(Account account) { this.account = account; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } }----------package com.atguigu.exer3;/* * 写一个测试程序。（1） 创建一个Customer ，名字叫 Jane Smith, 他有一个账号为1000，余额为2000元，年利率为 1.23％ 的账户。（2） 对Jane Smith操作。存入 100 元，再取出960元。再取出2000元。打印出Jane Smith 的基本信息成功存入 ：100.0成功取出：960.0余额不足，取款失败Customer [Smith, Jane] has a account: id is 1000, annualInterestRate is 1.23％, balance is 1140.0 */public class CustomerTest { public static void main(String[] args) { Customer cust = new Customer(\"Jane\", \"Smith\"); Account acct = new Account(1000, 2000, 0.0123); cust.setAccount(acct); cust.getAccount().deposit(100); cust.getAccount().withdraw(960); cust.getAccount().withdraw(2000); System.out.println(\"Customer[\" + cust.getLastName() + \",\" + cust.getFirstName() + \"] has a account: id is \" + cust.getAccount().getId() + \",annualInterestRate is \"+ cust.getAccount().getAnnualInterestRate() * 100 + \"% ,balance is \" + cust.getAccount().getBalance()); }} 20. 练习对象数组每加顾客+1或customers [ numberOfCustomers++] = cust; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.atguigu.exer4;public class Account { private double balance; public Account(double init_balance){ this.balance = init_balance; } public double getBalance(){ return balance; } //存钱操作 public void deposit(double amt){ if(amt &gt; 0){ balance += amt; System.out.println(\"存钱成功\"); } } //取钱操作 public void withdraw(double amt){ if(balance &gt;= amt){ balance -= amt; System.out.println(\"取钱成功\"); }else{ System.out.println(\"余额不足\"); } }}---package com.atguigu.exer4;public class Customer { private String firstName; private String lastName; private Account account; public Customer(String f, String l) { this.firstName = f; this.lastName = l; } public Account getAccount() { return account; } public void setAccount(Account account) { this.account = account; } public String getFirstName() { return firstName; } public String getLastName() { return lastName; } }----package com.atguigu.exer4;public class Bank { private Customer[] customers;// 存放多个客户的数组 private int numberOfCustomers;// 记录客户的个数 public Bank() { customers = new Customer[10]; } // 添加客户 public void addCustomer(String f, String l) { Customer cust = new Customer(f, l); // customers[numberOfCustomers] = cust; // numberOfCustomers++; // 或 customers[numberOfCustomers++] = cust; } // 获取客户的个数 public int getNumOfCustomers() { return numberOfCustomers; } // 获取指定位置上的客户 public Customer getCustomer(int index) { // return customers[index];//可能报异常 if (index &gt;= 0 &amp;&amp; index &lt; numberOfCustomers) { return customers[index]; } return null; }}+-++++++package com.atguigu.exer4;public class BankTest { public static void main(String[] args) { Bank bank = new Bank(); bank.addCustomer(\"Jane\", \"Smith\"); //连续操作 bank.getCustomer(0).setAccount(new Account(2000)); bank.getCustomer(0).getAccount().withdraw(500); double balance = bank.getCustomer(0).getAccount().getBalance(); System.out.println(\"客户：\" + bank.getCustomer(0).getFirstName() + \"的账户余额为：\" + balance); System.out.println(\"***********************\"); bank.addCustomer(\"万里\", \"杨\"); System.out.println(\"银行客户的个数为：\" + bank.getNumOfCustomers()); }}------- 21.package关键字的使用 package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。 (若缺省该语句，则指定为无名包)。它的格式为：package 顶层包名.子包名 包对应于文件系统的目录， package语句中，用 “.” 来指明包(目录)的层次； 包通常用小写单词标识。通常使用所在公司域名的倒置： com.atguigu.xxx 包的作用： 包帮助管理大型软件系统： 将功能相近的类划分到同一个包中。 比如： MVC的设计模式 包可以包含类和子包， 划分项目层次， 便于管理 解决类命名冲突的问题 控制访问权限 一、package关键字的使用1.为了更好的实现项目中类的管理，提供包的概念2.使用package声明类或接口所属的包，声明在源文件的首行3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”4.每”.”一次，就代表一层文件目录。 补充：同一个包下，不能命名同名的接口、类。 不同的包下，可以命名同名的接口、类。JDK中主要的包介绍 22.MVC设计模式的理解​ MVC是常用的设计模式之一，将整个程序分为三个层次： 视图模型层，控制器层，与数据模型层。 这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性 23 import 关键字的使用二、import关键字的使用import:导入 在源文件中显式的使用import结构导入指定包下的类、接口 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用”xxx.*”的方式，表示可以导入xxx包下的所有结构 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果使用的类或接口是本包下定义的，则可以省略import结构 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。————***** 使用”xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 * 不代表子包 import static:导入指定类或接口中的静态结构:属性或方法。 eg import static java.lang.System.*； out.print(“121”) 为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(.*)。 import语句告诉编译器到哪里去寻找类。 语法格式：import 包名. 类名; 应用举例：import pack1.pack2.Test; //import pack1.pack2.*;表示引入pack1.pack2包中的所有结构 注意： 在源文件中使用import显式的导入指定包下的类或接口 声明在包的声明和类的声明之间。 如果需要导入多个类或接口，那么就并列显式多个import语句即可 举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。 如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类。 如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。 import static组合的使用：调用指定类或接口下的静态的属性或方法 两个date # document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(上)补1","slug":"2016-06-10-面向对象-上-补1","date":"2016-06-27T02:57:13.000Z","updated":"2020-05-19T10:54:04.464Z","comments":true,"path":"2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/","link":"","permalink":"http://zhenqk.github.io/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/","excerpt":"","text":"1-2. 每天一问不是获取文件，而是过程，抄别人没有意义 1.面向对象思想编程内容的三条主线分别是什么 ①类及类的成员:属性、方法、构造器;代码块、内部类②面向对象的三大特征:封装、继承、多态。 ③其它关键字: this,super,abstract,interface,static,final,package,import 面向对象的编程思想?(类、对象;面向对象的三大特征…) 2.谈谈你对面向对象中类和对象的理解，并指出二者的关系 类:抽象的、概念上的内容。对象:实实在在存在的一个个体。对象是由类派生出来的。 3.面向对象思想的体现一:类和对象的创建和执行操作有哪三步? ①创建类②类的实例化。③调用对象的结构: “对象，属性” “对象.方法’ 4.类的方法内是否可以定义变量?是否可以调用属性?是否可以定义方法?是否可以调用方法? 是;是;否;是 3-4 复习学习 1个月 就可以工作了 1.面向对象学习的三条主线:①类及类的成员:属性、方法、构造器;代码块、内部类②面向对象的三大特征:封装、继承、多态。③其它关键字: this,super,abstract,interface,static,final,package,import “大处着眼，小处着手”2.面向对象与面向过程(理解)1.面向过程: 强调的是功能行为，以函数为最小单位，考虑怎么做。2.面向对象: 强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。 举例: 把大象装进冰箱3.完成一一个项目(或功能)的思路: 根据问题需要，选择问题所针对的现实世界中的实体。 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。 把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。 将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。 4.面向对象中两个重要的概念: 类:对一类事物的描述，是抽象的、概念上的定义 对象:是实际存在的该类事物的每个个体，因而也称为实例(instance)面向对象程字设计的重点是类的设计设计类，就是设计类的成员。 二者的关系:对象，是由类new出来的，派生出来的。 5.面向对象思想落地实现的规则一 1.创建类，设计类的成员 2.创建类的对象 3.通过“对象.属性”或“对象.方法”调用对象的结构 补充:几个概念的使用说明属性=成员变量=fie]d=域、字段方法=成员方法=函数= method创建类的对象=类的实例化=实例化类 6.对象的创建与对象的内存解析 典型代码:Person p1 = new Person();Person p2 = new Person();Person p3 = p1;//没有新创建-一个对象，共用一个堆空间中的对象实体。 说明:如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非static的)意味着:如果我们修改一-个对象的属性a，则不影响另外–个对象属性a的值。 7. JVM 内存结果《JVI规范》 虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中 堆，我们将nev出来的结构(比如:数组、对象)加载在对空间中。补充:对象的属性(非static的)加载在堆空间中。 方法区:类的加载信息、常量池、静态域 5. 属性和方法局部变量和属性 相同点和不同点 补充: 回顾变量的分类 1.按照数据类型分 2.按照类中声明的位置 方法复习关键字return方法的使用6. 万物皆对象一、理解“万事万物皆对象”1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构Scanner,String等文件：File网络资源：URL2.涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。 7. 对象数组的内存解析内存解析的说明1.引用类型的变量，只可能存储两类值：null 或 地址值（含变量的类型） 8. 匿名对象的使用 （可以看到这个）有名的对象eg 匿名对象 1.理解我们创建的对象，没有显式的赋给一个变量名。即为匿名对象 2.特征匿名对象只能调用一次。 3.实现代码 PhoneMall p104类比，你给别人的匿名信，他写上名字了mall.show(new Phone()); class PhoneMall{ public void show(Phone phone){ phone.sendEmail(); phone.playGame(); } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class InstanceTest { public static void main(String[] args) { Phone p = new Phone();// p = null; System.out.println(p); p.sendEmail(); p.playGame(); //匿名对象// new Phone().sendEmail();// new Phone().playGame(); new Phone().price = 1999; new Phone().showPrice();//0.0 //********************************** PhoneMall mall = new PhoneMall();// mall.show(p); //匿名对象的使用 mall.show(new Phone()); }}class PhoneMall{ public void show(Phone phone){ phone.sendEmail(); phone.playGame(); } }class Phone{ double price;//价格 public void sendEmail(){ System.out.println(\"发送邮件\"); } public void playGame(){ System.out.println(\"玩游戏\"); } public void showPrice(){ System.out.println(\"手机价格为：\" + price); } } 9.自定义数据工具类合理 整洁 复用性 –工具类的封装 10.理解方法的重载10.1方法的重载 重载的概念overload 参数列表在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 “两同一不同”:同一个类、相同方法名 参数列表不同：参数个数不同，参数类型不同 重载的特点:与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。 重载示例://返回两个整数的和int add(int x,int y){return x+y;}//返回三个整数的和int add(int x,int y,int z){return x+y+Z;}1返回两个小数的和double add(double x,double y){return x+y;} 11.方法的重载细节介绍 重载的判断跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！ 在通过对象调用方法时，如何确定某一个指定的方法：方法名 —&gt; 参数列表(还要看) 12.重载的举例与判断使用重载，可以为编程带来便捷a nb y 不要看返回值类型c yd yee yf ng n 13.编程实现duplicate 重复的 多重的 14.可变个数的形参的方法可变形参的方法JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。//JDK 5.0以前:采用数组形参来定义方法，传入多个同一类型变量public static void test(int a ,String[] books);//JDK5.0:采用可变个数形参来定义方法，传入多个同一类型变量public static void test(int a ,String…books); 具体使用 1.可变个数形参的格式：数据类型 … 变量名 2.当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。 3.可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载 9-11 4.可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。图9-12 5.可变个数形参在方法的形参中，必须声明在末尾String .. .strs必须声明在末尾 public void show(int i,String .. .strs)； 6.可变个数形参在方法的形参中,最多只能声明一个可变形参。 一山不容二虎打比方:万能备胎王 ；任何找不到 都不可以找到他；解说都要是String类型 才可以 原来的时候 123test.show(new String[]{\"AA\",\"BB\",\"CC\"});public void show(String[] strs){} 现在 123456789101112不用newtest.show(\"AA\",“BB”)；这样做也对test.show(new String[]{\"AA\",\"BB\",\"CC\"}); public void show(String ... strs){ System.out.println(\"show(String ... strs)\"); for(int i = 0;i &lt; strs.length;i++){ System.out.println(strs[i]); } } 应用: SQL 查条件 where 之后条件不知道要写几个 15.理解变量的赋值** 难点方法参数的值传递机制 方法，必须由其所在类或对象调用才有意义。若方法含有参数: 形参:方法声明时的参数 实参:方法调用时实际传给形参的参数值 Java的实参值如何传入方法呢?Java里方法的参数传递方式只有一种:值传递。即将实际参数值的副本(复制品)传入方法内，而参数本身不受影响。 形参是基本数据类型:将实参基本数据类型变量的“数据值”传递给形参 形参是引用数据类型:将实参引用数据类型变量的“地址值”传递给形参每天坚持 不停去写真是存的数字给它了，自己没有动 order o1=o2；一个对象的值修改了会影响到另一个对象Order o2 = o1;//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。 关于变量赋值如果变量是基本数据类型，此时赋值的是变量所保存的数据值。如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。 16.方法的形参的传递机制：值传递12形参：方法定义时，声明的小括号内的参数实参：方法调用时，实际传递给形参的数据 值传递机制：如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。 17.方法的形参的传递机制：引用数据类型传递 ###引用数据类型 赋值了地址 交换两个数组元素的值 18.画图19.探讨网红题目 20 参数传递的联系21 递归方法的使用递归方法 –理解 递归方法：一个方法体内调用它自身。 方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。eg//计算1-100之间所有自然数的和public int sum(int num){if(num == 1){return 1;}else{return num + sum(num - 1);}} 22 递归方法的使用递归的练习 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"面向对象(上)","slug":"2016-06-10-面向对象-上","date":"2016-06-26T22:49:32.000Z","updated":"2020-05-19T10:54:19.286Z","comments":true,"path":"2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/","link":"","permalink":"http://zhenqk.github.io/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/","excerpt":"","text":"Java语言的基本元素 类与对象5. 面向对象的思想概述 类(Class)和对象(Object)是面向对象的核心概念。 类是对一类事物的描述，是抽象的、概念上的定义 对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。 万事万物皆对象 可以理解为:类=抽象概念的人;对象=实实在在的某个人 面向对象程序设计的重点是类的设计（图纸） 类的设计，其实就是类的成员的设计 6.类的结构: 属性和方法Java类及类的成员 现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的细胞构成的。同理，Java代码世界是由诸多个不同功能的类构成的。 现实生物世界中的细胞又是由什么构成的呢?细胞核、细胞质、..那么,Java中用类class来描述事物也是如此。常见的类的成员有: 属性:对应类中的成员变量 行为:对应类中的成员方法 Field=属性=成员变量=域，字段，Method= (成员)方法=函数eg： 生活中描述事物无非就是描述事物的属性和行为。如:人有身高，体重等属性，有说话,打球等行为。类的成员构成version 1.0 类的成员构成version 2.0 7.类和对象的创建 创建类的对象=类的实例化=实例化类 创建对象语法： 类名 对象名 = new 类名(); 使用“对象名.对象成员”的方式访问对象成员（包括属性和方法） 二、类和对象的使用(面向对象思想落地的实现) 创建类，设计类的成员（多） 创建类的对象 通过““对象.属性或“对象.方法”调用对象的结构123456789101112131415161718192021222324252627282930313233343536class Person{ //属性 String name; int age = 1; boolean isMale; //方法 public void eat( ) { System.out.println(\"人可以吃饭\"); } public void sleep() { System.out.println(\"人可以睡觉\"); } public void talk(String language) { System.out.println(\"人可以说话,使用的是: \" + language); }}//测试类public class PersonTest {public static void main(String[] args) {//创建Person类的对象Person p1 = new Person( ) ;//Scanner scanner = new Scanner(System.in);//调用对象的结构:属性、方法//调用属性:“对象.属性”p1.name = \"Tom\";p1. isMale = true;System. out . println(p1. name);//调用方法:“对象。方法”p1.eat();p1.sleep();p1. talk(\"Chinese\"); } } 8.对类和对象创建的再理解有了对象反推出类—&gt;反射9.类多个对象的关系== 打比方 简历的模板 ，谁填是谁的信息 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非static的) 意味着:如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。 123//将p1变量保存的对象地址值赋给p3 ,导致p1和p3指向了堆空间中的同一个对象实体。Person p3=p1;System. out. println(p3.name);/ /Tom 10.对象的内存解析 方法中定义的变量都是局部变量 11.属性与局部变量的对比11-12属性(成员变量) VS 局部变量 （打比方 放的位置不同 蜂王和工蜂） 1.相同点 定义变量的格式:数据类型变量名=变量值 先声明，后作用 变量都有其对应的作用域、 2.不同点 在类中声明的位置的不同 属性：直接定义在类的一对{}内 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、public、缺省、protected ---&gt;封装性 作用域的大小 目前，大家声明属性时，都使用缺省就可以了。 局部变量：不可以使用权限修饰符，并没有默认初始化值（也就是理解方法代替了） 默认初始化值的情况: 属性:类的属性，根据其类型，都有默认初始化值。整型(byte、short、int、long):0浮点型(float、double) 0.0字符型(char):0或’\\u0000’ )布尔型(boolean) : false引用数据类型(类、数组、接口) : null 局部变量:没有默认初始化值。意味着，我们在调用局部变量之前，一定要显式赋值。特别地:形参在调用时，我们赋值即可。（下图） 在内存中加载的位置:属性:加载到堆空间中(非static 存在 方法区)局部变量:加载到栈空间 13. 类中方法举例与声明的格式方法：描述类应该具有的功能比如 Math类的sqrt() 举例public void eat(){}public void sleep(int hour){}public String getName(){}public String getNation(String nation){} 方法的声明：权限修饰符 返回值类型 方法名(形参列表){ 方法体 };注意：static、final、abstract 来修饰的方法，后面再讲。 14. 方法声明的说明14-15 说明： 3.1 关于权限修饰符：默认方法的权限修饰符先都使用publicJava规定的4种权限修饰符：private、public、缺省、protected –&gt;封装性再细说 3.2 返回值类型： 有返回值 vs 没有返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：“return 数据”。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。 3.2.2 我们定义方法该不该有返回值？① 题目要求② 凭经验：具体问题具体分析 3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 3.4 形参列表： 方法可以声明0个，1个或多个形参。 3.5 方法体：方法功能的体现。 16 return关键字的使用 return关键字的使用： 1.使用范围：使用在方法体中 2.作用：① 结束方法 ② 针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。 3.注意点：return关键字后面不可以声明执行语句。17. 方法使用中的注意点 方法的使用中，可以调用当前类的属性或方法特殊的：方法A中又调用了方法A:递归方法。方法中，不可以定义方法。 18-19-20. 类的设计 练习21-22 test 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/* * 4. 对象数组题目：定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。问题一：打印出3年级(state值为3）的学生信息。问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息提示：1) 生成随机数：Math.random()，返回值类型double; 2) 四舍五入取整：Math.round(double d)，返回值类型long。 * * * * */public class StudentTest { public static void main(String[] args) {// Student s1 = new Student();// Student s1 = new Student();// Student s1 = new Student();// Student s1 = new Student();// Student s1 = new Student();// Student s1 = new Student(); //声明Student类型的数组 Student[] stus = new Student[20]; //String[] arr = new String[10]; for(int i = 0;i &lt; stus.length;i++){ //给数组元素赋值 stus[i] = new Student(); //给Student对象的属性赋值 stus[i].number = (i + 1); //年级：[1,6] stus[i].state = (int)(Math.random() * (6 - 1 + 1) + 1); //成绩：[0,100] stus[i].score = (int)(Math.random() * (100 - 0 + 1)); } //遍历学生数组 for(int i = 0;i &lt;stus.length;i++){// System.out.println(stus[i].number + \",\" + stus[i].state // + \",\" + stus[i].score); System.out.println(stus[i].info()); } System.out.println(\"********************\"); //问题一：打印出3年级(state值为3）的学生信息。 for(int i = 0;i &lt;stus.length;i++){ if(stus[i].state == 3){ System.out.println(stus[i].info()); } } System.out.println(\"********************\"); //问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息 for(int i = 0;i &lt; stus.length - 1;i++){ for(int j = 0;j &lt; stus.length - 1 - i;j++){ if(stus[j].score &gt; stus[j + 1].score){ //如果需要换序，交换的是数组的元素：Student对象！！！ Student temp = stus[j]; stus[j] = stus[j + 1]; stus[j + 1] = temp; } } } //遍历学生数组 for(int i = 0;i &lt;stus.length;i++){ System.out.println(stus[i].info()); } }}class Student{ int number;//学号 int state;//年级 int score;//成绩 //显示学生信息的方法 public String info(){ return \"学号：\" + number + \",年级：\" + state + \",成绩：\" + score; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* * 4. 对象数组题目： 定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。问题一：打印出3年级(state值为3）的学生信息。问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息提示：1) 生成随机数：Math.random()，返回值类型double; 2) 四舍五入取整：Math.round(double d)，返回值类型long。 * * * 此代码是对StudentTest.java的改进：将操作数组的功能封装到方法中。 * */public class StudentTest1 { public static void main(String[] args) { //声明Student类型的数组 Student1[] stus = new Student1[20]; for(int i = 0;i &lt; stus.length;i++){ //给数组元素赋值 stus[i] = new Student1(); //给Student对象的属性赋值 stus[i].number = (i + 1); //年级：[1,6] stus[i].state = (int)(Math.random() * (6 - 1 + 1) + 1); //成绩：[0,100] stus[i].score = (int)(Math.random() * (100 - 0 + 1)); } StudentTest1 test = new StudentTest1(); //遍历学生数组 test.print(stus); System.out.println(\"********************\"); //问题一：打印出3年级(state值为3）的学生信息。 test.searchState(stus, 3); System.out.println(\"********************\"); //问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息 test.sort(stus); //遍历学生数组 test.print(stus); } /** * * @Description 遍历Student1[]数组的操作 * @author shkstart * @date 2019年1月15日下午5:10:19 * @param stus */ public void print(Student1[] stus){ for(int i = 0;i &lt;stus.length;i++){ System.out.println(stus[i].info()); } } /** * * @Description 查找Stduent数组中指定年级的学生信息 * @author shkstart * @date 2019年1月15日下午5:08:08 * @param stus 要查找的数组 * @param state 要找的年级 */ public void searchState(Student1[] stus,int state){ for(int i = 0;i &lt;stus.length;i++){ if(stus[i].state == state){ System.out.println(stus[i].info()); } } } /** * * @Description 给Student1数组排序 * @author shkstart * @date 2019年1月15日下午5:09:46 * @param stus */ public void sort(Student1[] stus){ for(int i = 0;i &lt; stus.length - 1;i++){ for(int j = 0;j &lt; stus.length - 1 - i;j++){ if(stus[j].score &gt; stus[j + 1].score){ //如果需要换序，交换的是数组的元素：Student对象！！！ Student1 temp = stus[j]; stus[j] = stus[j + 1]; stus[j + 1] = temp; } } } } }class Student1{ int number;//学号 int state;//年级 int score;//成绩 //显示学生信息的方法 public String info(){ return \"学号：\" + number + \",年级：\" + state + \",成绩：\" + score; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"}]},{"title":"基本数据类型","slug":"2016-06-24-基本数据类型","date":"2016-06-24T12:08:07.000Z","updated":"2020-05-19T10:19:52.766Z","comments":true,"path":"2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/","link":"","permalink":"http://zhenqk.github.io/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/","excerpt":"","text":"1. Java 语言基础-基本数据类型1. HelloWorld程序的讲解 public、class、static、 void为关键字，固定写法 HelloWord 为类名，可以任意写 main 为函数或方法名，每个程序都有一个main函数做为入口，如同房间，需要有个门一样 main方法后面括号的内容称为参数 System. out. println(“HelloWord” )向控制台输入内容 注意:类名第一个字母要使用大写，花括号是成对出现的 2. 常量的概述和使用什么是常量在程序执行的过程中其值不可以发生改变 Java中常量的分类①字面值常量②自定义常量(面向对象部分讲) 字面值常量的分类①字符串常量用双引号括起来的内容 “Java”②整数常量所有整数 1000③小数常量所有小数 3.14 有效数字 float 6-7 double 15-16④字符常量用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号 ‘c’⑤布尔常量较为特殊，只有true和false⑥空常量null [数组部分]win10 快速访问 3. 二,八,十六进制什么是进制 进制是一种进位方法。对于任何一种进制 X进制，就表示某-位置上的数 运算时逢X进一一位。 二进制就是逢二进一， 八逆制是逢八进一， 十进制是逢十进一， 十六进制是逢十六进-一。 不同进制数据的Java表现形式 二进制的数据表现形式 -一 由0,1组成。以0b(b可大小写)开头2= 10System.out.print(0b10); 八进制的数据表现形式— 由0,1,…7组成。 以0开头[8= 10] System.out.print(011); 十进制的数据表现形式—由0,1-9组成。整数默认是十进制的[10= 10] 十六进制的数据表现形式—由,1,–9,a,b,c,d,e,f(大小写均可)。以0x开头[16= 10] System.out.print(0X16); 注意:只有JDK1.7版本以上可以使用0b2来表示二进制 二进制 在计算机中，只能识别二进制的数据，二进制就是0和1来表示的 如上图表示1个字节，一个字节有8个比特位(1lbyte =8bit) 字节是数据存储的基本单位 数据存储单位计算1byte=8bit (比特)1kb = 1024byte1M = 1024kb1G = 1024M1T=1024G 二进制和十进制的转换 任意进制到十进制的转换原理 系数:就是每一位上的数据。 基数: x进制，基数就是X. 权:在右边，从0开始编号，对应位上的编号即为该位的权。 结果:把系数*基数的权次幂相加即可。 图解 八进制到十进制的转换 十六进制到十进制的转换 原码反码补码 有符号数据表示法的几种方式 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 左边是最高位，右边最低位 1111 1111 255 - 通过一个字节,也就是8个二进制位表示+7和-7 - 0(符号位) 0000111 +7 - 1(符号位) 0000111 -7 反码正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 eg. -7 1 000 0111（原码） 反码 11111 000 补码正数的补码与其原码相同；负数的补码是在其反码的末位加1 -7的补码 1111 1001 原码反码补码练习 已知原码求补码* 0b10110100 11001011+1 1100 1100 已知补码求原码* 0b11101110 1110 1110 1110 1101 -&gt;1001 0010 4. 变量和数据类型 变量的概述及格式 什么是变量在程序执行的过程中，在某个范围内其值可以发生改变的量 变量的定义格式，[如同数据方程式xyz, 求值]数据类型 变量名=变量值;byte b= 127; 为什么要定义变量用来不断的存放同类型的常量,并可以重复使用 5. 基本数据类型的定义 为什么有数据类型 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型， 每一种数据类型在内存中分配了不同大小的内存空间 这样做是为了充分高效的利用内存空间 -&gt; 2m的人 2m床 Java中数据类型的分类①基本数据类型②引用数据类型(面向对象部分) 基本数据类型分类(4类8种) 整数型:byte (字节类型) 占一个字节 -2^72^7-1[-128127] 不能把一个int 型转换为byte型 short 占两个字 -2^15~ 2^15-1 [ -3276832767]int 占四个字节-2^312^31-1 [-2^31=2147483647]1ong 占八个字节- 2^63~ 2^63-1 [ -2^63=9223372036854775807]写长整型时，加个L标识,可以写小写的l,但小写的l像一，不建议写 long d = -922L; System.out.println(d); 浮点型:float单精度占四个字节 -3.403E38~3.403E38单精度型使用F标识,不加F,默认就是双精度 float e = 1.87312343F;//单精度型使用F标识 System.out.println(e); double双精度占八个字节-1.798E308~1.798E308 字符型: char占两个字节0~65535 布尔型: boolean java中boolean类型没有明确指定他的大小 基本数据类型定义的注意事项 赋值时候注意float类型,long类型，加大写的F和L 作用域问题:同一个区域不能使用相同的变量名 初始化值问题:局部变量在使用之前必须赋值 一条语句可以定义几个变量 eg: int a,b,c 6.数据类型转换 Java中 的默认转换规则 取值范围小的数据类型与取值范围大的数据类型进行运算会先将小的数据类型提升为大的.再运算 Java的运算是以补码形式运算的得到了结果是1000 0010 == -2 再转换为补码强制类型转换会损失精度 数据类型相加的细节 进行混合运算的时候,byte,short,char不会相互转换都会自动类型提升为int类型 byte,short,char与其他类型进行混合运算的是小的数据类型提升为大的 7.面试题:long与float的取值范園谁大谁小 重点 8.字符和字符串参与运算字符 字符是指计算机中使用的字母、数字、字和符号，包括: 1、2、3、A、B、C、~，( )一一+等等。 在ASCII编码中，一个英文字母字符存储需要1个字节。 在GB2312编码或GBK编码中，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母存储需要1个字节，一个汉字储存需要3到4个字节。 字符的定义 使用char来定义字符类型 给char赋值时，如果是字母或者其它字符使用单引用号如: char c=‘a’ 给char 赋值时，可以直接使用asci表的数字如: char c= 97 在ascii表中大写的与小写的相差32 告白12345678char c1 = 73;char c2 = 76;char c3 = 111;char c4 = 118;char c5 = 101;char c6 = 89;char c7 = 111;char c8 = 117; 字符的相加 字符相加会把字符对应的ascii数字相加 记住ASCII码的三个值：‘0’ 48‘A’ 65‘a’ 97 字符与字符串相加 char数据与中文 char数据类型char 在ascii编码中占1个字节 取值在0到127char 在unicode编码中占2个字节 取值在0到65535 面试题:Java语言中的字符char可以存储一个中文汉字吗?为什么呢?1可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节，utf-8编码是unicode中的一种编码，所以，Java中的字符可以存储一个中文汉字 注:可以把编码类型改成ascii再打印中文给学生看，讲解为什么GBK编码 ： 只能显示简体中文GB2312编码:只能显示简体、繁体中文Unicode编码：不仅可以存中文，还有可存日文，韩文(万国码)-UTF-8 (万国码)-UTF-16 Unicode码 Unicode是一种字符集，中、日、韩的三种文字占用了Unicode中0x3000到0x9FFF的部分 Unicode采用的是UCS-2,用两个字节表示一个字符，2的16次方等于65536，最多能编码65536个字符 比如汉字“经”的编码是0x7ECF （字符码一般用16进制表示），转换成10进制就是32463 unicode编码从0到127的字符与ASCII编码的字符一样 比如字母”a”的Unicode 编码是0x0061,十进制是97 而”a”的ASCII编码是0x61,十进制也是97 对于汉字的编码，事实上Unicode对汉字支持不怎么好 因为简体和繁体总共有六七万个汉字，而UCS-2最多能表示65536个，才六万 多个 所以Unicode只能排除一些几乎不用的汉字 好在常用的简体汉字 也不过七千多个 为了能表示所有汉字，Unicode也有UCS-4规范，就是用 4个字节来编码字符 UTF-8编码 UTF-8(8-bit Unicode Transformation Format)是一种针对Unicode的可变长度字符编码,又称万国码。项目开发中常用utf-8 查看部分unicode码表http://baike.baidu.com/item/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8/12022016?sefr=cr 在线unicode码转换 网址: http://tool.chinaz.com/tools/unicode.aspx 演示a的unicode \\u0061 0x61 演示中的unicode \\u4e2d 熟记中文在unicode的范围 \\u4E00-\\u9FA5 19968 ~ 40869 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"引言:为什么学习Java以及怎么学习Java","slug":"2016-06-24-为什么学习Java以及怎么学习Java","date":"2016-06-24T10:11:03.000Z","updated":"2020-05-19T10:16:22.947Z","comments":true,"path":"2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/","link":"","permalink":"http://zhenqk.github.io/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/","excerpt":"","text":"1认识Java+1. Java在公司里是用于干啥的?(主要1和3)①Java web: 银行系统&amp;银行网站&amp;酒店系统&amp;N多后台管理系统 主要②App: android是 用java写的，今年出了新的kotlin语言③接口:为android、i0S等App提供数据访问接口 主要④大数据(马云说过“大”是计算的意思)⑤桌面应用(比较少开发桌面应用)⑥…. 2. Java的招聘需求及薪资 拉钩 3. Java的职业规划发展方向 首席java程序员 项目组组长:管理一个小团队 技术总监:主要把控项目中技术一块 软件系统架构师:负责整个项目的架构和技术实施方案（服务器 运维 并发 5年） 技术合伙人:公司的技术一把手，以技术来占公司股份，不需要花钱买（以技术入股） 软件营销:成为一个软件方面的销售高手 当IT讲师:传授你的工作经验 创业:与其他好友同事创业，开自己的公司，接外包或者做自己的产品 赚得一-定财富后，回老家开小店过小日子 (年薪20万 要有副业) 4. Java的就业前景和形势 领域非常广Java技术具有卓越的通用性、高效性、平台移植性和安全性，广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，所以说Java的应用领域非常广，同时拥有全球最大的开发者专业社群 需求量大Java是全球最流行的开发语言，我国的软件开发人才极为缺乏，其中java人才缺口最大，对java软件工程师的需求达到全部需求量的60% -70%，Java又 是安卓开发的基础，所以人才的需求又增加一大波。 就业方向非常广学完可应聘java\\h5\\android\\大数据架构师等职位。。。Java是一一门世界最好的语言，学会了Java再学习其它语言php, ios, python等非常容易上手一个星期或者半个月就可以做项目总结:学了Java,你可以在招聘网上投递的职位非常多需求量巨大 5. Java的学习方法和建议 跟着上课老师的课程大纲学习，掌握课堂知识点。 勤做笔记，如果上课走神或者没听懂的知识点，记下时间，再倒回去看视频。 复习时看视频，尽量1.5~2倍来看视频,课后多练代码。 写多了 就理解多了 尽量老师一边讲课，同学们一边写代码，当场掌握知识点。 不懂的多问老师与同学，因为毕业后，不一定才能能及时帮到你。 要有自己的思维，做一个功能或者需求时，想想有没有另一种方法。 多与同班同学交流，丰富情感生活，以后好互相推荐工作。 脑子累了要休息，尽量不要晚上通宵写代码，身体要紧。 每周或者两周要去参加一个活动,集体打球。 还有一点是学程序开发，有时是枯澡无味的，要忍住无聊和寂寞，特别是Java基础 6. 学习前要谨记一些心态 只要努力掌握课堂知识和老师的建议再加上自己的信心，找份较满意工资的工作是没有问题 一个班不可能每个都拿高薪，工资高的不一定是知识掌握的最好的那位同学。有时高薪看天时地利人和 学习Java找工作，只是你的一一个起点，以后你还会学习其它的语言，或者说不干程序员这份工作也说不定。(sina- 程序员辞职卖水果) 只要学精一门语言，不用怕以后这门语言不值钱，不用怕以后找不到工作。经验是最值钱的 对自己要有信心&amp;工资量&amp;打牢固公司看中经验 2.计算机基础&amp;DOS1. 计算机简介: 计算机(computer) 俗称电脑，是现代一种用于高速计算的电子计算机器，是能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。 计算机由硬件系统和软件系统所组成，没有安装任何软件的计算机称为裸机。 计算机可分为超级计算机、工业控制计算机、网络计算机、个人计算机、嵌入式计算机五类，较先进的计算机有生物计算机、光子计算机、量子计算机等。 计算机发明者约翰.冯，诺依曼。计算机是20世纪最先进的科学技术发明之一 计算机的硬件分成5大组成部件:运算器、控制器、存储器、输入设备和输出设备。 运算器、控制器合称为中央处理单元(Central ProcessingUnit, CPU)或处理器 存储器分为:内部存储器(内存条) -重启电脑数据不在 外部存储器(U盘、硬盘),重启电脑数据还在 输入设备有键盘、 鼠标等 输出设备有显示器、打印机等 2. 计算机的操作系统 操作系统(Operating System, 简称0S)是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在”裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。 常见的操作系统: Windows/Linux/MacOS/ Android/ iOS 3. 计算机软件概念 软件(中国大陆及香港用语，台湾称作软体，英文: Software) app 软件是一系列按照特定顺序组织的计算机数据和指令的集合。 一般来讲软件被划分为系统软件、应用软件和介于这两者之间的中间件。 系统软件:windows/linux/macOS/ Android/i0S 应用软件:QQ WeChat 浏览器迅雷、后台系统等… 4. 软件开发的概念什么是软件开发借助开发工具与计算机语言制作软件 什么是计算机语言人与计算机之间进行信息交流沟通的一种特殊语言 计算机语言的分类 机器语言:机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。 汇编语言:汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。 高级语言:使用普通英语进行编写源代码，通过编译器将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。高级语言包括C,C++, C#, JAVA，PHP, Py thon 5. DOS命令​ DOS (磁盘操作系统)命令，是DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。常用命令如下: win+e 文件资源管理器 win+r 命令行 1. 查看目录内容命令dir 2. 打开指定目录命令[语法: cd路径] 拖拽 2.1 同盘下(切换路径) 2.2 异盘下(切换到D盘) 2.3 特殊用法 ;返回当前盘的根路径 3. 创建目录命令[语法:md 文件夹名字] —mkdir dir4. 删除当前指定的目录[语法:rd 路径] –remove 1235. 创建文件 echo a&gt; a.txt6. 文件复制命令[语法: copy 源文件路径 目标文件路径] 执行效果相同 7. 显示文本文件内容命令[语法: type 文件名]8. 更改文件名命令[语法: ren a.txt a1.txt]9. 删除文件命令[语法: del a.txt a1.txt] note 😛 同时删除2个10. 清除屏幕命令 cls11. 改变当前盘符命令d:12. 查看环境变量path or echo %path%3.Java 开发环境的准备1. Java语言发展史 詹姆斯.高斯林(James Gosling) 1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得 了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统， 但不受重视。后来转至Sun公司，1990年， 与Patrick, Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak” ，后改名为Java。 SUN (Stanford Uni versity Network, 斯坦福大学网络公司) 卡内基梅隆大学截至2017年卡耐基梅隆大学共培养出了12个图灵奖，20个诺贝尔奖，9个奥斯卡，114个艾米奖，44个托尼奖，非常牛逼的大学。 Java是一 门软件编程语言，可编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等 早期Sun公司研发 人员对C++进行改造，开发了一种称为Oak的面向对象语言 1995年，Sun公司将Oak更名为Java 1996年，Sun公司发布了Java的第一个开发工具包(JDK1.0) 1998年，第二代Java平台的企业版J2EE发布 1999年公司发布了第二代Java平台(简称为Java2)的3个版本J2ME (Java2 Micro Edition, Java2平 台的微型版)，应用于移动、无线及有限资源的环境;J2SE (Java 2 Standard Edition, Java 2平台的标准版)，应用于桌面环境;J2EE (Java 2Enterprise Edition, Java 2平台的企业版)，应用于基于Java的应用服务器。 Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。 2009年，甲骨文公司宣布收购Sun。 2010年，Java编程语言的共同创始人之一詹姆斯.高斯林(Java之父)从Oracle公司辞职。 2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。 2014年，甲骨文公司发布了Java8正式版。 2017年，甲骨文公司发布了Java9 2. Java语言版本 老版本稳定，追求稳定 3. Java语言特点​ 简单性、解释性、面向对象、高性能、分布式处理、多线程、健壮性、动态性、安全性、跨平台、移植性注:这是一道笔记题，需要记住 4. Java语言跨平台原理4.1 什么是跨平台性1开发的软件在任何操作系统(mac/window/linux)上都能安装并运行 4.2 Java语言跨平台原理1只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。 4.3 Java语言跨平台图解 4.4 write once ，run anywhere!(一处编译,到处运行)5. JRE和JDK的概述5.1 什么是JRE (Java Runtime Environment) JRE包括Java虛拟机(JVM Java Virtual Machine)和Java程序所需的核心类库(jar 包)等 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。（java-&gt;jar） 总的说JRE = JVM +核心类库 5.2 什么是JDK (Java Development Kit) JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。 所以安装了JDK,就不用在单独安装JRE了。 java的开发工具有:编译工具(javac)、 打包工具(jar)等 JDK=JRE+JAVA的开发工具。 JDK=JVM+核心类库+ Java开发工具(javac, jar..) 5.3 JDK, JRE, JVM的作用和关系 JDK包含JRE，而JRE包含JVM， 总的来说JDK是用于java程序的开发，而jre则是只 5.4 能运行class而没有编译的功能，最后用张网络图片总结下 总结:JDK:主要用于编译JRE:主要作用看运行效果JVM:主要作用跨平台，负责Java程序的调用 6. JDK的下载和安装过程图解6.1 JDK的下载地址 https://www.oracle.com/java/technologies/javase-downloads.html Sun被oracle收购，地址都可以，访问sun会跳转到oracle 6.2 JDK的安装 下载对应操作系统平台的JDK,这里下载1.8的windows平台然后傻瓜式安装，下一步下一步 验证安装是否成功 如果安装 了JDK, JDK的安装路径在C: \\Program Files\\Java\\jdk1.8.0_ 131路径下 在cmd中可以输入java -version来查看jdk的版本 可安装共存:1.7和 1.8 共存 7. JDK的删除和自定义安装路径 删除JDK不能直接把Java的home目录文件夹删除了，这种操作是不正确 正确的删除JDK是要来到 “ 控制面板\\所有控制面板项\\程序和功能”进行删除， JDK安装路径可以自己定义， 个人喜好，我就不喜欢改。 什么时候需要更改jdk的安装路径■当默认的c盘没有空 间的时候，可以改成D盘 8. JDK安装路径下的目录解释 在jdk的Home中，会有如下图的结构 Home 目录路径C: \\Program Fi les\\JavaXjdk1.8.0131,又称jdk主目录 bin:该目录用于存放一些可执行程序，如javac ( java编译器)、java(java运行 工具)，jar(打包工具)和javadoc(文档生成工具)等 db:db目录是一个小型的数据库，从JDK 6. 0开始，Java中引用了一个新的成员JavaDB, 这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4. 0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。 jre: “jre”是Java Runt ime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及-个bin目录，但不包含开发环境中的开发工具。 include: 由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。 1ib: 1ib是1ibrary的缩写， 意为Java 类库或库文件，是开发工具使用的归档包文件。 src. zip文件: src. zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码， 通过该文件可以查看Java基础类的源代码。 9.第一个Java程序， Hel loWord案例的编写与编译(命令行方式) 编写Java源代码，以.java结尾 打开终端cmd,进入到jdk的bin目录，cd “C:\\ Program Files\\Java\\jdk1.8.0_ 131\\bin” 编译java文件，终端中输入javac HelloWorld.java的全路径 执行class文件,终端输入java HelloWorld,不需要加.class后缀Java程序运行流程[记住]①编写java文件②编译java文件，获得一个.class文件③运行.class文件 看到效果 遇到问题 10. Javac&amp;Java命令执行的路径 Javac是一个将. java编译成. class文件命令 javac命令的具体路径是C: \\Program Files\\Java\\jdk1. 8.0_ 131bin 在终端cmd输入java - version, Java的命令执行的路径是在Path的C: \\PrbgramData \\0racl e\\Java\\javapath 如果在命令行执行javac HelloWorld. java 返回‘javac’ 不是内部或外部命令，也不是可运行的程序，或批处理文件。说明在当前路径找不到Javac命令 11. Java环境变量Path配置 目的: 不需要进入到bin目录，也可执行bin目录下的命令javac 方法步骤- windows10的操作: 点击:此电脑-右键属性-高级系统设置-高级-环境变量 在系统变量中新建JAVA_ HOME=C: \\Program Files\\Java\\jdk1.8.0_ 131 在系统变量中编辑Path,在后面追加路径%JAVA_ HOME%\\bin (注:是右斜杠) 在命令行可以输入echo %JAVA HOME%\\bin 来查看环境变量 通过上面的努力， 你就可以在任意目录编译. java文件了MacOs： .bash_profile 12. CLASSPATH变量配置 jvm在 查找class文件时如果没有设置classpath会在当前路径查找，设置classpath后仅在classpath路径下查找class文件即可。 classpath 不是必须配置的 一旦修改了环境变量的东西，一定要重新启动cmd命令行echo %classpath%补: cd.. 切换到上一个路径 4. Java开发工具Eclipse1. 常用的Java IDE开发工具 为什么会有Java IDE开发工具，如果像以前那样在终端通过命令行来编译执行java文件，一旦文件比较多，是件多么折腾的一件事。所以有很多开发工具，来简化我们的开发工作。 集成开发环境(IDE， Integrated Deve lopment Environment )是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。 常见的Java开发工具有，工作中掌握Eclipse即可①Editplus 少②Sublime Text 少③Eclipse (工作中常用，200多M) 免费④MyEclipse(至 少1G)⑤IntelliJ IDEA (500多M) 多 注:掌握了Eclipse, MyEclipse, IDEA也自然会用，因为他们长的两差不多 2. Eclipse历史版本 Neon 3. Eclipse的下载与安装 进入eclipse的 下载页面https://www.eclipse.org/downloads/packages/ 然后在页面中，选择红色框的下载，下载后得到一个eclipse-jee neon-3-win32-x86_ 64.zip文 件 然后解压zip,直接点击解压后文件夹中的eclipse.exe即可使用 -&gt;发送快捷方式注意:下载Eclipse-Neon的版本，一定要安装jdk1.8现在最新版本是eclipse-jee -oxygen-1a-win32 x86_ 64.zip [oxygen:氧气 ]建议项目名格式 wzq_day01_20170206 3. Eclipse的区域与字体调整 调整Eclipse的字体大小 第一种方式: 点击Eclipse的Window Prefernces偏好设置， 找到General-Appearance Colors and Fonts. 再找到Basic 然后点击Text Font来 调字体大小 第二种方式: neon版本的eclipse可以通过[ctrl +、-]来更改文字大小注:有些旧版本不支持这种方式，所以只能使用第一种 4.项目的导入和删除Project Explorer 下 选择 import -&gt;General-&gt;Existing Projects into Workspace 注释 ctrl+shift+/ctrl+/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"DOS命令","slug":"DOS命令","permalink":"http://zhenqk.github.io/tags/DOS%E5%91%BD%E4%BB%A4/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-06-23T21:06:24.000Z","updated":"2020-05-19T10:24:00.560Z","comments":true,"path":"2016/06/24/hello-world/","link":"","permalink":"http://zhenqk.github.io/2016/06/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}],"categories":[{"name":"安装","slug":"安装","permalink":"http://zhenqk.github.io/categories/%E5%AE%89%E8%A3%85/"},{"name":"Linux","slug":"安装/Linux","permalink":"http://zhenqk.github.io/categories/%E5%AE%89%E8%A3%85/Linux/"},{"name":"Linux","slug":"Linux","permalink":"http://zhenqk.github.io/categories/Linux/"},{"name":"Java 基础","slug":"Java-基础","permalink":"http://zhenqk.github.io/categories/Java-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhenqk.github.io/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://zhenqk.github.io/tags/MySQL/"},{"name":"blueBall","slug":"blueBall","permalink":"http://zhenqk.github.io/tags/blueBall/"},{"name":"Linux下JDK的安装","slug":"Linux下JDK的安装","permalink":"http://zhenqk.github.io/tags/Linux%E4%B8%8BJDK%E7%9A%84%E5%AE%89%E8%A3%85/"},{"name":"面向对象概述","slug":"面向对象概述","permalink":"http://zhenqk.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/"},{"name":"DOS命令","slug":"DOS命令","permalink":"http://zhenqk.github.io/tags/DOS%E5%91%BD%E4%BB%A4/"}]}