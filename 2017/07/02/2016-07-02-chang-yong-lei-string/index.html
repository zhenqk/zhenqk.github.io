<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="程序员Tony">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://zhenqk.github.io">
    <!--SEO-->

<meta name="keywords" content="常用类" />


<meta name="description" content="Java高级编程   使用层面
理解是可以长久保存的，别死记硬背
1.每日一考1.画图说明线程的生命周期，以及各状态切换使用到的方法等，五种状态     状态转换   方法2.同步代码块中涉及到..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    常用类String |
    
    程序员Tony
</title>

<link rel="alternate" href="/atom.xml" title="程序员Tony" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>

    <header class="main-header"  style="background-image:url(
    https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1589855563474&amp;di=3aa70d773e2c49618ad522cba950a73c&amp;imgtype=0&amp;src=http%3A%2F%2Fbpic.588ku.com%2Fback_pic%2F00%2F09%2F33%2F28562e1bc3ca3a9.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Tony'>
            <img src="/img/avatar.gif" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
          <!--<h2 class="text-hide">成为自己要成为的人</h2> -->
            
            <h2>
                越简单越OK
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://zhenqk.github.io">
                        程序员Tony</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                主目录</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/工具/"><i class="fa "></i>
                                工具</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">

            <div class="row">
 
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="常用类String">
            
            常用类String
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/Java-%E5%9F%BA%E7%A1%80/">Java 基础</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/" rel="tag">常用类</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2017/07/02</span>
    </span>
    
    <span class="fa-wrap">
        <i class="fa fa-eye"></i>
        <span id="busuanzi_value_page_pv"></span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <p>Java高级编程   使用层面</p>
<p>理解是可以长久保存的，别死记硬背</p>
<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>1.画图说明线程的生命周期，以及各状态切换使用到的方法等，<br>五种状态     状态转换   方法<br>2.同步代码块中涉及到<code>同步监视器</code>和<code>共享数据</code>，谈谈你对同步监视器和共享数据的理解，以及注意点。<br>synchronized（同步监视器)<br>/操作共享数据的代码(不能包括多了，也不能包括少了)<br>}</p>
<p>把握核心的东西<br>3.sleep()和wait()的区别。<br>4.写一个线程安全的懒汉式<br>需要会手写<br>5.创建多线程有哪几种方式。<br>继承Thread类<br>实现Runnable接口<br>实现Cllable接口。<br>线程池  （响应速度提高了，提高了资源的重用率，便于管理)</p>
<h2 id="2-生命周期与同步机制"><a href="#2-生命周期与同步机制" class="headerlink" title="2.生命周期与同步机制"></a>2.生命周期与同步机制</h2><p>图示:<br><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_01.png" alt="线程的声明周期"><br>说明:<br>1.生命周期关注两个概念:状态、相应的方法<br>2.关注:状态a–&gt;状态b:哪些方法执行了(回调方法)<br>某个方法主动调用:状态a–&gt;状态b ;<br>3.阻塞:临时状态，不可以作为最终状态<br>死亡:最终状态。|</p>
<h4 id="线程的同步机制"><a href="#线程的同步机制" class="headerlink" title="线程的同步机制"></a>线程的同步机制</h4><p>1.背景<br>火车票卖票</p>
<p>2.Java解决方案: 同步机制</p>
<p> 方式一：同步代码块<br>  synchronized(同步监视器){<br>     //需要被同步的代码<br>  }<br> 说明：1.操作共享数据的代码，即为需要被同步的代码。  –&gt;不能包含代码多了，也不能包含代码少了。<br>      2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。<br>      3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。任意<br>         要求：多个线程必须要共用同一把锁。<br>  补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</p>
<p>   在继承Thread类创建多线程的方式中，慎用this 充当同步监视器，考虑使用当前类充当同步监视器。   </p>
<p><strong>方式二：同步方法。</strong><br>    如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<p>解决线程安全问题的方式三：Lock锁  — JDK5.0新增<br> *</p>
<ol>
<li>面试题：synchronized 与 Lock的异同？<br>相同：二者都可以解决线程安全问题<br>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器<br>Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）</li>
</ol>
<p>关于同步方法的总结：</p>
<ol>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法，同步监视器是：this静态的同步方法，同步监视器是：当前类本身</li>
</ol>
<p>理解下，自己把它写一下</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_02.png" alt="线程的声明周期"></p>
<p>Lock -&gt; 同步代码块（已经进入了方法体，分配了相应资源） -&gt;同步方法（在方法体之外）</p>
<p>3.利弊</p>
<p>同步的方式，解决了线程的安全问题。—好处<br>   操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 —局限性</p>
<p>4.<br>面试题: Java是如何解决线程安全问题的，有几种方式?并对比几种方式的不同</p>
<p>面试题：synchronized 与 Lock的异同？<br>相同：二者都可以解决线程安全问题<br>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器<br>Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）</p>
<p>面试题: synchronized和Lock方 式解决线程安全问题的对比</p>
<p>异步  喊你吃饭，他走了，你也走了，他在你前面</p>
<p>##3.线程通信和新的线程创建方式</p>
<p>使用同步机制将单例模式中的懒汉式改写为线程安全的。</p>
<p>懒汉式:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同步机制将单例模式中的懒汉式改写为线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) {</span></span><br><span class="line"><span class="comment">//            if(instance == null){</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (Bank<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">                    instance = <span class="keyword">new</span> Bank();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>面试题::写一个线程安全的单例模式</p>
<p>饿汉式</p>
<p>懒汉式 写上面优化的</p>
<p>死锁:</p>
<p>1.死锁的理解:<br>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁<br>2.说明:</p>
<p>1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续<br>2）我们使用同步时，要避免出现死锁。</p>
<p>3.举例:</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer s2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s1){</span><br><span class="line">                    s1.append(<span class="string">"a"</span>);</span><br><span class="line">                    s2.append(<span class="string">"1"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s2){</span><br><span class="line">                        s1.append(<span class="string">"b"</span>);</span><br><span class="line">                        s2.append(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (s2){</span><br><span class="line"></span><br><span class="line">                    s1.append(<span class="string">"c"</span>);</span><br><span class="line">                    s2.append(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">synchronized</span> (s1){</span><br><span class="line">                        s1.append(<span class="string">"d"</span>);</span><br><span class="line">                        s2.append(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h4><p>1.线程通信涉及到的三个方法:</p>
<p>两个线程之间并行  有交流</p>
<p>例题: 使用两个线程打印1-100。线程1,线程2交替打印</p>
<p>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。<br>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。<br>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</p>
<p>2.说明:</p>
<ul>
<li>1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。<br>2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常  外面生成一个object 要是同一把锁 </li>
<li><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/..%5CstudyNote_Pic%5Csgg%5Cday19%5C19_26.png" alt="制造 加sleep 死锁的问题"></li>
<li>3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</li>
</ul>
<p>3.面试题</p>
<p>面试题：sleep() 和 wait()的异同？<br>1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>2.不同点：</p>
<ul>
<li>1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li>
<li>2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li>
<li>3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li>
</ul>
<p>4.<br>小结释放锁的操作:</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_03.png" alt="释放锁的操作"></p>
<p>小结不会释放锁的操作:</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_04.png" alt="释放锁的操作"></p>
<h4 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h4><p>新增方式一:实现Callable接口</p>
<p>说明:</p>
<p>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</p>
<ol>
<li>call()可以有返回值的。</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的</li>
</ol>
<p>新增方式二:使用线程池<br>说明:</p>
<p>好处:<br>提高响应速度(减少了创建新线程的时间)<br>降低资源消耗(重复利用线程池中线程，不需要每次都创建)<br>便于线程管理<br>V corePoolSize: 核心池的大小<br>V maximumPoolSize: 最大线程数<br>VkeepAliveTime:线程没有任务时最多保持多长时间后会终止</p>
<p>面试题: Java中 多线程的创建有几种方式?四种</p>
<p>创建线程的两种方式（继承Thread类，实现Runnable接口 ）+新特性</p>
<h2 id="4-Java常用类的概述"><a href="#4-Java常用类的概述" class="headerlink" title="4.Java常用类的概述"></a>4.Java常用类的概述</h2><h2 id="5-String类的概述"><a href="#5-String类的概述" class="headerlink" title="5.String类的概述"></a>5.String类的概述</h2><h2 id="6-理解String-不可变性"><a href="#6-理解String-不可变性" class="headerlink" title="6.理解String 不可变性"></a>6.理解String 不可变性</h2><h3 id="9-1-字符串相关的类"><a href="#9-1-字符串相关的类" class="headerlink" title="9.1 字符串相关的类"></a>9.1 字符串相关的类</h3><p>String类及常用方法和StringBuffer、StringBuilder    数组实现</p>
<h4 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h4><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_05.png" alt="String的特性"></p>
<ul>
<li>String:字符串，使用一对””引起来表示。<ul>
<li>1.String声明为final的，不可被继承</li>
<li>2.String实现了Serializable接口：表示字符串是支持序列化的。<pre><code>实现了Comparable接口：表示String可以比较大     </code></pre></li>
<li>3.String内部定义了final char[] value用于存储字符串数据</li>
<li>4.String:代表不可变的字符序列。简称：不可变性。<pre><code>体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
     2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
              3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</code></pre></li>
<li>5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li>
<li>6.字符串常量池中是不会存储相同内容的字符串的。<br><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_06.png" alt="String的特性"></li>
</ul>
</li>
</ul>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_07.png" alt="String的特性"></p>
<h2 id="7-不同实例化方式的对比"><a href="#7-不同实例化方式的对比" class="headerlink" title="7.不同实例化方式的对比"></a>7.不同实例化方式的对比</h2><p>s5=s4.replace(‘a’,’m’);</p>
<p>String 对象的创建</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_08.png" alt="String的特性"></p>
<p>第一种在常量池种</p>
<p>第二种 在堆种</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_09.png" alt="String的特性"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_10.png" alt="String实例化方式"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_11.png" alt="String的特性"></p>
<p>面试题: string s = new String(“abc”);方式创建对象，在内存中创建了几个对象?<br>两个:一个是堆空间中new结构，另一个是char[ ]对应的常量池中的数据: “abc “</p>
<h2 id="8-String-不同拼接操作的对比"><a href="#8-String-不同拼接操作的对比" class="headerlink" title="8.String 不同拼接操作的对比"></a>8.String 不同拼接操作的对比</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_12.png" alt="String的特性"></p>
<p>通过变量名参与，此时均不在常量池，需要在堆空间开辟</p>
<p>说明:</p>
<p>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。<br>只要其中有一个是变量，结果就在堆中</p>
<p>String s8=s5.intern();</p>
<p>sout(s3==s8)；   s8使用了常量值种已经存在的数据</p>
<p>如果拼接的结果调用intern()方法，返回值就在常量池中</p>
<h2 id="9-String的一道面试题"><a href="#9-String的一道面试题" class="headerlink" title="9.String的一道面试题"></a>9.String的一道面试题</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_13.png" alt="String的特性"></p>
<p>String  不可变</p>
<h2 id="10-JVM中设计字符串的内存结构"><a href="#10-JVM中设计字符串的内存结构" class="headerlink" title="10.JVM中设计字符串的内存结构"></a>10.JVM中设计字符串的内存结构</h2><p>jvm 7 字符串方法区在堆种     jvm8在元空间(永久区)</p>
<h2 id="11-String-的常用方法1-3"><a href="#11-String-的常用方法1-3" class="headerlink" title="11. String 的常用方法1-3"></a>11. String 的常用方法1-3</h2><p>明确做啥</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_14.png" alt="String 的常用方法1"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_15.png" alt="String 的常用方法2"></p>
<p>//什么情况下，index0f(str) 和astIndex0f(str)返回值相同?<br>//情况一:存在唯一的一个str.<br>。情况二:不存在str</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_16.png" alt="String 的常用方法3"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_17.png" alt="String 的常用方法3"></p>
<p>数据库是从1开始</p>
<p>正则表达式</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_18.png" alt="String 的常用方法3"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_19.png" alt="String 的常用方法3"></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1="123hello456world789";                        //开头有,或者结尾有逗号  | 或者String s2 = s1.replaceAll("\\d+", ",").replaceAll("^,|,$", "");System.out.println(s2);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_20.png" alt="String 的常用方法3"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_21.png" alt="String 的常用方法切割"></p>
<h2 id="14-String与基本数据类型包装类的转换"><a href="#14-String与基本数据类型包装类的转换" class="headerlink" title="14.String与基本数据类型包装类的转换"></a>14.String与基本数据类型包装类的转换</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_22.png" alt="String 的常用方法切割"></p>
<p>String str1=”123”</p>
<p>int num=Integer.parseInt(str1)</p>
<hr>
<p>String.valueOf(num);</p>
<p>或者   num+””      .concat</p>
<h2 id="15-String与char-之间的转换"><a href="#15-String与char-之间的转换" class="headerlink" title="15.String与char[]之间的转换"></a>15.String与char[]之间的转换</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_23.png" alt="String 的常用方法切割"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_26.png" alt="String 的常用方法切割"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_25.png" alt="String 的常用方法切割"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_24.png" alt="String 的常用方法切割"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_27.png" alt="String 的常用方法切割"></p>
<p>  <img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_28.png" alt="String 的常用方法切割"></p>
<p> 编码：String –&gt; byte[]:调用String的getBytes()<br>   解码：byte[] –&gt; String:调用String的构造器</p>
<p>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)<br>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）<br>  说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p>
<h2 id="17-解决一个拼接问题"><a href="#17-解决一个拼接问题" class="headerlink" title="17.解决一个拼接问题"></a>17.解决一个拼接问题</h2><p>  <img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_29.png" alt="String 的常用方法切割"></p>
<h2 id="18-面试中String-算法考查说明"><a href="#18-面试中String-算法考查说明" class="headerlink" title="18.面试中String 算法考查说明"></a>18.面试中String 算法考查说明</h2><p>1.模拟一个trim方法，去除字符串两端的空格。<br>2.将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”<br>3.获取一个字符串在另-一个字符串中出现的次数。<br>比如:获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数<br>4.获取两个字符串中最大相同子串。比如:<br>str1 = “abcwerthelloyuiodef;str2 = “cvhellobnm’<br>提示:将短的那个串进行长度依次递减的子串与较长的串比较。<br>5.对字符串中字符进行自然顺序排序。<br>提示:<br>1)字符串变成字符数组。<br>2)对数组排序，选择，冒泡，Arrays. sort();<br>3)将排序后的数组变成字符串。</p>
<p>自己去想</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.模拟一个trim方法，去除字符串两端的空格。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.将一个字符串进行反转。将字符串中指定部分进行反转。比如将“abcdefg”反转为”abfedcg”</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.获取一个字符串在另一个字符串中出现的次数。</span></span><br><span class="line"><span class="comment">      比如：获取“ab”在 “cdabkkcadkabkebfkabkskab”    </span></span><br><span class="line"><span class="comment">      中出现的次数</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">4.获取两个字符串中最大相同子串。比如：</span></span><br><span class="line"><span class="comment">   str1 = "abcwerthelloyuiodef“;str2 = "cvhellobnm"//10</span></span><br><span class="line"><span class="comment">   提示：将短的那个串进行长度依次递减的子串与较长  </span></span><br><span class="line"><span class="comment">   的串比较。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5.对字符串中字符进行自然顺序排序。"abcwerthelloyuiodef"</span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1）字符串变成字符数组。</span></span><br><span class="line"><span class="comment">2）对数组排序，选择，冒泡，Arrays.sort(str.toCharArray());</span></span><br><span class="line"><span class="comment">3）将排序后的数组变成字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第1题</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">myTrim</span><span class="params">(String str)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (str != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">// 用于记录从前往后首次索引位置不是空格的位置的索引</span></span><br><span class="line">			<span class="keyword">int</span> end = str.length() - <span class="number">1</span>;<span class="comment">// 用于记录从后往前首次索引位置不是空格的位置的索引</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(start) == <span class="string">' '</span>) {</span><br><span class="line">				start++;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(end) == <span class="string">' '</span>) {</span><br><span class="line">				end--;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (str.charAt(start) == <span class="string">' '</span>) {</span><br><span class="line">				<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> str.substring(start, end + <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第2题</span></span><br><span class="line">	<span class="comment">// 方式一：</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverse1</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{<span class="comment">// start:2,end:5</span></span><br><span class="line">		<span class="keyword">if</span> (str != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="comment">// 1.</span></span><br><span class="line">			<span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">			<span class="comment">// 2.</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) {</span><br><span class="line">				<span class="keyword">char</span> temp = charArray[i];</span><br><span class="line">				charArray[i] = charArray[j];</span><br><span class="line">				charArray[j] = temp;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">// 3.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方式二：</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverse2</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">		<span class="comment">// 1.</span></span><br><span class="line">		String newStr = str.substring(<span class="number">0</span>, start);<span class="comment">// ab</span></span><br><span class="line">		<span class="comment">// 2.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) {</span><br><span class="line">			newStr += str.charAt(i);</span><br><span class="line">		} <span class="comment">// abfedc</span></span><br><span class="line">			<span class="comment">// 3.</span></span><br><span class="line">		newStr += str.substring(end + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> newStr;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方式三：推荐 （相较于方式二做的改进）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverse3</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{<span class="comment">// ArrayList list = new ArrayList(80);</span></span><br><span class="line">		<span class="comment">// 1.</span></span><br><span class="line">		StringBuffer s = <span class="keyword">new</span> StringBuffer(str.length());</span><br><span class="line">		<span class="comment">// 2.</span></span><br><span class="line">		s.append(str.substring(<span class="number">0</span>, start));<span class="comment">// ab</span></span><br><span class="line">		<span class="comment">// 3.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) {</span><br><span class="line">			s.append(str.charAt(i));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.</span></span><br><span class="line">		s.append(str.substring(end + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5.</span></span><br><span class="line">		<span class="keyword">return</span> s.toString();</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReverse</span><span class="params">()</span> </span>{</span><br><span class="line">		String str = <span class="string">"abcdefg"</span>;</span><br><span class="line">		String str1 = reverse3(str, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(str1);<span class="comment">// abfedcg</span></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第3题</span></span><br><span class="line">	<span class="comment">// 判断str2在str1中出现的次数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String mainStr, String subStr)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (mainStr.length() &gt;= subStr.length()) {</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// while((index = mainStr.indexOf(subStr)) != -1){</span></span><br><span class="line">			<span class="comment">// count++;</span></span><br><span class="line">			<span class="comment">// mainStr = mainStr.substring(index + subStr.length());</span></span><br><span class="line">			<span class="comment">// }</span></span><br><span class="line">			<span class="comment">// 改进：</span></span><br><span class="line">			<span class="keyword">while</span> ((index = mainStr.indexOf(subStr, index)) != -<span class="number">1</span>) {</span><br><span class="line">				index += subStr.length();</span><br><span class="line">				count++;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetCount</span><span class="params">()</span> </span>{</span><br><span class="line">		String str1 = <span class="string">"cdabkkcadkabkebfkabkskab"</span>;</span><br><span class="line">		String str2 = <span class="string">"ab"</span>;</span><br><span class="line">		<span class="keyword">int</span> count = getCount(str1, str2);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyTrim</span><span class="params">()</span> </span>{</span><br><span class="line">		String str = <span class="string">"   a   "</span>;</span><br><span class="line">		<span class="comment">// str = " ";</span></span><br><span class="line">		String newStr = myTrim(str);</span><br><span class="line">		System.out.println(<span class="string">"---"</span> + newStr + <span class="string">"---"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第4题</span></span><br><span class="line">	<span class="comment">// 如果只存在一个最大长度的相同子串</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMaxSameSubString</span><span class="params">(String str1, String str2)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (str1 != <span class="keyword">null</span> &amp;&amp; str2 != <span class="keyword">null</span>) {</span><br><span class="line">			String maxStr = (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">			String minStr = (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> len = minStr.length();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {<span class="comment">// 0 1 2 3 4 此层循环决定要去几个字符</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) {</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (maxStr.contains(minStr.substring(x, y))) {</span><br><span class="line"></span><br><span class="line">						<span class="keyword">return</span> minStr.substring(x, y);</span><br><span class="line">					}</span><br><span class="line"></span><br><span class="line">				}</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果存在多个长度相同的最大相同子串</span></span><br><span class="line">	<span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line">	<span class="keyword">public</span> String[] getMaxSameSubString1(String str1, String str2) {</span><br><span class="line">		<span class="keyword">if</span> (str1 != <span class="keyword">null</span> &amp;&amp; str2 != <span class="keyword">null</span>) {</span><br><span class="line">			StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">			String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">			String minString = (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> len = minString.length();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) {</span><br><span class="line">					String subString = minString.substring(x, y);</span><br><span class="line">					<span class="keyword">if</span> (maxString.contains(subString)) {</span><br><span class="line">						sBuffer.append(subString + <span class="string">","</span>);</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">				System.out.println(sBuffer);</span><br><span class="line">				<span class="keyword">if</span> (sBuffer.length() != <span class="number">0</span>) {</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			String[] split = sBuffer.toString().replaceAll(<span class="string">",$"</span>, <span class="string">""</span>).split(<span class="string">"\\,"</span>);</span><br><span class="line">			<span class="keyword">return</span> split;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 如果存在多个长度相同的最大相同子串：使用ArrayList</span></span><br><span class="line"><span class="comment">//	public List&lt;String&gt; getMaxSameSubString1(String str1, String str2) {</span></span><br><span class="line"><span class="comment">//		if (str1 != null &amp;&amp; str2 != null) {</span></span><br><span class="line"><span class="comment">//			List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line"><span class="comment">//			String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;</span></span><br><span class="line"><span class="comment">//			String minString = (str1.length() &gt; str2.length()) ? str2 : str1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			int len = minString.length();</span></span><br><span class="line"><span class="comment">//			for (int i = 0; i &lt; len; i++) {</span></span><br><span class="line"><span class="comment">//				for (int x = 0, y = len - i; y &lt;= len; x++, y++) {</span></span><br><span class="line"><span class="comment">//					String subString = minString.substring(x, y);</span></span><br><span class="line"><span class="comment">//					if (maxString.contains(subString)) {</span></span><br><span class="line"><span class="comment">//						list.add(subString);</span></span><br><span class="line"><span class="comment">//					}</span></span><br><span class="line"><span class="comment">//				}</span></span><br><span class="line"><span class="comment">//				if (list.size() != 0) {</span></span><br><span class="line"><span class="comment">//					break;</span></span><br><span class="line"><span class="comment">//				}</span></span><br><span class="line"><span class="comment">//			}</span></span><br><span class="line"><span class="comment">//			return list;</span></span><br><span class="line"><span class="comment">//		}</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		return null;</span></span><br><span class="line"><span class="comment">//	}</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetMaxSameSubString</span><span class="params">()</span> </span>{</span><br><span class="line">		String str1 = <span class="string">"abcwerthelloyuiodef"</span>;</span><br><span class="line">		String str2 = <span class="string">"cvhellobnmiodef"</span>;</span><br><span class="line">		String[] strs = getMaxSameSubString1(str1, str2);</span><br><span class="line">		System.out.println(Arrays.toString(strs));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第5题</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span> </span>{</span><br><span class="line">		String str = <span class="string">"abcwerthelloyuiodef"</span>;</span><br><span class="line">		<span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">		Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">		String newStr = <span class="keyword">new</span> String(arr);</span><br><span class="line">		System.out.println(newStr);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="19-StringBuffer和StringBuilder的介绍"><a href="#19-StringBuffer和StringBuilder的介绍" class="headerlink" title="19.StringBuffer和StringBuilder的介绍"></a>19.StringBuffer和StringBuilder的介绍</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_30.png" alt="String 的常用方法切割"></p>
<p>   String、StringBuffer、StringBuilder三者的异同？<br>    String:不可变的字符序列；底层使用char[]存储<br>    StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储<br>    StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_31.png" alt="String 的常用方法切割"></p>
<p>原字符上变</p>
<h2 id="20-StringBuffer的源码分析"><a href="#20-StringBuffer的源码分析" class="headerlink" title="20.StringBuffer的源码分析"></a>20.StringBuffer的源码分析</h2><p>  源码分析：<br>    String str = new String();//char[] value = new char[0];   length=0</p>
<p>​    String str1 = new String(“abc”);//char[] value = new char[]{‘a’,’b’,’c’};<br>​    StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。<br>​    System.out.println(sb1.length());//<br>​    sb1.append(‘a’);//value[0] = ‘a’;<br>​    sb1.append(‘b’);//value[1] = ‘b’;</p>
<p>​    StringBuffer sb2 = new StringBuffer(“abc”);//char[] value = new char[“abc”.length() + 16];</p>
<p>问题1. System.out.println(sb2.length());//3<br>    //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。<br>     默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。<br>     指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)<br>vlane&lt;&lt;1  == *2  append 多少次</p>
<h2 id="21-StringBuffer中的常用方法"><a href="#21-StringBuffer中的常用方法" class="headerlink" title="21.StringBuffer中的常用方法"></a>21.StringBuffer中的常用方法</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_32.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_33.png" alt="StringBuffer中的常用方法"></p>
<p>substring 需要返回值</p>
<p>setCharAt 指定字符改成新的</p>
<p>总结: 增删改查 插 长度 遍历</p>
<p>总结：<br>        增：append(xxx)<br>        删：delete(int start,int end)<br>        改：setCharAt(int n ,char ch) / replace(int start, int end, String str)<br>        查：charAt(int n )<br>        插：insert(int offset, xxx)<br>        长度：length();<br>        *遍历：for() + charAt() / toString()</p>
<h2 id="22-对比String、StringBuffer、StringBuilder三者的效率"><a href="#22-对比String、StringBuffer、StringBuilder三者的效率" class="headerlink" title="22.对比String、StringBuffer、StringBuilder三者的效率"></a>22.对比String、StringBuffer、StringBuilder三者的效率</h2><p>   从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   对比String、StringBuffer、StringBuilder三者的效率：</span></span><br><span class="line"><span class="comment">   从高到低排列：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="comment">//初始设置</span></span><br><span class="line">       <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">       <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">       String text = <span class="string">""</span>;</span><br><span class="line">       StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">       StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">       <span class="comment">//开始对比</span></span><br><span class="line">       startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) {</span><br><span class="line">           buffer.append(String.valueOf(i));</span><br><span class="line">       }</span><br><span class="line">       endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">"StringBuffer的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">       startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) {</span><br><span class="line">           builder.append(String.valueOf(i));</span><br><span class="line">       }</span><br><span class="line">       endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">"StringBuilder的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">       startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) {</span><br><span class="line">           text = text + i;</span><br><span class="line">       }</span><br><span class="line">       endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">"String的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="9-2-JDK8之前的日期时间API"><a href="#9-2-JDK8之前的日期时间API" class="headerlink" title="9.2 JDK8之前的日期时间API"></a>9.2 JDK8之前的日期时间API</h3><p>System静态方法、Date类、Calender类、SimpleDateFormat类</p>
<h2 id="23-System类中获取时间戳的方法"><a href="#23-System类中获取时间戳的方法" class="headerlink" title="23.System类中获取时间戳的方法"></a>23.System类中获取时间戳的方法</h2><p> <img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_34.png" alt="StringBuffer中的常用方法"></p>
<p> <img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_35.png" alt="StringBuffer中的常用方法"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.System类中的currentTimeMillis()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line">    <span class="comment">//称为时间戳</span></span><br><span class="line">    System.out.println(time);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="24-Java中两个Date类的使用"><a href="#24-Java中两个Date类的使用" class="headerlink" title="24.Java中两个Date类的使用"></a>24.Java中两个Date类的使用</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_36.png" alt="StringBuffer中的常用方法"></p>
<p> java.util.Date类<br>        |—java.sql.Date类</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.两个构造器的使用</span><br><span class="line">    &gt;构造器一：Date()：创建一个对应当前时间的Date对象</span><br><span class="line">    &gt;构造器二：创建指定毫秒数的Date对象</span><br><span class="line">2.两个方法的使用</span><br><span class="line">    &gt;toString():显示当前的年、月、日、时、分、秒</span><br><span class="line">    &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）</span><br><span class="line"></span><br><span class="line">3.java.sql.Date对应着数据库中的日期类型的变量</span><br><span class="line">    &gt;如何实例化</span><br><span class="line">    &gt;如何将java.util.Date对象转换为java.sql.Date对象</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_37.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_38.png" alt="StringBuffer中的常用方法"></p>
<p>情况一</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_40.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_41.png" alt="StringBuffer中的常用方法"></p>
<h3 id="9-3-JDK8中新日期时间API"><a href="#9-3-JDK8中新日期时间API" class="headerlink" title="9.3 JDK8中新日期时间API"></a>9.3 JDK8中新日期时间API</h3><p>LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter、其他类</p>
<h3 id="9-4-Java-比较器"><a href="#9-4-Java-比较器" class="headerlink" title="9.4 Java 比较器"></a>9.4 Java 比较器</h3><p>Comparable接口<br>Comparator接口</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>
    
    <div class="reward" ontouchstart>
    <div class="reward-wrap">赏
        <div class="reward-box">
            
            <span class="reward-type">
                <img class="alipay" src="https://img2020.cnblogs.com/blog/1508241/202005/1508241-20200519155417931-1887836889.jpg"><b>支付宝打赏</b>
            </span>
            
            
            <span class="reward-type">
                <img class="wechat" src="https://img2020.cnblogs.com/blog/1508241/202005/1508241-20200519155421281-200217015.jpg"><b>微信打赏</b>
            </span>
            
        </div>
    </div>
    <p class="reward-tip">
        一分一毛也是爱
    </p>
</div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Tony</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2017/07/04/2016-07-04-chang-yong-lei-date/" class="pre-post btn btn-default" title='常用类Date'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            常用类Date</span>
    </a>
    
    
    <a href="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/" class="next-post btn btn-default" title='多线程（补1）多'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            多线程（补1）多</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>

<script src="http://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'LWmP4tvyNOjV0hDcXSzBxE6c-gzGzoHsz',
    appKey: 'R7xHtkFCXCFDHvyOSB5h4YjG',
    placeholder: '说点什么吧',
    notify: true,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '5',
    path: window.location.pathname,
    lang: 'zh-CN'.toLowerCase()
})
</script>


</div>

                  
                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            大纲
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-每日一考"><span class="toc-text">1.每日一考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-生命周期与同步机制"><span class="toc-text">2.生命周期与同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程的同步机制"><span class="toc-text">线程的同步机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程通讯"><span class="toc-text">线程通讯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新特性"><span class="toc-text">新特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Java常用类的概述"><span class="toc-text">4.Java常用类的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-String类的概述"><span class="toc-text">5.String类的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-理解String-不可变性"><span class="toc-text">6.理解String 不可变性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-字符串相关的类"><span class="toc-text">9.1 字符串相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String的特性"><span class="toc-text">String的特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-不同实例化方式的对比"><span class="toc-text">7.不同实例化方式的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-String-不同拼接操作的对比"><span class="toc-text">8.String 不同拼接操作的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-String的一道面试题"><span class="toc-text">9.String的一道面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-JVM中设计字符串的内存结构"><span class="toc-text">10.JVM中设计字符串的内存结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-String-的常用方法1-3"><span class="toc-text">11. String 的常用方法1-3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-String与基本数据类型包装类的转换"><span class="toc-text">14.String与基本数据类型包装类的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-String与char-之间的转换"><span class="toc-text">15.String与char[]之间的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-解决一个拼接问题"><span class="toc-text">17.解决一个拼接问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-面试中String-算法考查说明"><span class="toc-text">18.面试中String 算法考查说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-StringBuffer和StringBuilder的介绍"><span class="toc-text">19.StringBuffer和StringBuilder的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-StringBuffer的源码分析"><span class="toc-text">20.StringBuffer的源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-StringBuffer中的常用方法"><span class="toc-text">21.StringBuffer中的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-对比String、StringBuffer、StringBuilder三者的效率"><span class="toc-text">22.对比String、StringBuffer、StringBuilder三者的效率</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-JDK8之前的日期时间API"><span class="toc-text">9.2 JDK8之前的日期时间API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-System类中获取时间戳的方法"><span class="toc-text">23.System类中获取时间戳的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-Java中两个Date类的使用"><span class="toc-text">24.Java中两个Date类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-JDK8中新日期时间API"><span class="toc-text">9.3 JDK8中新日期时间API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-Java-比较器"><span class="toc-text">9.4 Java 比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#"><span class="toc-text"></span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>


<script type="text/javascript" src="/js/love_mouse.js"></script>
<canvas id="canv" width="630" height="648" style="position: fixed; top: 0px; left: 0px; z-index: -2; opacity: 1.0;"></canvas>
 <script type="text/javascript" src="/js/jscartoon2.js"></script>  
<script type="text/javascript" src="/js/code/codeBlockFuction.js"></script>
<!-- 代码语言 -->
<script type="text/javascript" src="/js/code/codeLang.js"></script>
<!-- 代码块复制 -->
<script type="text/javascript" src="/js/code/codeCopy.js"></script>
<script type="text/javascript" src="/js/code/clipboard.min.js"></script>
<!-- 代码块收缩 -->
<script type="text/javascript" src="/js/code/codeShrink.js"></script> 
<!-- 代码块折行 -->
<style type="text/css">code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }</style>

    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
    访问量:
    <strong id="busuanzi_value_site_pv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    &nbsp; | &nbsp;
    访客数:
    <strong id="busuanzi_value_site_uv">
        <i class="fa fa-spinner fa-spin"></i>
    </strong>
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2015
                    
                </span> |
                <span>
                    Powered by <a href="//user.qzone.qq.com/943697678" class="copyright-links" target="_blank" rel="nofollow">QQ空间</a>
                </span> |
            
            </div>
        </div>
    </div>
</div>



<script src="/assets/tagcanvas.min.js?rev=2.9.js"></script>

<script>
var tagOption = {
    textColour: '#444', // 字体颜色
    outlineMethod: 'block', // 选中模式
    outlineColour: '#FFDAB9', // 选中模式的颜色
    interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
    textHeight: 13,
    outlineRadius: 3,
    freezeActive: true || '', // 选中的标签是否继续滚动
    frontSelect: true || '', // 不选标签云后部的标签
    initial: [0.1, -0.1],
    depth: 0.5,
    decel: 0.95,
    maxSpeed: 0.03,
    reverse: true || '', // 是否反向触发
    fadeIn: 500, // 进入动画时间
    wheelZoom: false || '' // 是否启用鼠标滚轮
}
TagCanvas.Start('tag-cloud-3d', '', tagOption);
</script>


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash.js"></script>





</body>
</html>