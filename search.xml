<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java的认识、Jdk、Java开发环境Eclipse的介绍</title>
    <url>/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/</url>
    <content><![CDATA[<h2 id="引言-为什么学习Java以及怎么学习Java"><a href="#引言-为什么学习Java以及怎么学习Java" class="headerlink" title="引言:为什么学习Java以及怎么学习Java"></a>引言:为什么学习Java以及怎么学习Java</h2><h3 id="1-认识Java"><a href="#1-认识Java" class="headerlink" title="1 认识Java"></a>1 认识Java</h3><h4 id="1-Java在公司里是用于干啥的-主要1和3"><a href="#1-Java在公司里是用于干啥的-主要1和3" class="headerlink" title="1. Java在公司里是用于干啥的?(主要1和3)"></a>1. Java在公司里是用于干啥的?(主要1和3)</h4><p>① Java web: 银行系统&amp;银行网站&amp;酒店系统&amp;N多后台管理系统&lt;-主要<br>② App: android是 用java写的，今年出了新的kotlin语言<br>③ 接口:为android、i0S等App提供数据访问接口 &lt;-主要<br>④ 大数据(马云说过“大”是计算的意思)<br>⑤ 桌面应用(比较少开发桌面应用)<br>⑥ ….</p>
<a id="more"></a>

<h4 id="2-Java的招聘需求及薪资"><a href="#2-Java的招聘需求及薪资" class="headerlink" title="2. Java的招聘需求及薪资"></a>2. Java的招聘需求及薪资</h4><p>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拉钩、Boss直聘等</p>
<h4 id="3-Java的职业规划发展方向"><a href="#3-Java的职业规划发展方向" class="headerlink" title="3. Java的职业规划发展方向"></a>3. Java的职业规划发展方向</h4><ol>
<li>首席java程序员</li>
<li>项目组组长:管理一个小团队</li>
<li>技术总监:主要把控项目中技术一块</li>
<li>软件系统架构师:负责整个项目的架构和技术实施方案（服务器 运维 并发  5年）</li>
<li>技术合伙人:公司的技术一把手，以技术来占公司股份，不需要花钱买（以技术入股）</li>
<li>软件营销:成为一个软件方面的销售高手</li>
<li>当IT讲师:传授你的工作经验</li>
<li>创业:与其他好友同事创业，开自己的公司，接外包或者做自己的产品</li>
<li>赚得一-定财富后，回老家开小店过小日子   (年薪20万，要有副业)</li>
</ol>
<h4 id="4-Java的就业前景和形势"><a href="#4-Java的就业前景和形势" class="headerlink" title="4. Java的就业前景和形势"></a>4. Java的就业前景和形势</h4><ol>
<li>领域非常广<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java技术具有卓越的通用性、高效性、平台移植性和安全性，广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，所以说Java的应用领域非常广，同时拥有全球最大的开发者专业社群</li>
<li>需求量大<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java是全球最流行的开发语言，我国的软件开发人才极为缺乏，其中java人才缺口最大，对java软件工程师的需求达到全部需求量的60% -70%，Java又 是安卓开发的基础，所以人才的需求又增加一大波。</li>
<li>就业方向非常广<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;学完可应聘java\h5\android\大数据架构师等职位。。。<br>Java是一一门世界最好的语言，学会了Java再学习其它语言php, ios, python等非常容易上手<br>一个星期或者半个月就可以做项目<br>总结:学了Java,你可以在招聘网上投递的职位非常多——–需求量巨大</li>
</ol>
<h4 id="5-Java的学习方法和建议"><a href="#5-Java的学习方法和建议" class="headerlink" title="5.  Java的学习方法和建议"></a>5.  Java的学习方法和建议</h4><ol>
<li>跟着上课老师的课程大纲学习，掌握课堂知识点。</li>
<li>勤做笔记，如果上课走神或者没听懂的知识点，记下时间，再倒回去看视频。</li>
<li>复习时看视频，尽量1.5~2倍来看视频,课后多练代码。   写多了  就理解多了</li>
<li>尽量老师一边讲课，同学们一边写代码，当场掌握知识点。</li>
<li>不懂的多问老师与同学，因为毕业后，不一定才能能及时帮到你。</li>
<li>要有自己的思维，做一个功能或者需求时，想想有没有另一种方法。</li>
<li>多与同班同学交流，丰富情感生活，以后好互相推荐工作。</li>
<li>脑子累了要休息，尽量不要晚上通宵写代码，身体要紧。</li>
<li>每周或者两周要去参加一个活动,集体打球。</li>
<li>还有一点是学程序开发，有时是枯澡无味的，要忍住无聊和寂寞，特别是Java基础</li>
</ol>
<h4 id="6-学习前要谨记一些心态"><a href="#6-学习前要谨记一些心态" class="headerlink" title="6.  学习前要谨记一些心态"></a>6.  学习前要谨记一些心态</h4><ul>
<li>只要努力掌握课堂知识和老师的建议再加上自己的信心，找份较满意工资的工作是没有问题</li>
<li>一个班不可能每个都拿高薪，工资高的不一定是知识掌握的最好的那位同学。有时高薪看天时地利人和</li>
<li>学习Java找工作，只是你的一一个起点，以后你还会学习其它的语言，或者说不干程序员这份<br>工作也说不定。(sina- 程序员辞职卖水果)</li>
<li>只要学精一门语言，不用怕以后这门语言不值钱，不用怕以后找不到工作。经验是最值钱的</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对自己要有信心&amp;工资量&amp;打牢固<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公司看中经验</p>
<hr>
<h3 id="2-计算机基础-amp-DOS"><a href="#2-计算机基础-amp-DOS" class="headerlink" title="2 计算机基础&amp;DOS"></a>2 计算机基础&amp;DOS</h3><h4 id="1-计算机简介"><a href="#1-计算机简介" class="headerlink" title="1. 计算机简介:"></a>1. 计算机简介:</h4><ul>
<li>计算机(computer) 俗称电脑，是现代一种用于高速计算的电子计算机器，是能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。</li>
<li>计算机由硬件系统和软件系统所组成，没有安装任何软件的计算机称为裸机。</li>
<li>计算机可分为超级计算机、工业控制计算机、网络计算机、个人计算机、嵌入式计算机五类，较先进的计算机有生物计算机、光子计算机、量子计算机等。</li>
<li>计算机发明者约翰.冯，诺依曼。计算机是20世纪最先进的科学技术发明之一</li>
<li>计算机的硬件分成5大组成部件:运算器、控制器、存储器、输入设备和输出设备。<ul>
<li>运算器、控制器合称为中央处理单元(Central ProcessingUnit, CPU)或处理器</li>
<li>存储器分为:<br>内部存储器(内存条) -重启电脑数据不在<br> 外部存储器(U盘、硬盘)-重启电脑数据还在</li>
<li>输入设备有键盘、 鼠标等</li>
<li>输出设备有显示器、打印机等</li>
</ul>
</li>
</ul>
<h4 id="2-计算机的操作系统"><a href="#2-计算机的操作系统" class="headerlink" title="2. 计算机的操作系统"></a>2. 计算机的操作系统</h4><ul>
<li>操作系统(Operating System, 简称0S)是管理和控制计算机硬件与软件资源的<br>计算机程序，是直接运行在”裸机”上的最基本的系统软件，任何其他软件都必<br>须在操作系统的支持下才能运行。</li>
<li>常见的操作系统: Windows/Linux/MacOS/ Android/ iOS</li>
</ul>
<h4 id="3-计算机软件概念"><a href="#3-计算机软件概念" class="headerlink" title="3. 计算机软件概念"></a>3. 计算机软件概念</h4><ul>
<li>软件(中国大陆及香港用语，台湾称作软体，英文: Software)   App</li>
<li>软件是一系列按照特定顺序组织的计算机数据和指令的集合。</li>
<li>一般来讲软件被划分为<code>系统软件、应用软件</code>和介于这两者之间的中间件。</li>
<li>系统软件:Windows/Linux/macOS/ Android/i0S</li>
<li>应用软件:QQ、WeChat、浏览器、迅雷、后台系统等…</li>
</ul>
<h4 id="4-软件开发的概念"><a href="#4-软件开发的概念" class="headerlink" title="4. 软件开发的概念"></a>4. 软件开发的概念</h4><h5 id="4-1-什么是软件开发"><a href="#4-1-什么是软件开发" class="headerlink" title="4.1 什么是软件开发"></a>4.1 什么是软件开发</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助开发工具与计算机语言制作软件</p>
<h5 id="4-2-什么是计算机语言"><a href="#4-2-什么是计算机语言" class="headerlink" title="4.2 什么是计算机语言"></a>4.2 什么是计算机语言</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;人与计算机之间进行信息交流沟通的一种特殊语言</p>
<h5 id="4-3-计算机语言的分类"><a href="#4-3-计算机语言的分类" class="headerlink" title="4.3 计算机语言的分类"></a>4.3 计算机语言的分类</h5><ul>
<li>机器语言:<br>机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。</li>
<li>汇编语言:<br>汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。</li>
<li>高级语言:<br>使用普通英语进行编写源代码，通过<code>编译器</code>将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。高级语言包括C,C++, C#, JAVA，PHP, Python</li>
</ul>
<h4 id="5-DOS命令"><a href="#5-DOS命令" class="headerlink" title="5. DOS命令"></a>5. DOS命令</h4><p>​        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOS (<code>磁盘操作系统</code>)命令，是DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。常用命令如下:</p>
<h5 id="1-查看目录内容命令dir"><a href="#1-查看目录内容命令dir" class="headerlink" title="1. 查看目录内容命令dir"></a>1. 查看目录内容命令<code>dir</code></h5><p>   <img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_1.png" alt="dir"></p>
<h5 id="2-打开指定目录命令-语法-cd路径"><a href="#2-打开指定目录命令-语法-cd路径" class="headerlink" title="2. 打开指定目录命令[语法: cd路径]"></a>2. 打开指定目录命令[语法: cd路径]</h5><p>   拖拽可以获取文件名</p>
<p>   2.1 同盘下(切换路径)</p>
<p>   <img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_2.png" alt="cd 文件名"></p>
<p>   2.2 异盘下(切换到D盘)</p>
<p>   <img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_3.png" alt="d:"></p>
<p>   2.3 特殊用法 ;返回当前盘的根路径</p>
<p>   <img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_4.png" alt="cd /"></p>
<p>​    2.4 返回上一级目录</p>
<p><img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_15.png" alt="cd .."></p>
<h5 id="3-创建目录命令-语法-md-文件夹名字-—mkdir-dir"><a href="#3-创建目录命令-语法-md-文件夹名字-—mkdir-dir" class="headerlink" title="3. 创建目录命令[语法:md 文件夹名字]  —mkdir dir"></a>3. 创建目录命令[语法:<code>md 文件夹名字</code>]  —mkdir dir</h5><h5 id="4-删除当前指定的目录-语法-rd-路径-–remove-123"><a href="#4-删除当前指定的目录-语法-rd-路径-–remove-123" class="headerlink" title="4. 删除当前指定的目录[语法:rd 路径]   –remove 123"></a>4. 删除当前指定的目录[语法:<code>rd 路径</code>]   –remove 123</h5><h5 id="5-创建文件-echo-a-gt-a-txt"><a href="#5-创建文件-echo-a-gt-a-txt" class="headerlink" title="5. 创建文件 echo a> a.txt"></a>5. 创建文件 <code>echo a&gt; a.txt</code></h5><h5 id="6-文件复制命令-语法-copy-源文件路径-目标文件路径"><a href="#6-文件复制命令-语法-copy-源文件路径-目标文件路径" class="headerlink" title="6. 文件复制命令[语法: copy 源文件路径 目标文件路径]"></a>6. 文件复制命令[语法: <code>copy 源文件路径 目标文件路径</code>]</h5><p><img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_5.png" alt="copy"></p>
<p>   执行效果相同</p>
<h5 id="7-显示文本文件内容命令-语法-type-文件名"><a href="#7-显示文本文件内容命令-语法-type-文件名" class="headerlink" title="7. 显示文本文件内容命令[语法: type 文件名]"></a>7. 显示文本文件内容命令[语法: <code>type 文件名</code>]</h5><h5 id="8-更改文件名命令-语法-ren-a-txt-a1-txt"><a href="#8-更改文件名命令-语法-ren-a-txt-a1-txt" class="headerlink" title="8. 更改文件名命令[语法: ren a.txt a1.txt]"></a>8. 更改文件名命令[语法: <code>ren a.txt a1.txt</code>]</h5><h5 id="9-删除文件命令-语法-del-a-txt-a1-txt-note-stuck-out-tongue-同时删除2个"><a href="#9-删除文件命令-语法-del-a-txt-a1-txt-note-stuck-out-tongue-同时删除2个" class="headerlink" title="9. 删除文件命令[语法: del a.txt a1.txt]  note :stuck_out_tongue:  同时删除2个"></a>9. 删除文件命令[语法: <code>del a.txt a1.txt</code>]  note <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8">😛</span>  同时删除2个</h5><h5 id="10-清除屏幕命令-cls"><a href="#10-清除屏幕命令-cls" class="headerlink" title="10. 清除屏幕命令 cls"></a>10. 清除屏幕命令 <code>cls</code></h5><h5 id="11-查看环境变量path-or-echo-path"><a href="#11-查看环境变量path-or-echo-path" class="headerlink" title="11. 查看环境变量path  or  echo %path%"></a>11. 查看环境变量<code>path</code>  or  echo %path%</h5><p>快捷键:</p>
<p>win+e 文件资源管理器 </p>
<p>win+r 命令行</p>
<p>win+q 搜索框</p>
<p>win+i win设置</p>
<hr>
<h3 id="3-Java-开发环境的准备"><a href="#3-Java-开发环境的准备" class="headerlink" title="3.Java 开发环境的准备"></a>3.Java 开发环境的准备</h3><h4 id="1-Java语言发展史"><a href="#1-Java语言发展史" class="headerlink" title="1. Java语言发展史"></a>1. Java语言发展史</h4><ul>
<li>詹姆斯.高斯林(James Gosling) 1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得 了<code>美国卡内基梅隆大学</code>计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统， 但不受重视。后来转至Sun公司，1990年， 与Patrick, Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak” ，后改名为Java。</li>
<li>SUN (Stanford Uni versity Network, 斯坦福大学网络公司)</li>
<li>卡内基梅隆大学截至2017年卡耐基梅隆大学共培养出了12个图灵奖，20个诺贝尔奖，9个奥斯卡，114个艾米奖，44个托尼奖，非常牛逼的大学。</li>
<li>Java是一 门软件编程语言，可编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等</li>
<li>早期Sun公司研发 人员对C++进行改造，开发了一种称为Oak的面向对象语言</li>
<li>1995年，Sun公司将Oak更名为Java</li>
<li>1996年，Sun公司发布了Java的第一个开发工具包(JDK1.0)</li>
<li>1998年，第二代Java平台的企业版J2EE发布</li>
<li>1999年公司发布了第二代Java平台(简称为Java2)的3个版本<br>J2ME (Java2 Micro Edition, Java2平 台的微型版)，应用于移动、无线及有限资源的环境;<br>J2SE (Java 2 Standard Edition, Java 2平台的标准版)，应用于桌面环境;<br>J2EE (Java 2Enterprise Edition, Java 2平台的企业版)，应用于基于Java的应用服务器。</li>
<li>Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。</li>
<li>2009年，甲骨文公司宣布收购Sun。</li>
<li>2010年，Java编程语言的共同创始人之一詹姆斯.高斯林(Java之父)从Oracle公司辞职。</li>
<li>2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。</li>
<li>2014年，甲骨文公司发布了Java8正式版。</li>
<li>2017年，甲骨文公司发布了Java9</li>
</ul>
<h4 id="2-Java语言版本"><a href="#2-Java语言版本" class="headerlink" title="2. Java语言版本"></a>2. Java语言版本</h4><p>   <img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_6.png" alt="Java语言版本"></p>
<p>老版本稳定，追求稳定</p>
<h4 id="3-Java语言特点"><a href="#3-Java语言特点" class="headerlink" title="3. Java语言特点"></a>3. Java语言特点</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单性、解释性、<code>面向对象</code>、<code>高性能</code>、分布式处理、多线程、健壮性、动态性、<code>安全性</code>、<code>跨平台</code>、移植性<br>注:这是一道笔记题，需要记住</p>
<h4 id="4-Java语言跨平台原理"><a href="#4-Java语言跨平台原理" class="headerlink" title="4. Java语言跨平台原理"></a>4. Java语言跨平台原理</h4><h5 id="4-1-什么是跨平台性"><a href="#4-1-什么是跨平台性" class="headerlink" title="4.1 什么是跨平台性"></a>4.1 什么是跨平台性</h5><blockquote>
<p>开发的软件,在任何操作系统(mac/window/linux)上都能安装并运行</p>
</blockquote>
<h5 id="4-2-Java语言跨平台原理"><a href="#4-2-Java语言跨平台原理" class="headerlink" title="4.2 Java语言跨平台原理"></a>4.2 Java语言跨平台原理</h5><blockquote>
<p>只要在需要运行Java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。</p>
</blockquote>
<h5 id="4-3-Java语言跨平台图解"><a href="#4-3-Java语言跨平台图解" class="headerlink" title="4.3 Java语言跨平台图解"></a>4.3 Java语言跨平台图解</h5><p><img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_7.png" alt="Java语言跨平台图解"></p>
<h5 id="4-4-write-once-，run-anywhere-一处编译-到处运行"><a href="#4-4-write-once-，run-anywhere-一处编译-到处运行" class="headerlink" title="4.4 write once ，run anywhere!(一处编译,到处运行)"></a>4.4 write once ，run anywhere!(一处编译,到处运行)</h5><h4 id="5-JRE和JDK的概述"><a href="#5-JRE和JDK的概述" class="headerlink" title="5. JRE和JDK的概述"></a>5. JRE和JDK的概述</h4><h5 id="5-1-什么是JRE-Java-Runtime-Environment"><a href="#5-1-什么是JRE-Java-Runtime-Environment" class="headerlink" title="5.1 什么是JRE (Java Runtime Environment)"></a>5.1 什么是JRE (Java Runtime Environment)</h5><ul>
<li>JRE包括Java虛拟机(JVM Java Virtual Machine)和Java程序所需的核心类库(jar 包)等</li>
<li>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。（java2jar）</li>
<li>总的说JRE = JVM +核心类库</li>
</ul>
<h5 id="5-2-什么是JDK-Java-Development-Kit"><a href="#5-2-什么是JDK-Java-Development-Kit" class="headerlink" title="5.2 什么是JDK (Java Development Kit)"></a>5.2 什么是JDK (Java Development Kit)</h5><ul>
<li>JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。</li>
<li><code>所以安装了JDK,就不用在单独安装JRE了</code>。</li>
<li>java的开发工具有:<code>编译工具(javac)</code>、 <code>打包工具(jar)</code>等</li>
<li>JDK=JRE+JAVA的开发工具。</li>
<li>JDK=JVM+核心类库+ Java开发工具(javac, jar..)</li>
</ul>
<h5 id="5-3-JDK-JRE-JVM的作用和关系"><a href="#5-3-JDK-JRE-JVM的作用和关系" class="headerlink" title="5.3 JDK, JRE, JVM的作用和关系"></a>5.3 JDK, JRE, JVM的作用和关系</h5><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JDK包含JRE，而JRE包含JVM， 总的来说JDK是用于java程序的开发，而jre则是只能运行class而没有编译的功能，最后用张网络图片总结下<br> <img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_8.png" alt="jdk和jre"></p>
<ul>
<li>总结:<br>JDK:主要用于编译<br>JRE:主要作用看运行效果<br>JVM:主要作用跨平台，负责Java程序的调用</li>
</ul>
<h4 id="6-JDK的下载和安装过程图解"><a href="#6-JDK的下载和安装过程图解" class="headerlink" title="6. JDK的下载和安装过程图解"></a>6. JDK的下载和安装过程图解</h4><h5 id="6-1-JDK的下载地址"><a href="#6-1-JDK的下载地址" class="headerlink" title="6.1 JDK的下载地址"></a>6.1 JDK的下载地址</h5><ul>
<li>官方下载地址<code>https://www.oracle.com/java/technologies/javase-downloads.html</code></li>
<li>Sun被oracle收购，地址都可以，访问sun会跳转到oracle</li>
</ul>
<h5 id="6-2-JDK的安装"><a href="#6-2-JDK的安装" class="headerlink" title="6.2 JDK的安装"></a>6.2 JDK的安装</h5><ul>
<li><p>下载对应操作系统平台的JDK,这里下载1.8的windows平台然后傻瓜式安装，下一步,下一步验证安装是否成功</p>
</li>
<li><p>如果安装 了JDK, JDK的安装路径在<code>C: \Program Files\Java\jdk1.8.0_ 131</code>路径下</p>
</li>
<li><p>在cmd中可以输入java -version来查看jdk的版本</p>
</li>
</ul>
<p>说明:可安装共存:  如1.7和 1.8 共存</p>
<h4 id="7-JDK的删除和自定义安装路径"><a href="#7-JDK的删除和自定义安装路径" class="headerlink" title="7. JDK的删除和自定义安装路径"></a>7. JDK的删除和自定义安装路径</h4><ol>
<li>删除JDK不能直接把Java的home目录文件夹删除了，这种操作是不正确</li>
<li>正确的删除JDK是要来到 “ 控制面板\所有控制面板项\程序和功能”进行删除，</li>
<li>JDK安装路径可以自己定义，个人喜好，我就不喜欢改。</li>
<li>什么时候需要更改jdk的安装路径<br>■当默认的c盘没有空间的时候，可以改成D盘<h4 id="8-JDK安装路径下的目录解释"><a href="#8-JDK安装路径下的目录解释" class="headerlink" title="8. JDK安装路径下的目录解释"></a>8. JDK安装路径下的目录解释</h4></li>
</ol>
<ul>
<li>在jdk的Home中，会有如下图的结构<br><img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_9.png" alt="JDK的目录"><ul>
<li>Home 目录路径C: \Program Fi les\JavaXjdk1.8.0131,又称jdk主目录<ul>
<li>bin:该目录用于存放一些可执行程序，如javac ( java编译器)、java(java运行 工具)，jar(打包工具)和javadoc(文档生成工具)等</li>
<li>db:db目录是一个小型的数据库，从JDK 6. 0开始，Java中引用了一个新的成员JavaDB, 这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4. 0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。</li>
<li>jre: “jre”是Java Runt ime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及-个bin目录，但不包含开发环境中的开发工具。</li>
<li>include: 由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。</li>
<li>1ib: 1ib是library的缩写， 意为Java 类库或库文件，是开发工具使用的归档包文件。</li>
<li>src. zip文件: src. zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码， 通过该文件可以查看Java基础类的源代码。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-第一个Java程序，-Hel-loWorld案例的编写与编译-命令行方式"><a href="#9-第一个Java程序，-Hel-loWorld案例的编写与编译-命令行方式" class="headerlink" title="9.第一个Java程序， Hel loWorld案例的编写与编译(命令行方式)"></a>9.第一个Java程序， Hel loWorld案例的编写与编译(命令行方式)</h4><ul>
<li><p>编写Java源代码，以.java结尾<br><img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_10.png" alt="HelloWorld 代码"></p>
</li>
<li><p>打开终端cmd,进入到jdk的bin目录，cd “C:\ Program Files\Java\jdk1.8.0_ 131\bin”</p>
</li>
<li><p>编译java文件，终端中输入javac HelloWorld.java的全路径</p>
</li>
<li><p>执行class文件,终端输入java HelloWorld,不需要加.class后缀<br>Java程序运行流程[记住]<br>① 编写java文件<br>② 编译java文件，获得一个.class文件<br>③ 运行.class文件 看到效果</p>
</li>
<li><p>遇到问题</p>
<p><img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_11.png" alt="需要注意的问题"></p>
</li>
</ul>
<h4 id="10-Javac-amp-Java命令执行的路径"><a href="#10-Javac-amp-Java命令执行的路径" class="headerlink" title="10. Javac&amp;Java命令执行的路径"></a>10. Javac&amp;Java命令执行的路径</h4><ul>
<li>Javac是一个将. java编译成. class文件命令</li>
<li>javac命令的具体路径是C: \Program Files\Java\jdk1. 8.0_ 131bin</li>
<li>在终端cmd输入java - version, Java的命令执行的路径是在Path的<br>C: \ProgramData \Oracle\Java\javapath</li>
<li>如果在命令行执行javac HelloWorld. java 返回‘javac’ 不是内部或外部命令，也不是可运行的程序，或批处理文件。说明在当前路径找不到Javac命令</li>
</ul>
<h4 id="11-Java环境变量Path配置"><a href="#11-Java环境变量Path配置" class="headerlink" title="11. Java环境变量Path配置"></a>11. Java环境变量Path配置</h4><ul>
<li>目的: 不需要进入到bin目录，也可执行bin目录下的命令javac</li>
<li>方法步骤- windows10的操作:</li>
</ul>
<ol>
<li>点击:此电脑-右键属性-高级系统设置-高级-环境变量</li>
<li>在系统变量中新建JAVA_ HOME=C: \Program Files\Java\jdk1.8.0_ 131</li>
<li>在系统变量中编辑Path,在后面追加路径%JAVA_ HOME%\bin (注:是右斜杠)</li>
<li>在命令行可以输入echo %JAVA HOME%\bin 来查看环境变量</li>
</ol>
<ul>
<li>通过上面的努力， 你就可以在任意目录编译. java文件了<br>MacOs：  .bash_profile</li>
</ul>
<h4 id="12-CLASSPATH变量配置"><a href="#12-CLASSPATH变量配置" class="headerlink" title="12. CLASSPATH变量配置"></a>12. CLASSPATH变量配置</h4><ul>
<li>JVM在 查找class文件时如果没有设置classpath会在当前路径查找，设置classpath后<code>仅在classpath路径下</code>查找class文件即可。</li>
<li>classpath 不是必须配置的</li>
<li>一旦修改了环境变量的东西，一定要重新启动所有cmd命令行<br>echo %classpath%</li>
</ul>
<hr>
<h3 id="4-Java开发工具Eclipse"><a href="#4-Java开发工具Eclipse" class="headerlink" title="4. Java开发工具Eclipse"></a>4. Java开发工具Eclipse</h3><h4 id="1-常用的Java-IDE开发工具"><a href="#1-常用的Java-IDE开发工具" class="headerlink" title="1. 常用的Java IDE开发工具"></a>1. 常用的Java IDE开发工具</h4><ul>
<li>为什么会有Java IDE开发工具，如果像以前那样在终端通过命令行来编译执行java文件，一旦<br>文件比较多，是件多么折腾的一件事。所以有很多开发工具，来简化我们的开发工作。</li>
<li>集成开发环境(IDE， Integrated Deve lopment Environment )是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和GUI等工具。</li>
<li>常见的Java开发工具有，工作中掌握Eclipse即可<br>①Editplus 少<br>②Sublime Text  少<br>③Eclipse (工作中常用，200多M)  免费<br>④MyEclipse(至 少1G)<br>⑤IntelliJ IDEA (500多M)  多</li>
<li>注:掌握了Eclipse, MyEclipse, IDEA也自然会用，因为他们长的差不多</li>
</ul>
<h4 id="2-Eclipse历史版本-Neon"><a href="#2-Eclipse历史版本-Neon" class="headerlink" title="2. Eclipse历史版本  Neon"></a>2. Eclipse历史版本  Neon</h4><p> <img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_12.png" alt=" Eclipse历史版本"></p>
<h4 id="3-Eclipse的下载与安装"><a href="#3-Eclipse的下载与安装" class="headerlink" title="3. Eclipse的下载与安装"></a>3. Eclipse的下载与安装</h4><ul>
<li>进入eclipse的 下载页面<code>https://www.eclipse.org/downloads/packages/</code></li>
<li>然后在页面中，选择红色框的下载，下载后得到一个eclipse-jee neon-3-win32-<br>x86_ 64.zip文 件</li>
<li>然后解压zip,直接点击解压后文件夹中的eclipse.exe即可使用 -&gt;发送快捷方式</li>
</ul>
<p>注意:下载Eclipse-Neon的版本，一定要安装jdk1.8<br>  现在最新版本是eclipse-jee -oxygen-1a-win32 x86_ 64.zip [oxygen:氧气 ]<br>  建议项目名格式 wzq_day01_20170206</p>
<h4 id="3-Eclipse的区域与字体调整"><a href="#3-Eclipse的区域与字体调整" class="headerlink" title="3. Eclipse的区域与字体调整"></a>3. Eclipse的区域与字体调整</h4><p> <img src="/2017/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_14.png" alt="Eclipse的区域"></p>
<ul>
<li>调整Eclipse的字体大小<ul>
<li>第一种方式:<ul>
<li>点击Eclipse的Window Prefernces偏好设置，</li>
<li>找到General-Appearance Colors and Fonts. 再找到Basic </li>
<li>然后点击Text Font来 调字体大小</li>
</ul>
</li>
<li>第二种方式:<ul>
<li>neon<br>版本的eclipse可以通过[ctrl +、-]来更改文字大小<br>注:有些旧版本不支持这种方式，所以只能使用第一种</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-项目的导入和删除"><a href="#4-项目的导入和删除" class="headerlink" title="4.项目的导入和删除"></a>4.项目的导入和删除</h4><p>Project Explorer 下 选择 import -&gt;General-&gt;Existing Projects into Workspace<br>注释 ctrl+shift+/<br>ctrl+/</p>
<h1 id="结束！-撒花"><a href="#结束！-撒花" class="headerlink" title="结束！ 撒花"></a>结束！ 撒花</h1><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>DOS命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系列安装SQLServer2012</title>
    <url>/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/</url>
    <content><![CDATA[<p>安装环境: win10 1803</p>
<p>软件版本:cn_sql_server_2012_enterprise_edition_with_sp1_x64_dvd_1234495</p>
<p>要求：安装的空间要预留出10G</p>
<p>sql_server 按照以下每一步就能安装成功</p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_01" alt="1590812080676"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_02" alt="1590812166876"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_03" alt="1590812282895"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_04" alt="1590812312886"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_05" alt="1590812350402"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_06" alt="1590812377347"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_07" alt="1590812409559"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_08" alt="1590821992903"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_09" alt="1590822030514"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_10" alt="1590822087118"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_11" alt="1590822159752"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_12" alt="1590822297587"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_13" alt="1590822422008"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_14" alt="1590822545067"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_15" alt="1590822582453"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_16" alt="1590822633384"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_17" alt="1590822694133"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_18" alt="1590822743653"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_19" alt="1590822775266"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_20" alt="1590836379099"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_21" alt="1590836492372"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_22" alt="1590845366207"></p>
<p><img src="/2020/05/31/windows-xi-lie-an-zhuang-sqlserver2012/sql_23" alt="1590845382636"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Windows的常用命令</title>
    <url>/2020/05/31/windows-de-chang-yong-ming-ling/</url>
    <content><![CDATA[<p>关闭防火墙 control.exe /name microsoft.windowsfirewall<br>网络连接 ncpa.cpl<br>网络配置 control.exe /name Microsoft.NetworkAndSharingCenter<br>ren * *.jpg<br>远程连接 mstsc<br>计算器  calc<br>查看系统版本 winver<br>查看系统运行时间 systeminfo<br>打开系统配置  msconfig<br>打开控制面板control<br>打开文件资源管理器 windows+E  explorer<br>打开D盘 start D:<br>回到桌面快捷键  Win +D </p>
<hr>
<ol>
<li>d: 回车 盘符切换</li>
<li>dir(directory):列出当前目录下的文件及文件夹</li>
<li>md(make directory):创建目录</li>
<li>rd(remove directory):删除目录</li>
<li>cd(change directory):改变指定目录（进入指定目录）</li>
<li>cd..:退出到上一级目录</li>
<li>cd:退出到根目录</li>
<li>del(delete):删除文件，删除一堆后缀名一样的文件*.txt</li>
<li>exit:退出doc命令</li>
<li>cls:(clean screen)清屏</li>
</ol>
<p>dir /S   // 递归显示当前目录中的内容<br>tree<br>md movie music  // 在当前目录中创建名为movie和music的文件夹<br>copy key.txt c:\doc  // 将当前目录下的key.txt拷贝到c:\doc下（若doc中也存在一个key.txt文件，会询问是否覆盖）<br>move *.png test  // 将当前目录下的png图片移动到当前目录下test文件夹中 （若test中也存在同名的png图片，会询问是否覆盖）</p>
<p>type 显示文本文件内容</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>Ubuntu1810下安装MySQL</title>
    <url>/2018/12/02/2018-12-02-ubuntu1810-xia-an-zhuang-mysql/</url>
    <content><![CDATA[<p>版本:Ubuntu 1810<br>1.切换为root,下载并安装SQL服务器</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">q@q-virtual-machine:~$ su root</span><br><span class="line">密码： </span><br><span class="line">root@q-virtual-machine:/home/q# wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb</span><br><span class="line">root@q-virtual-machine:/home/q# dpkg -i mysql-apt-config_0.8.10-1_all.deb </span><br><span class="line">root@q-virtual-machine:/home/q# sudo apt update</span><br><span class="line">root@q-virtual-machine:/home/q# apt-get install mysql-server mysql-client libmysqlclient-dev</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105011139162-1649051620.png" alt=""></p>
<p>查看是否安装成功</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/home/q# systemctl status mysql</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105011421419-1161754551.png" alt=""></p>
<p>遇到错误不紧张:<br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105103412302-844933723.png" alt=""><br>重启</p>
<p>2.修改配置<br>设置远程访问及修改密码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/home/q# mysql </span><br><span class="line">mysql&gt; use mysql;select user, plugin from user;</span><br><span class="line">mysql&gt; update user set authentication_string=password("2557"),plugin='mysql_native_password' where user='root';</span><br><span class="line">mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '456';</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></tbody></table></figure>

<p>一条语句版:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt;use mysql;select user, plugin from user;update user set authentication_string=password("2557"),plugin='mysql_native_password' where user='root';grant all privileges on *.* to 'root'@'%' identified by '456';flush privileges;commit;</span><br></pre></td></tr></tbody></table></figure>

<p>远程登录密码是456<br>本地是2557<br>更改的是本地密码  mysql&gt; set password=password(‘123’);和2557是同等功效<br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105011734978-2032220959.png" alt=""><br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105102305276-1714387986.png" alt=""></p>
<p>&amp;%只在远端登录(可不做  知识扩充)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/home/q# vi  /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">注释掉  #bind-address           = 127.0.0.1</span><br><span class="line"></span><br><span class="line">root@q-virtual-machine:/etc/mysql/mysql.conf.d# mysql </span><br><span class="line">mysql&gt; use mysql </span><br><span class="line">mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '456';</span><br><span class="line">mysql&gt; flush privileges;commit;</span><br><span class="line">q@q-virtual-machine:~$ sudo systemctl restart mysql.service</span><br><span class="line">远端可以使用  密码456</span><br><span class="line">本地登录依然不需要密码</span><br></pre></td></tr></tbody></table></figure>

<p>3.注释掉(要以root权限打开)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/home/q# cd  /etc/mysql/mysql.conf.d/</span><br><span class="line">root@q-virtual-machine:/etc/mysql/mysql.conf.d# vi mysqld.cnf</span><br><span class="line">注释掉</span><br><span class="line">#bind-address           = 127.0.0.1</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105012146046-1207685549.png" alt=""><br>远端登录成功<br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105111337829-834142522.png" alt=""></p>
<p>4.设置utf-8字符集</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/etc/mysql/mysql.conf.d# sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"></span><br><span class="line">lc-messages-dir	= /usr/share/mysql</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105013641674-858490908.png" alt=""></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/etc/mysql/mysql.conf.d# gedit /etc/mysql/conf.d/mysql.cnf</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105013901523-174469967.png" alt=""></p>
<p>查看效果</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE 'char%';</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105014036031-663821687.png" alt=""></p>
<h1 id="shell脚本-配置ubuntu-3步"><a href="#shell脚本-配置ubuntu-3步" class="headerlink" title="shell脚本   配置ubuntu   3步"></a>shell脚本   配置ubuntu   3步</h1><p>1.t.shell</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 注释 文件复制 用于配置字符集utf-8和远端登录</span><br><span class="line">cp  t1.cnf  /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">cp  t3.cnf  /etc/mysql/conf.d/mysql.cnf</span><br><span class="line"># 设置本地密码2557  开启远端密码456 刷新权限</span><br><span class="line">mysql "mysql" -e"update user set authentication_string=password('2557'),plugin='mysql_native_password' where user='root';grant all privileges on *.* to 'root'@'%' identified by '456';flush privileges;commit;"</span><br><span class="line">echo "everything is ok"</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart mysql.service</span><br><span class="line">systemctl enable mysql.service</span><br><span class="line"># 查看字符集utf-8</span><br><span class="line">mysql -uroot -p2557 -e"SHOW VARIABLES LIKE 'char%';"</span><br></pre></td></tr></tbody></table></figure>

<p>2.t1.cnf</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># The MySQL database server configuration file.</span><br><span class="line">#</span><br><span class="line"># You can copy this to one of:</span><br><span class="line"># - "/etc/mysql/my.cnf" to set global options,</span><br><span class="line"># - "~/.my.cnf" to set user-specific options.</span><br><span class="line"># </span><br><span class="line"># One can use all long options that the program supports.</span><br><span class="line"># Run program with --help to get a list of available options and with</span><br><span class="line"># --print-defaults to see which it would actually understand and use.</span><br><span class="line">#</span><br><span class="line"># For explanations see</span><br><span class="line"># http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span><br><span class="line"></span><br><span class="line"># This will be passed to all mysql clients</span><br><span class="line"># It has been reported that passwords should be enclosed with ticks/quotes</span><br><span class="line"># escpecially if they contain "#" chars...</span><br><span class="line"># Remember to edit /etc/mysql/debian.cnf when changing the socket location.</span><br><span class="line"></span><br><span class="line"># Here is entries for some specific programs</span><br><span class="line"># The following values assume you have at least 32M ram</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">socket		= /var/run/mysqld/mysqld.sock</span><br><span class="line">nice		= 0</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># * Basic Settings</span><br><span class="line">#</span><br><span class="line">user		= mysql</span><br><span class="line">pid-file	= /var/run/mysqld/mysqld.pid</span><br><span class="line">socket		= /var/run/mysqld/mysqld.sock</span><br><span class="line">port		= 3306</span><br><span class="line">basedir		= /usr</span><br><span class="line">datadir		= /var/lib/mysql</span><br><span class="line">tmpdir		= /tmp</span><br><span class="line">lc-messages-dir	= /usr/share/mysql</span><br><span class="line">character-set-server=utf8</span><br><span class="line">skip-external-locking</span><br><span class="line">#</span><br><span class="line"># Instead of skip-networking the default is now to listen only on</span><br><span class="line"># localhost which is more compatible and is not less secure.</span><br><span class="line"># bind-address		= 127.0.0.1</span><br><span class="line">#</span><br><span class="line"># * Fine Tuning</span><br><span class="line">#</span><br><span class="line">key_buffer_size		= 16M</span><br><span class="line">max_allowed_packet	= 16M</span><br><span class="line">thread_stack		= 192K</span><br><span class="line">thread_cache_size       = 8</span><br><span class="line"># This replaces the startup script and checks MyISAM tables if needed</span><br><span class="line"># the first time they are touched</span><br><span class="line">myisam-recover-options  = BACKUP</span><br><span class="line">#max_connections        = 100</span><br><span class="line">#table_open_cache       = 64</span><br><span class="line">#thread_concurrency     = 10</span><br><span class="line">#</span><br><span class="line"># * Query Cache Configuration</span><br><span class="line">#</span><br><span class="line">query_cache_limit	= 1M</span><br><span class="line">query_cache_size        = 16M</span><br><span class="line">#</span><br><span class="line"># * Logging and Replication</span><br><span class="line">#</span><br><span class="line"># Both location gets rotated by the cronjob.</span><br><span class="line"># Be aware that this log type is a performance killer.</span><br><span class="line"># As of 5.1 you can enable the log at runtime!</span><br><span class="line">#general_log_file        = /var/log/mysql/mysql.log</span><br><span class="line">#general_log             = 1</span><br><span class="line">#</span><br><span class="line"># Error log - should be very few entries.</span><br><span class="line">#</span><br><span class="line">log_error = /var/log/mysql/error.log</span><br><span class="line">#</span><br><span class="line"># Here you can see queries with especially long duration</span><br><span class="line">#slow_query_log		= 1</span><br><span class="line">#slow_query_log_file	= /var/log/mysql/mysql-slow.log</span><br><span class="line">#long_query_time = 2</span><br><span class="line">#log-queries-not-using-indexes</span><br><span class="line">#</span><br><span class="line"># The following can be used as easy to replay backup logs or for replication.</span><br><span class="line"># note: if you are setting up a replication slave, see README.Debian about</span><br><span class="line">#       other settings you may need to change.</span><br><span class="line">#server-id		= 1</span><br><span class="line">#log_bin			= /var/log/mysql/mysql-bin.log</span><br><span class="line">expire_logs_days	= 10</span><br><span class="line">max_binlog_size   = 100M</span><br><span class="line">#binlog_do_db		= include_database_name</span><br><span class="line">#binlog_ignore_db	= include_database_name</span><br><span class="line">#</span><br><span class="line"># * InnoDB</span><br><span class="line">#</span><br><span class="line"># InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.</span><br><span class="line"># Read the manual for more InnoDB related options. There are many!</span><br><span class="line">#</span><br><span class="line"># * Security Features</span><br><span class="line">#</span><br><span class="line"># Read the manual, too, if you want chroot!</span><br><span class="line"># chroot = /var/lib/mysql/</span><br><span class="line">#</span><br><span class="line"># For generating SSL certificates I recommend the OpenSSL GUI "tinyca".</span><br><span class="line">#</span><br><span class="line"># ssl-ca=/etc/mysql/cacert.pem</span><br><span class="line"># ssl-cert=/etc/mysql/server-cert.pem</span><br><span class="line"># ssl-key=/etc/mysql/server-key.pem</span><br></pre></td></tr></tbody></table></figure>

<p>3.t3.cnf</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>安装</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7(18.10)搭建个人网盘和博客</title>
    <url>/2018/12/01/2018-12-01-centos-7-18-10-da-jian-si-ren-wang-pan-he-bo-ke/</url>
    <content><![CDATA[<h4 id="1-java环境-jdk-8u231-linux-x64-tar-gz-由于原先有jdk7版本-故移除更换"><a href="#1-java环境-jdk-8u231-linux-x64-tar-gz-由于原先有jdk7版本-故移除更换" class="headerlink" title="1. java环境 jdk-8u231-linux-x64.tar.gz 由于原先有jdk7版本,故移除更换"></a>1. <code>java环境 jdk-8u231-linux-x64.tar.gz</code> 由于原先有jdk7版本,故移除更换</h4><p>先上传文件-&gt; 修改环境变量-&gt;解压至此文件下<br>/usr/local/src/java/  文件名为解压名 jdk1.8.0_231（和下面配置环境变量java_HOME路径一致）</p>
<h4 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2. 环境变量配置"></a>2. 环境变量配置</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU java]# vi /etc/profile</span><br><span class="line"> #set java environment</span><br><span class="line">        JAVA_HOME=/usr/local/src/java/jdk1.8.0_231</span><br><span class="line">        CLASSPATH=.:$JAVA_HOME/lib.tools.jar</span><br><span class="line">        PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">        export JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105215256350-1833053104.png" alt=""></p>
<h4 id="3-使环境变量生效"><a href="#3-使环境变量生效" class="headerlink" title="3.使环境变量生效"></a>3.使环境变量生效</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU java]# source /etc/profile</span><br><span class="line">[root@NEU java]# java -version</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105215525171-2010478065.png" alt=""></p>
<h3 id="搭建私有网盘"><a href="#搭建私有网盘" class="headerlink" title="搭建私有网盘"></a>搭建私有网盘</h3><h4 id="解压文件tank-3-0-6-linux-amd64-tar-gz-到-root-blueBall-下执行"><a href="#解压文件tank-3-0-6-linux-amd64-tar-gz-到-root-blueBall-下执行" class="headerlink" title="解压文件tank-3.0.6.linux-amd64.tar.gz 到/root/blueBall 下执行"></a>解压文件tank-3.0.6.linux-amd64.tar.gz 到/root/blueBall 下执行</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU blueBall]# cd tank-3.0.6/</span><br><span class="line">[root@NEU tank-3.0.6]# ./tank</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221141703-376703942.png" alt=""></p>
<h5 id="若执行遇到权限不足，请解压！！！！"><a href="#若执行遇到权限不足，请解压！！！！" class="headerlink" title="若执行遇到权限不足，请解压！！！！"></a>若执行遇到权限不足，请解压！！！！</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU ~]# cd blueBall/</span><br><span class="line">[root@NEU blueBall]# tar -zxvf tank-3.0.6.linux-amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221250471-62857338.png" alt=""></p>
<h5 id="修改默认端口"><a href="#修改默认端口" class="headerlink" title="修改默认端口"></a>修改默认端口</h5><p> <img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221453763-559829577.png" alt=""></p>
<h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><h4 id="修改端口-数据库-用户名和登录密码-startup-sh"><a href="#修改端口-数据库-用户名和登录密码-startup-sh" class="headerlink" title="修改端口,数据库,用户名和登录密码  startup.sh"></a>修改端口,数据库,用户名和登录密码  startup.sh</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># executable path</span><br><span class="line">DIR="$( cd "$( dirname "$0"  )" &amp;&amp; pwd  )"</span><br><span class="line">JAR_PATH=$DIR/blog-1.1.0.jar</span><br><span class="line">#configs</span><br><span class="line">ServerPort=80</span><br><span class="line">#mysql configs</span><br><span class="line">MysqlPort=3306</span><br><span class="line">MysqlHost=192.168.20.20</span><br><span class="line">MysqlSchema=blog</span><br><span class="line">MysqlUsername=root</span><br><span class="line">MysqlPassword=123</span><br><span class="line">MysqlUrl="jdbc:mysql://$MysqlHost:$MysqlPort/$MysqlSchema?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false"</span><br><span class="line">#tank configs</span><br><span class="line">TankUrl="https://tank.eyeblue.cn"</span><br><span class="line">TankEmail=zhenqk@163.com</span><br><span class="line">TankPassword=123456</span><br><span class="line">#admin configs</span><br><span class="line">AdminUsername=Tony</span><br><span class="line">AdminNickname=Tony</span><br><span class="line">AdminEmail=zhenqk@163.com</span><br><span class="line">AdminPassword=123456</span><br><span class="line">#email configs</span><br><span class="line">MailProtocol=smtps</span><br><span class="line">MailHost=smtp.126.com</span><br><span class="line">MailPort=465</span><br><span class="line">MailUsername=zhenqk@126.com</span><br><span class="line">MailPassword=a4877188</span><br><span class="line">MailDefaultEncoding=UTF-8</span><br><span class="line"></span><br><span class="line">OPTS="-Xmx512m -Dserver.port=$ServerPort -Dspring.datasource.url=$MysqlUrl -Dspring.datasource.username=$MysqlUsername -Dspring.datasource.password=$MysqlPassword -Dtank.url=$TankUrl -Dtank.email=$TankEmail -Dtank.password=$TankPassword -Dadmin.username=$AdminUsername -Dadmin.nickname=$AdminNickname -Dadmin.email=$AdminEmail -Dadmin.password=$AdminPassword -Dspring.mail.protocol=$MailProtocol -Dspring.mail.host=$MailHost -Dspring.mail.port=$MailPort -Dspring.mail.username=$MailUsername -Dspring.mail.password=$MailPassword -Dspring.mail.default-encoding=$MailDefaultEncoding"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo $OPTS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JAVA='java'</span><br><span class="line">if [ -z `which java` ]; then</span><br><span class="line">    if [ -z $JAVA_HOME ];</span><br><span class="line">        then</span><br><span class="line">            JAVA=$JAVA_HOME/bin/java</span><br><span class="line">        else</span><br><span class="line">            echo 'Cannot find java command and JAVA_HOME.'</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -z `java -version 2&gt;&amp;1 | grep 'java version' | awk '{print $3}' | egrep '1.[8-9].\d*'` ]; then</span><br><span class="line">    nohup $JAVA $OPTS -jar $JAR_PATH &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    echo $JAR_PATH</span><br><span class="line">    echo 'Started successfully.'</span><br><span class="line">else</span><br><span class="line">        echo 'Java version not support, must be 1.8 or 1.8+.'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221623514-127261145.png" alt=""><br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221801676-685815260.png" alt=""></p>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU blueBall]# cd blog-1.1.0/</span><br><span class="line">[root@NEU blog-1.1.0]# sh startup.sh</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221930094-1502045769.png" alt=""><br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105222102331-309170409.png" alt=""></p>
<h2 id="开机软件启动-根目录"><a href="#开机软件启动-根目录" class="headerlink" title="开机软件启动(根目录)"></a>开机软件启动(根目录)</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sh /root/blueBall/blog-1.1.0/startup.sh</span><br><span class="line">/root/blueBall/tank-3.0.6/tank</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>blueBall</tag>
        <tag>Linux下JDK的安装</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2017/07/10/2016-07-10-fan-she/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><ol>
<li>一个IP对应着哪个类的一个对象？InetAddress</li>
</ol>
<p>实例化这个类的两种方式是？</p>
<p>InetAddress.getByName(String host);</p>
<p>InetAddress.getLocalHost();//获取本地ip</p>
<p>两个常用的方法是？<br>getHostName();<br>getHostAddress();</p>
<p>2.传输层的TCP协议和UDP协议的主要区别是？<br>TCP:可靠的数据传输(三次握手)；进行大数据量的传输；效率低<br>UDP:不可靠；以数据报形式发送，数据报限定为64k；效率高</p>
<p>3.什么是URL，你能写一个URL吗？</p>
<p><a href="URL:统一资源定位符">URL:统一资源定位符</a></p>
<p>URL url = new URL(“<a href="http://192.168.14.100:8080/examples/hello.txt?username=Tom”" target="_blank" rel="noopener">http://192.168.14.100:8080/examples/hello.txt?username=Tom”</a>);</p>
<p>4.谈谈你对对象序列化机制的理解</p>
<p>序列化过程：</p>
<p>反序列化过程：  再还原为内存</p>
<p>5.对象要想实现序列化，需要满足哪几个条件</p>
<p>\1. 实现接口：Serializable  标识接口</p>
<p>\2. 对象所在的类提供常量：序列版本号</p>
<p>\3. 要求对象的属性也必须是可序列化的。（基本数据类型、String：本身就已经是可序列化的。）</p>
<h2 id="2-对象序列化机制"><a href="#2-对象序列化机制" class="headerlink" title="2.对象序列化机制"></a>2.对象序列化机制</h2><h4 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h4><h5 id="对象流的使用"><a href="#对象流的使用" class="headerlink" title="对象流的使用"></a>对象流的使用</h5><p>1.对象流:</p>
<p>ObjectOutputStream和ObjectInputStream</p>
<p>2.作用:</p>
<p>objectoutputStream:内存中的对象–&gt;存储中的文件、通过网络传输出去  序列化过程<br>objectInputStream:存储中的文件、通过网络接收过来–&gt;内存中的对象   反序列化过程</p>
<p>进程和进程之间传输要序列化</p>
<p>3.对象的序列化机制:</p>
<p>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另- - 个网络节点。//当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</p>
<p>4.<br>序列化过程代码实现:</p>
 <figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去</span><br><span class="line"> 使用ObjectOutputStream实现</span><br><span class="line">  */</span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectOutputStream</span><span class="params">()</span></span>{</span><br><span class="line">     ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> {</span><br><span class="line">         <span class="comment">//1.</span></span><br><span class="line">         oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"object.dat"</span>));</span><br><span class="line">         <span class="comment">//2.</span></span><br><span class="line">         oos.writeObject(<span class="keyword">new</span> String(<span class="string">"我爱北京天安门"</span>));</span><br><span class="line">         oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">         oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"王铭"</span>,<span class="number">23</span>));</span><br><span class="line">         oos.flush();</span><br><span class="line"></span><br><span class="line">         oos.writeObject(<span class="keyword">new</span> Person(<span class="string">"张学良"</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> Account(<span class="number">5000</span>)));</span><br><span class="line">         oos.flush();</span><br><span class="line"></span><br><span class="line">     } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     } <span class="keyword">finally</span> {</span><br><span class="line">         <span class="keyword">if</span>(oos != <span class="keyword">null</span>){</span><br><span class="line">             <span class="comment">//3.</span></span><br><span class="line">             <span class="keyword">try</span> {</span><br><span class="line">                 oos.close();</span><br><span class="line">             } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">             }</span><br><span class="line"></span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<p>5.<br>反序列化代码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   反序列化：将磁盘文件中的对象还原为内存中的一个java对象</span></span><br><span class="line"><span class="comment">   使用ObjectInputStream来实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testObjectInputStream</span><span class="params">()</span></span>{</span><br><span class="line">       ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"object.dat"</span>));</span><br><span class="line">           Object obj = ois.readObject();</span><br><span class="line">           String str = (String) obj;</span><br><span class="line">           Person p = (Person) ois.readObject();</span><br><span class="line">           Person p1 = (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">           System.out.println(str);</span><br><span class="line">           System.out.println(p);</span><br><span class="line">           System.out.println(p1);</span><br><span class="line"></span><br><span class="line">       } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       } <span class="keyword">finally</span> {</span><br><span class="line">           <span class="keyword">if</span>(ois != <span class="keyword">null</span>){</span><br><span class="line">               <span class="keyword">try</span> {</span><br><span class="line">                   ois.close();</span><br><span class="line">               } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line"></span><br><span class="line">           }</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure>

<p>开发基本用string 去序列化</p>
<p>6.实现序列化的对象所属的类需要满足:</p>
<ul>
<li><p>Person需要满足如下的要求，方可序列化</p>
</li>
<li><p>1.需要实现接口：Serializable</p>
</li>
<li><p>2.当前类提供一个全局常量：serialVersionUID</p>
</li>
<li><p>3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性</p>
<p>也必须是可序列化的。（默认情况下，基本数据类型可序列化）</p>
<p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
</li>
</ul>
<h2 id="3-复习：-其他IO流内容"><a href="#3-复习：-其他IO流内容" class="headerlink" title="3.复习： 其他IO流内容"></a>3.复习： 其他IO流内容</h2><h4 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h4><p>1.随机存取文件流:    可读可写  RandomAccessFile</p>
<p>2.使用说明:</p>
<p>1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口<br>2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流，同一个类 不同对象<br>3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。<br>  如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</p>
<p>4.可以通过相关的操作，实现RandomAccessFile“插入”数据的效果   seek(int pos)</p>
<p>3.<br>典型代码1</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_23" alt="1588459927396">:</p>
<p>典型代码2:</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_26" alt="1588461597717"></p>
<h4 id="Path-Paths-Files的使用"><a href="#Path-Paths-Files的使用" class="headerlink" title="Path\Paths\Files的使用"></a>Path\Paths\Files的使用</h4><p>常用  开源框架 ，第三方jar<br>1.NIO的使用说明:<br>Java NIO (New I0，Non-Blocking I0)是从Java 1.4版本开始引入的一套新<br>的I0 API，可以替代标准的Java I0 API。<br>NIO与原来的I0有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(I0是面向流的)、基于通道的I0操作。NIO将以更加高效的方式进行文件的读写操作。<br>随着JDK 7的发布，Java对NIO进行了极大的扩展，增强了对<br>文件处理和文件系统特性的支持，以至于我们称他们为NIO.2。</p>
<p>2.Path的使用–jdk7提供<br>2.1Path的说明:<br>Path替换原有的File类。<br>2.2如何实例化:</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_01" alt="1588483560328"></p>
<p>2.3常用方法: .</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_32" alt="1588462010980"></p>
<p>3.Files工具类–jdk7提供<br>3.1作用:操作文件或问价目录的工具类</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_33" alt="1588462037569"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_34" alt="1588462086709"></p>
<h2 id="复习4-网络通信要素"><a href="#复习4-网络通信要素" class="headerlink" title="复习4. 网络通信要素"></a>复习4. 网络通信要素</h2><h4 id="InetAddress类的使用"><a href="#InetAddress类的使用" class="headerlink" title="InetAddress类的使用"></a>InetAddress类的使用</h4><p>一、 实现网络通信需要解决的两个问题</p>
<p>1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用<br>2.找到主机后如何可靠高效地进行数据传输</p>
<p>二、网络通信的两个要素:</p>
<p>1.对应问题一：IP和端口号<br>2.对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）</p>
<p>三、通信要素一: IP和端口号<br>1.IP的理解</p>
<ol>
<li><p>IP:唯一的标识 Internet 上的计算机（通信实体）</p>
</li>
<li><p>在Java中使用InetAddress类代表IP</p>
</li>
<li><p>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</p>
</li>
<li><p>域名:   <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>   <a href="http://www.mi.com" target="_blank" rel="noopener">www.mi.com</a>  <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a>  <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a></p>
<pre><code>www.vip.com</code></pre><p>域名解析:域名容易记忆， 当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。..域名解析</p>
</li>
<li><p>本地回路地址：127.0.0.1 对应着：localhost</p>
</li>
</ol>
<ol start="2">
<li><p>InetAddress类: 此类的一个对象就代表着一个具体的IP地址<br> 2.1实例化</p>
<p>getByName(String host) 、 getLocalHost()</p>
</li>
</ol>
<p>  2.2常用方法</p>
<p>  getHostName() / getHostAddress()</p>
<p>  3.端口号:正在计算机上运行的进程。<br>  要求：不同的进程有不同的端口号<br>  范围：被规定为一个 16 位的整数 0~65535。</p>
<p>端口号与IP地址的组合得出-一个网络套接字: Socket</p>
<p>四、通信要素二:网络通信协议<br>1.分型模型<br><img src="/2017/07/10/2016-07-10-fan-she/27_39" alt="1588464678863"></p>
<p>2.TCP和UDP的区别</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_49" alt="1588468669762"></p>
<ol start="3">
<li>TCP三次握手和四次挥手</li>
</ol>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_50" alt="1588468691949"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_76" alt="1588468711223"></p>
<p>目的提高建立可靠连接，提高</p>
<h2 id="5-复习-TCP、UDP、URL网络编程"><a href="#5-复习-TCP、UDP、URL网络编程" class="headerlink" title="5.复习:TCP、UDP、URL网络编程."></a>5.复习:TCP、UDP、URL网络编程.</h2><h4 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h4><h5 id="TCP-网络编程"><a href="#TCP-网络编程" class="headerlink" title="TCP 网络编程"></a>TCP 网络编程</h5><ul>
<li><p>例子1：客户端发送信息给服务端，服务端将数据显示在控制台上</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span>  </span>{</span><br><span class="line">        Socket socket = <span class="keyword">null</span>; </span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            InetAddress inet = InetAddress.getByName(<span class="string">"192.168.14.100"</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(inet,<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">"你好，我是客户端mm"</span>.getBytes());</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    os.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    socket.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span>  </span>{</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">//3.获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            <span class="comment">//不建议这样写，可能会有乱码</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">//        int len;</span></span><br><span class="line"><span class="comment">//        while((len = is.read(buffer)) != -1){</span></span><br><span class="line"><span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">//            System.out.print(str);</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">            <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>){</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">            <span class="comment">//看谁给我发的</span></span><br><span class="line">            System.out.println(<span class="string">"收到了来自于："</span> + socket.getInetAddress().getHostAddress() + <span class="string">"的数据"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="keyword">null</span>){</span><br><span class="line">                <span class="comment">//5.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    baos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    is.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    socket.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    ss.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>2.客户端发送文件给服务端，服务端将文件保存在本地。</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_54" alt="1588470827777"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_77" alt="1588470923833"></p>
<p>实例三:从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</p>
<p>服务器端</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/27_55" alt="1588471281061"></p>
<p>os.close</p>
<p>客户端socket.shutdownOutput()  告诉数据结束      阻塞式的操作</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/..%5CstudyNote_Pic%5Csgg%5Cday12%5C1588471342577.png" alt="1588471342577"></p>
<p>baos.close()</p>
<h5 id="UDP-网络编程"><a href="#UDP-网络编程" class="headerlink" title="UDP 网络编程"></a>UDP 网络编程</h5><p>示例一<br><img src="/2017/07/10/2016-07-10-fan-she/27_64" alt="1588472841104"></p>
<h5 id="UR编程"><a href="#UR编程" class="headerlink" title="UR编程"></a>UR编程</h5><p>1.URL(Uniform Resource Locator)的理解:<br>统一资源定位符，对应着互联网的某一资源地址</p>
<p>2.URL的5个基本结构:<br> <a href="http://localhost:8080/examples/beauty.jpg?username=Tom" target="_blank" rel="noopener">http://localhost:8080/examples/beauty.jpg?username=Tom</a><br> 协议   主机名    端口号  资源地址           参数列表<br>3.如何实例化:<br>URL url = new URL(“<a href="http://localhost:8080/examples/beauty.jpg?username=Tom&quot;" target="_blank" rel="noopener">http://localhost:8080/examples/beauty.jpg?username=Tom"</a>);</p>
<p>4.常用方法:<br><img src="/2017/07/10/2016-07-10-fan-she/27_68" alt="1588472841104"></p>
<p>5.可以读取、下载对应的ur1资源:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLTest1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:8080/examples/beauty.jpg"</span>);</span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">            urlConnection.connect();</span><br><span class="line">            is = urlConnection.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"day10\\beauty3.jpg"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>){</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"下载完成"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(is != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    is.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(urlConnection != <span class="keyword">null</span>){</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="6-反射的概述-lt-设计代码会写"><a href="#6-反射的概述-lt-设计代码会写" class="headerlink" title="6.反射的概述<设计代码会写"></a>6.反射的概述&lt;设计代码会写</h2><h4 id="1-Java反射机制概述"><a href="#1-Java反射机制概述" class="headerlink" title="1.Java反射机制概述"></a>1.Java反射机制概述</h4><p><img src="/2017/07/10/2016-07-10-fan-she/28_02" alt="1588486379717"></p>
<p>运行时才能确定，造那个对象，调用那个方法</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_03" alt="1588486483361"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_04" alt="1588486625491"></p>
<p>spring动态代理</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_05" alt="1588486693586"></p>
<p>Class 通用类    任意类都有  属性方法构造器   ，，通用描述其他类信息；；；描述类的类</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_06" alt="1588486839082"></p>
<h4 id="2-理解Class类并获取Class实例"><a href="#2-理解Class类并获取Class实例" class="headerlink" title="2.理解Class类并获取Class实例*"></a>2.理解Class类并获取Class实例*</h4><h2 id="7-反射之前，类的实例化等操作"><a href="#7-反射之前，类的实例化等操作" class="headerlink" title="7.反射之前，类的实例化等操作"></a>7.反射之前，类的实例化等操作</h2><p>引入反射</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"Person()"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"你好，我是一个人"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">showNation</span><span class="params">(String nation)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"我的国籍是："</span> + nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>demo 类</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_07" alt="1588487306057"></p>
<h2 id="8-使用反射，实现同上的操作"><a href="#8-使用反射，实现同上的操作" class="headerlink" title="8.使用反射，实现同上的操作"></a>8.使用反射，实现同上的操作</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_08" alt="1588487656995"></p>
<h2 id="9-反射的强大-调用类的私有结构"><a href="#9-反射的强大-调用类的私有结构" class="headerlink" title="9.反射的强大 :调用类的私有结构"></a>9.反射的强大 :调用类的私有结构</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_09" alt="1588488931785"></p>
<h2 id="10-如何看待反射和封装性两个技术"><a href="#10-如何看待反射和封装性两个技术" class="headerlink" title="10.如何看待反射和封装性两个技术"></a>10.如何看待反射和封装性两个技术</h2><p>//疑问1：通过直接new的方式或反射的方式都可以调用公共的结构，开发中到底用那个？<br>    //建议：直接new的方式。<br>    //什么时候会使用：反射的方式。 反射的特征：动态性        ;编译的时候不能确定调用那个对象<br>    //  服务器已经开启了，<br>    //疑问2：反射机制与面向对象中的封装性是不是矛盾的？如何看待两个技术？<br>    //不矛盾。   反射是动态性，原来的时候还是那个用<br>//封装 正常调用 用不着,单例对于反射 没必要构造对象<br>//反射是能不能调用的问题    ，封装解决 到底建议你怎么调用</p>
<h2 id="11-Class类的理解"><a href="#11-Class类的理解" class="headerlink" title="11.Class类的理解"></a>11.Class类的理解</h2><p> /*<br>    关于java.lang.Class类的理解<br>    1.类的加载过程：<br>    程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)。<br>    接着我们使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件<br>    加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此<br>    运行时类，就作为Class的一个实例。<br>    2.换句话说，Class的实例就对应着一个运行时类。<br>    3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式<br>    来获取此运行时类。<br>     */<br>     class 是大Class 对象<br>万事万物皆对象<br>加上泛型避免强转</p>
<h2 id="12-获取Class-实例的4种方式-前三种要求掌握"><a href="#12-获取Class-实例的4种方式-前三种要求掌握" class="headerlink" title="12.获取Class 实例的4种方式 (前三种要求掌握)"></a>12.获取Class 实例的4种方式 (前三种要求掌握)</h2><pre><code>![1588491323588](28_10)</code></pre><p>第三种的用的多</p>
<h2 id="13-Class实例对应的结构的说明"><a href="#13-Class实例对应的结构的说明" class="headerlink" title="13. Class实例对应的结构的说明."></a>13. Class实例对应的结构的说明.</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_11" alt="1588491520221"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_12" alt="1588491541456"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_13" alt="1588491566384"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_14" alt="1588491587195"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_15" alt="1588491751810"></p>
<p>true</p>
<h4 id="3-类的加载与ClassLoader的理解"><a href="#3-类的加载与ClassLoader的理解" class="headerlink" title="3.类的加载与ClassLoader的理解"></a>3.类的加载与ClassLoader的理解</h4><h2 id="14-理解类的加载过程"><a href="#14-理解类的加载过程" class="headerlink" title="14.理解类的加载过程"></a>14.理解类的加载过程</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_16" alt="1588491931848"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_17" alt="1588492111554"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_18" alt="1588492181644"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_19" alt="1588492247651"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_20" alt="1588492268577"></p>
<h2 id="15-ClassLoader的理解"><a href="#15-ClassLoader的理解" class="headerlink" title="15.ClassLoader的理解"></a>15.ClassLoader的理解</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_21" alt="1588492290739"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_22" alt="1588492370657"></p>
<p>引导  加载器  string</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_23" alt="1588492528630"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_29" alt="1588493843728"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_24" alt="1588492597689"></p>
<h2 id="16-使用Classloader加载配置文件"><a href="#16-使用Classloader加载配置文件" class="headerlink" title="16. 使用Classloader加载配置文件"></a>16. 使用Classloader加载配置文件</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_25" alt="1588492840087"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_26" alt="1588492992423"></p>
<p>第一种  src\jdbc1.properties</p>
<h4 id="4-创建运行时类的对象"><a href="#4-创建运行时类的对象" class="headerlink" title="4.创建运行时类的对象*"></a>4.创建运行时类的对象*</h4><h2 id="17-创建运行时类的对象"><a href="#17-创建运行时类的对象" class="headerlink" title="17.创建运行时类的对象"></a>17.创建运行时类的对象</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_27" alt="1588493229705"></p>
<p>用泛型 不用转型了</p>
<pre><code>/*
newInstance():调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。

要想此方法正常的创建运行时类的对象，要求：
1.运行时类必须提供空参的构造器
2.空参的构造器的访问权限得够。通常，设置为public。
在javabean中要求提供一个public的空参构造器。原因：
1.便于通过反射，创建运行时类的对象
2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器

 */</code></pre><p><img src="/2017/07/10/2016-07-10-fan-she/28_28" alt="1588493725904"></p>
<p>只有构造器才能造对象，newInstance  内部调用构造器     不带参数好处理，避免各个子类之间属性不一样</p>
<p>通常 通过反射创建对象 ，都喜欢空参的</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_30" alt="1588494021095"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_31" alt="1588494042948"></p>
<h2 id="18-体会反射的动态性"><a href="#18-体会反射的动态性" class="headerlink" title="18.体会反射的动态性"></a>18.体会反射的动态性</h2><p>只有运行过后才能确认</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_32" alt="1588494556537"></p>
<h4 id="5-获取运行时类的完整结构-不要求掌握"><a href="#5-获取运行时类的完整结构-不要求掌握" class="headerlink" title="5.获取运行时类的完整结构  (不要求掌握)"></a>5.获取运行时类的完整结构  (不要求掌握)</h4><h2 id="19-提供结构丰富的Person类（Creature-java，MyInterface-java，MyAnnotation-java-Person-java）"><a href="#19-提供结构丰富的Person类（Creature-java，MyInterface-java，MyAnnotation-java-Person-java）" class="headerlink" title="19. 提供结构丰富的Person类（Creature.java，MyInterface.java，MyAnnotation.java,Person.java）"></a>19. 提供结构丰富的Person类（Creature.java，MyInterface.java，MyAnnotation.java,Person.java）</h2><p>Creature.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creature</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"生物呼吸"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"生物吃东西"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>MyInterface.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>MyAnnotation.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation {</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "hello"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Person.java</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(value=<span class="string">"hi"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">MyInterface</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value=<span class="string">"abc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">     Person(String name,<span class="keyword">int</span> age){</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">show</span><span class="params">(String nation)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"我的国籍是："</span> + nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">(String interests,<span class="keyword">int</span> age)</span> <span class="keyword">throws</span> NullPointerException,ClassCastException</span>{</span><br><span class="line">        <span class="keyword">return</span> interests + age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"我是一个人"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String o)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showDesc</span><span class="params">()</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"我是一个可爱的人"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person{"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", id="</span> + id +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


<h2 id="20-获取运行时类的属性结构及其内部结构"><a href="#20-获取运行时类的属性结构及其内部结构" class="headerlink" title="20.获取运行时类的属性结构及其内部结构."></a>20.获取运行时类的属性结构及其内部结构.</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_33" alt="1588495783337"></p>
<p>本类中声明的属性</p>
<p>属性的具体某个结构拿到   (实际开发不用 太无聊了)</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_34" alt="1588496598491"></p>
<h2 id="21-获取运行时类的方法结构"><a href="#21-获取运行时类的方法结构" class="headerlink" title="21.获取运行时类的方法结构"></a>21.获取运行时类的方法结构</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_35" alt="1588497813290"></p>
<h2 id="22-获取运行时类的方法的内部结构"><a href="#22-获取运行时类的方法的内部结构" class="headerlink" title="22.获取运行时类的方法的内部结构"></a>22.获取运行时类的方法的内部结构</h2><p>注解  runtime 可以获取到，，，改成RetentionPolicy.class 获取不到</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_37" alt="1588498829875"></p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_36" alt="1588498803536"></p>
<p>可重复注解，所以是多了类型</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_38" alt="1588499949858"></p>
<p>后续通过反射拿到方法  ，接着获取注解，看想做什么</p>
<p>注解+反射+设计模式=框架</p>
<h2 id="23-获取运行时类的构造器结构"><a href="#23-获取运行时类的构造器结构" class="headerlink" title="23. 获取运行时类的构造器结构"></a>23. 获取运行时类的构造器结构</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_39" alt="1588500150497"></p>
<h2 id="24-获取运行时类的父类及父类的泛型"><a href="#24-获取运行时类的父类及父类的泛型" class="headerlink" title="24.获取运行时类的父类及父类的泛型"></a>24.获取运行时类的父类及父类的泛型</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_40" alt="1588500639738"></p>
<h2 id="25-获取运行时类的接、所在包、注解等"><a href="#25-获取运行时类的接、所在包、注解等" class="headerlink" title="25. 获取运行时类的接、所在包、注解等"></a>25. 获取运行时类的接、所在包、注解等</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_41" alt="1588501117780"></p>
<p>test4.  test5(动态代理)    test7  框架用到的多（可能用在某个方法上）</p>
<h4 id="6-调用运行时类的指定结构"><a href="#6-调用运行时类的指定结构" class="headerlink" title="6.调用运行时类的指定结构*"></a>6.调用运行时类的指定结构*</h4><h2 id="26-调用运行时类中的指定属性-属性-方法-构造器-重点方法"><a href="#26-调用运行时类中的指定属性-属性-方法-构造器-重点方法" class="headerlink" title="26.调用运行时类中的指定属性 (属性  方法 构造器 )  重点方法"></a>26.调用运行时类中的指定属性 (属性  方法 构造器 )  重点方法</h2><p>declare  范围比较小</p>
<p><img src="/2017/07/10/2016-07-10-fan-she/28_42" alt="1588501820312"></p>
<h2 id="27-调用运行时类中的指定方法"><a href="#27-调用运行时类中的指定方法" class="headerlink" title="27.调用运行时类中的指定方法."></a>27.调用运行时类中的指定方法.</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_43" alt="1588502254601"></p>
<p>  静态 :   null==Person.class 都可以</p>
<h2 id="28-调用运行时类中的指定构造器（不常用）"><a href="#28-调用运行时类中的指定构造器（不常用）" class="headerlink" title="28.调用运行时类中的指定构造器（不常用）"></a>28.调用运行时类中的指定构造器（不常用）</h2><p><img src="/2017/07/10/2016-07-10-fan-she/28_44" alt="1588502603077"></p>
<p>通用  通用  –&gt;   空参数 通用</p>
<h4 id="7-反射的应用-动态代理"><a href="#7-反射的应用-动态代理" class="headerlink" title="7.反射的应用:动态代理"></a>7.反射的应用:动态代理</h4><p>二轮面试  项目经理和开发组长</p>
<p>待遇   20% </p>
<p>参与项目  ，项目采用什么架构  ，主要那一块   用什么技术实现的</p>
<p> 这就是下一个目标</p>
<p>代码: 逻辑性代码 VS 功能性代码 </p>
<p>逻辑性代码  要保存起来  ，  从一个页面到另一个页面的逻辑    保存</p>
<p>功能性代码    :知道代码干什么事就够了   不用深究</p>
<p>知道怎么用  ，</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流与网络编程</title>
    <url>/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>1.说明流的三种分类方式<br>流向：输入流、输出流<br>数据单位：字节流、字符流<br>流的角色：节点流、处理流</p>
<p>2.写出4个IO流中的抽象基类，4个文件流，4个缓冲流<br>InputStream           FileXxx       BufferedXxx<br>OutputStream<br>Reader<br>Writer<br>InputStreamReader:父类Reader<br>异常： XxxException  XxxError<br>RandomAccessFile</p>
<ol start="3">
<li>字节流与字符流的区别与使用情境<br>字节流：read(byte[] buffer) / read()   非文本文件<br>字符流：read(char[] cbuf) / read()     文本文件</li>
<li>使用缓冲流实现a.jpg文件复制为b.jpg文件的操作<br>BufferedInputStream bis = new BufferedInputStream(new FileInputStream(new File(“a.jpg”)));<br>BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File(“b.jpg”)));<br>byte[] buffer = new byte[1024];<br>int len;<br>while((len = bis.read(buffer))!= -1){<br>​    bos.write(buffer,0,len);<br>}<br>bos.close();<br>bis.close();<br>//此时的异常应该使用try-catch-finally处理。</li>
</ol>
<p>5.转换流是哪两个类，分别的作用是什么？请分别创建两个类的对象。<br>InputStreamReader:将输入的字节流转换为输入的字符流。 解码<br>OutputStreamWriter：将输出的字符流转换为输出的字节流。编码<br>InputStreamReader isr = new InputStreamReader(new FileInputStream(“a.txt”),”utf-8”);<br>OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(“b.txt”),”gbk”);</p>
<h2 id="2-复习-：-IO流概述"><a href="#2-复习-：-IO流概述" class="headerlink" title="2.复习 ： IO流概述"></a>2.复习 ： IO流概述</h2><h5 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h5><h5 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h5><p>1.流的分类<br>操作数据单位：字节流、字符流<br>.数据的流向：输入流、输出流<br>流的角色：节点流、处理流<br>图示:<img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_23" alt="1588406068349"><br>2.流的体系结构<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_24" alt="1588429011700">   加深色重点关注<br>说明 IO流的4个抽象基类</p>
<p>3.重点说明的几个流结构</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_01" alt="1588429199446"></p>
<p>已有的节点流 作为参数，放在缓冲流构造器中</p>
<p>装饰的设计模式  功能加强了  </p>
<p>4.输入、输出的标准化过程<br>4.1输入过程</p>
<p>①创建File类的对象，指明读取的数据的来源。(要求此文件一 -定要存在)<br>②创建相应的输入流，将File类的对象作为参数，传入流的构造器中<br>③具体的读入过程: 创建相应的byte[]或char[]。<br>④关闭流资源</p>
<p>说明:程序中出现的异常需要使用try-catch-finally处理。</p>
<p>4.2输出过程</p>
<p>①创建File类的对象，指明写出的数据的位置。(不要求此文件一定要存在)<br>②创建相应的输出流，将File类的对象作为参数，传入流的构造器中<br>③具体的写出过程:<br>write(char[]/byte[] buffer,0,len)<br>④关闭流资源<br>说明:程序中出现的异常需要使用try-catch-finally处理。</p>
<h2 id="3-复习-节点流"><a href="#3-复习-节点流" class="headerlink" title="3.复习:节点流"></a>3.复习:节点流</h2><h5 id="节点流-或文件流"><a href="#节点流-或文件流" class="headerlink" title="节点流(或文件流)"></a>节点流(或文件流)</h5><p> 1.FileReader/FileWriter的使用:<br>1.1 FileReader的使用<br>说明点：1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</p>
<ol start="2">
<li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</li>
<li>读入的文件一定要存在，否则就会报FileNotFoundException。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">//对read()操作升级：使用read的重载方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReader1</span><span class="params">()</span>  </span>{</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//1.File类的实例化</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line">            <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">            <span class="comment">//3.读入的操作</span></span><br><span class="line">            <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];    <span class="comment">//*****</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>){</span><br><span class="line">                <span class="comment">//方式一：</span></span><br><span class="line">                <span class="comment">//错误的写法</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++){</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                }</span></span><br><span class="line">                <span class="comment">//正确的写法</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; len;i++){</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                }</span></span><br><span class="line">                <span class="comment">//方式二：</span></span><br><span class="line">                <span class="comment">//错误的写法,对应着方式一的错误的写法</span></span><br><span class="line"><span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line">                <span class="comment">//正确的写法</span></span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len); <span class="comment">//******</span></span><br><span class="line">                System.out.print(str);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="keyword">null</span>){</span><br><span class="line">                <span class="comment">//4.资源的关闭</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fr.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<p>1.2 FilelWriter的使用<br>从内存中写出数据到硬盘的文件里。<br>说明：1. 输出操作，对应的File可以不存在的。并不会报异常</p>
<ol start="2">
<li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。<br>File对应的硬盘中的文件如果存在：<br>如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原有文件的覆盖<br>如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容<br>RAF 在原有基础上覆盖</li>
</ol>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_38" alt="1588413758710"></p>
<p>1.3文本文件的复制: .<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_39" alt="1588414166673"></p>
<p>2.FileInputStream / FileOutputStream的使用:   仅仅搬运也可以复制</p>
<ol>
<li>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</li>
<li>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</li>
</ol>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_41" alt="1588415573068"><br>造文件，，造流，复制的过程，关闭流资源</p>
<p>[注意]<br>相对路径在IDEA和Eclipse中使用的区别?</p>
<p>IDEA:<br>如果使用单元测试方法，相对路径基于当前的Module的。<br>如果使用main()测试，相对路径基于当前Project的。<br>Eclipse:<br>单元测试方法还是main(),相对路径都是基于当前Project的。</p>
<h2 id="4-缓冲流与转换流"><a href="#4-缓冲流与转换流" class="headerlink" title="4.缓冲流与转换流"></a>4.缓冲流与转换流</h2><h5 id="缓冲流的使用"><a href="#缓冲流的使用" class="headerlink" title="缓冲流的使用"></a>缓冲流的使用</h5><p>1.缓冲流涉及到的类:<br>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter<br>2.作用:<img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_02" alt="1588430560271"></p>
<p>一边想  一边写<br>3.典型代码<br>3.1使用BufferedInputStream和BufferedoutputStream:处理非文本文件<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_44" alt="1588417053398"></p>
<p>3.2使用BufferedReader和BufferedWriter: 处理文本文件<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_46" alt="1588417989885"></p>
<h5 id="转换流的使用"><a href="#转换流的使用" class="headerlink" title="转换流的使用"></a>转换流的使用</h5><p>1.转换流涉及到的类:属于字符流<br>  InputStreamReader：将一个字节的输入流转换为字符的输入流<br>  解码：字节、字节数组  —&gt;字符数组、字符串</p>
<p>  OutputStreamWriter：将一个字符的输出流转换为字节的输出流<br>  编码：字符数组、字符串 —&gt; 字节、字节数组</p>
<p>  说明编码决定了解码的方式<br>2.作用:<br>提供字节流与字符流之间的转换</p>
<p>3.图示:<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_51" alt="1588419462018"></p>
<p>4.典型实现:<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_52" alt="1588421377417"><br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/26_53" alt="1588421703979"><br>5.说明:<br>//文件编码的方式(比如: GBK) ，决定了解析时使用的字符集(也只能是GBK)。</p>
<h5 id="常见的编码表"><a href="#常见的编码表" class="headerlink" title="常见的编码表"></a>常见的编码表</h5><p>1.常见的编码表<br> *ASCII：美国标准信息交换码。<br> 用一个字节的7位可以表示。<br> ISO8859-1：拉丁码表。欧洲码表<br> 用一个字节的8位表示。<br> GB2312：中国的中文编码表。最多两个字节编码所有字符<br> GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码<br> Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。<br> UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</p>
<p>2.对后面学习的启示<br>客户端/浏览器端——-  后台(java,GO,Python,Node. js,php)————-数据库<br>要求前前后后使用的字符集都要统一: UTF-8.</p>
<h2 id="5-复习-其他流的使用"><a href="#5-复习-其他流的使用" class="headerlink" title="5.复习:其他流的使用"></a>5.复习:其他流的使用</h2><p>1.标准的输入输出流:<br>    System.in:标准的输入流，默认从键盘输入<br>    System.out:标准的输出流，默认从控制台输出<br>修改默认的输入和输出行为:<br>   System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。<br>2.打印流:<br>打印流：PrintStream 和PrintWriter<br>说明:<br>提供了一系列重载就的print())和println)方法，用于多种数据类型的输出<br>实现将基本数据类型的数据格式转化为字符串输出<br>System.out返回的是PrinStream的实例</p>
<p>3.数据流:<br> DataInputStream 和 DataOutputStream<br>作用:用于读取或写出基本数据类型的变量或字符串<br>示例代码:</p>
<p>将内存中的字符串、基本数据类型的变量写出到文件中。<br>注意：处理异常的话，仍然应该使用try-catch-finally.     只能对基本类型有效</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">*/</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">      <span class="comment">//1.</span></span><br><span class="line">      DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">      <span class="comment">//2.</span></span><br><span class="line">      dos.writeUTF(<span class="string">"Tony"</span>);</span><br><span class="line">      dos.flush();<span class="comment">//刷新操作，将内存中的数据写入文件</span></span><br><span class="line">      dos.writeInt(<span class="number">23</span>);</span><br><span class="line">      dos.flush();</span><br><span class="line">      dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">      dos.flush();</span><br><span class="line">      <span class="comment">//3.</span></span><br><span class="line">      dos.close();</span><br><span class="line">          }</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment">  注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">      <span class="comment">//1.造流</span></span><br><span class="line">      DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">      <span class="comment">//2. 读</span></span><br><span class="line">      String name = dis.readUTF();</span><br><span class="line">      <span class="keyword">int</span> age = dis.readInt();</span><br><span class="line">      <span class="keyword">boolean</span> isMale = dis.readBoolean();</span><br><span class="line">      System.out.println(<span class="string">"name = "</span> + name);</span><br><span class="line">      System.out.println(<span class="string">"age = "</span> + age);</span><br><span class="line">      System.out.println(<span class="string">"isMale = "</span> + isMale);</span><br><span class="line">      <span class="comment">//3.关闭流</span></span><br><span class="line">      dis.close();</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>

<h4 id="9-对象流-掌握"><a href="#9-对象流-掌握" class="headerlink" title="9.对象流(掌握)"></a>9.对象流(掌握)</h4><h2 id="6-对象序列化机制的理解"><a href="#6-对象序列化机制的理解" class="headerlink" title="6.对象序列化机制的理解"></a>6.对象序列化机制的理解</h2><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_03" alt="1588457212051"></p>
<p>反序列化  还原成内存</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_04" alt="1588457402281"></p>
<p>需要类是可序列化的，，     用于进程之间可以传递数据，比如 微信可以查看QQ人数</p>
<h2 id="7-对象流序列化与反序列化字符串的操作"><a href="#7-对象流序列化与反序列化字符串的操作" class="headerlink" title="7.对象流序列化与反序列化字符串的操作"></a>7.对象流序列化与反序列化字符串的操作</h2><p>对象流的使用<br>1.ObjectInputStream 和 ObjectOutputStream<br>2.作用：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。<br>3.要想一个java对象是可序列化的，需要满足相应的要求。见Person.java</p>
<p>4.序列化机制：<br>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种<br>二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。<br>当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_09" alt="1588457948130"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">反序列化：将磁盘文件中的对象还原为内存中的一个java对象</span><br><span class="line">使用ObjectInputStream来实现</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/..%5CstudyNote_Pic%5Csgg%5Cday12%5C1588458170048.png" alt="1588458170048"></p>
<h2 id="8-自定义类实现序列化与反序列化"><a href="#8-自定义类实现序列化与反序列化" class="headerlink" title="8.自定义类实现序列化与反序列化"></a>8.自定义类实现序列化与反序列化</h2><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_10" alt="1588458413528"></p>
<p>需要搞成这样才能序列化</p>
<ul>
<li><p>Person需要满足如下的要求，方可序列化</p>
</li>
<li><p>1.需要实现接口：Serializable</p>
</li>
<li><p>2.当前类提供一个全局常量：serialVersionUID</p>
</li>
<li><p>3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性</p>
<p>也必须是可序列化的。（默认情况下，基本数据类型可序列化）</p>
<p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
</li>
</ul>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_12" alt="1588458683306"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_11" alt="1588458512806"></p>
<p>读写按照顺序<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_13" alt="1588458791819"></p>
<h2 id="9-serialVersionUID的理解"><a href="#9-serialVersionUID的理解" class="headerlink" title="9.serialVersionUID的理解"></a>9.serialVersionUID的理解</h2><p>person—&gt;打成二进制流–&gt;美国   —&gt;贴上标签<br>为什么要贴标签，由于保证是自己<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_05" alt="1588457589687"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_06" alt="1588457611322"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_07" alt="1588457630026"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_08" alt="1588457647970"></p>
<p>若serialVersionUID省略，当类的结构会更改时，则会重新随机生成serialVersionUID。</p>
<p>类中新增一个成员 Id</p>
<h2 id="10-自定义类可序列化的其它要求"><a href="#10-自定义类可序列化的其它要求" class="headerlink" title="10.自定义类可序列化的其它要求"></a>10.自定义类可序列化的其它要求</h2><p>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性</p>
<p>也必须是可序列化的。（默认情况下，基本数据类型可序列化）</p>
<p>3.自定义类中还有自定义类</p>
<p>person{</p>
<p>Account a;</p>
<p>}</p>
<p>name  static 修饰:</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/..%5CstudyNote_Pic%5Csgg%5Cday12%5C1588459508680.png" alt="1588459508680"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_14" alt="1588459683435"></p>
<p>某个部分不想序列化，  就贴个标签，static 归类所有，有自己属性不想序列化</p>
<p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
<p>应用场景: 内存中对象转化为特殊的字符串（json）</p>
<h4 id="10-随机存取文件流"><a href="#10-随机存取文件流" class="headerlink" title="10.随机存取文件流"></a>10.随机存取文件流</h4><h2 id="11-RandomAccessFile实现数据的读写操作"><a href="#11-RandomAccessFile实现数据的读写操作" class="headerlink" title="11.RandomAccessFile实现数据的读写操作"></a>11.RandomAccessFile实现数据的读写操作</h2><p>任意，既可以输入，也可以输出</p>
<p>从头开始进行覆盖</p>
<p>RandomAccessFile的使用<br>1.RandomAccessFile直接继承于java.lang.Object类，实现了DataInput和DataOutput接口<br>2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流，同一个类 不同对象<br>3.如果RandomAccessFile作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。<br>  如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</p>
<p>4.可以通过相关的操作，实现RandomAccessFile“插入”数据的效果</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_15" alt="1588459880048"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_16" alt="1588459904566">)<img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_22" alt="1588460307959"></p>
<p>文件的复制<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_23" alt="1588459927396"></p>
<p>关于输出的时候文件内容的覆盖</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_24" alt="1588460650418"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_18" alt="1588459945705"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_19" alt="1588459971010"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_20" alt="1588460005746"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_21" alt="1588460031045"></p>
<h2 id="12-RandomAccessFile实现数据的插入"><a href="#12-RandomAccessFile实现数据的插入" class="headerlink" title="12.RandomAccessFile实现数据的插入"></a>12.RandomAccessFile实现数据的插入</h2><p>seek</p>
<p>下例子是把def 覆盖掉了</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_25" alt="1588460851812"></p>
<p>raf1.seek(len)</p>
<hr>
<p>把后续数据覆盖之前取出来</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_26" alt="1588461597717"></p>
<p>​        //思考：将StringBuilder替换为ByteArrayOutputStream</p>
<p>ByteArrayOutputStream</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayOutputStreamTest</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"abc.txt"</span>);</span><br><span class="line">		String info = readStringFromInputStream(fis);</span><br><span class="line">		System.out.println(info);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">readStringFromInputStream</span><span class="params">(FileInputStream fis)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">		<span class="comment">// 方式一：可能出现乱码</span></span><br><span class="line">		<span class="comment">// String content = "";</span></span><br><span class="line">		<span class="comment">// byte[] buffer = new byte[1024];</span></span><br><span class="line">		<span class="comment">// int len;</span></span><br><span class="line">		<span class="comment">// while((len = fis.read(buffer)) != -1){</span></span><br><span class="line">		<span class="comment">// content += new String(buffer);</span></span><br><span class="line">		<span class="comment">// }</span></span><br><span class="line">		<span class="comment">// return content;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 方式二：BufferedReader</span></span><br><span class="line">		BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fis));</span><br><span class="line">		<span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		String str = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">while</span> ((len = reader.read(buf)) != -<span class="number">1</span>) {</span><br><span class="line">			str += <span class="keyword">new</span> String(buf, <span class="number">0</span>, len);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 方式三：避免出现乱码</span></span><br><span class="line">		<span class="comment">// ByteArrayOutputStream baos = new ByteArrayOutputStream();</span></span><br><span class="line">		<span class="comment">// byte[] buffer = new byte[10];</span></span><br><span class="line">		<span class="comment">// int len;</span></span><br><span class="line">		<span class="comment">// while ((len = fis.read(buffer)) != -1) {</span></span><br><span class="line">		<span class="comment">// baos.write(buffer, 0, len);</span></span><br><span class="line">		<span class="comment">// }</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// return baos.toString();</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>深入文件内部</p>
<p>应用:文件续传</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_27" alt="1588461862786"></p>
<p>####11.NIO.2中Path、Paths、Files类的使用</p>
<h2 id="13-NIO介绍及NIO2中Path、-Paths、-Files的介绍"><a href="#13-NIO介绍及NIO2中Path、-Paths、-Files的介绍" class="headerlink" title="13.NIO介绍及NIO2中Path、 Paths、 Files的介绍"></a>13.NIO介绍及NIO2中Path、 Paths、 Files的介绍</h2><p> <img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_28" alt="1588461931121"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_29" alt="1588461951448"></p>
<p>面向缓冲区<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_30" alt="1588461973076"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_31" alt="1588461991705"></p>
<p>Path 接口<br><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_32" alt="1588462010980"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_33" alt="1588462037569"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_34" alt="1588462086709"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//path  </span></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. jdk 7.0 时，引入了 Path、Paths、Files三个类。</span></span><br><span class="line"><span class="comment"> * 2.此三个类声明在：java.nio.file包下。</span></span><br><span class="line"><span class="comment"> * 3.Path可以看做是java.io.File类的升级版本。也可以表示文件或文件目录，与平台无关</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 4.如何实例化Path:使用Paths.</span></span><br><span class="line"><span class="comment"> * static Path get(String first, String … more) : 用于将多个字符串串连成路径</span></span><br><span class="line"><span class="comment"> * static Path get(URI uri): 返回指定uri对应的Path路径</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何使用Paths实例化Path</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>{</span><br><span class="line">        Path path1 = Paths.get(<span class="string">"d:\\nio\\hello.txt"</span>);<span class="comment">//new File(String filepath)</span></span><br><span class="line"></span><br><span class="line">        Path path2 = Paths.get(<span class="string">"d:\\"</span>, <span class="string">"nio\\hello.txt"</span>);<span class="comment">//new File(String parent,String filename);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(path1);</span><br><span class="line">        System.out.println(path2);</span><br><span class="line"></span><br><span class="line">        Path path3 = Paths.get(<span class="string">"d:\\"</span>, <span class="string">"nio"</span>);</span><br><span class="line">        System.out.println(path3);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path中的常用方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>{</span><br><span class="line">        Path path1 = Paths.get(<span class="string">"d:\\"</span>, <span class="string">"nio\\nio1\\nio2\\hello.txt"</span>);</span><br><span class="line">        Path path2 = Paths.get(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		String toString() ： 返回调用 Path 对象的字符串表示形式</span></span><br><span class="line">        System.out.println(path1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		boolean startsWith(String path) : 判断是否以 path 路径开始</span></span><br><span class="line">        System.out.println(path1.startsWith(<span class="string">"d:\\nio"</span>));</span><br><span class="line"><span class="comment">//		boolean endsWith(String path) : 判断是否以 path 路径结束</span></span><br><span class="line">        System.out.println(path1.endsWith(<span class="string">"hello.txt"</span>));</span><br><span class="line"><span class="comment">//		boolean isAbsolute() : 判断是否是绝对路径</span></span><br><span class="line">        System.out.println(path1.isAbsolute() + <span class="string">"~"</span>);</span><br><span class="line">        System.out.println(path2.isAbsolute() + <span class="string">"~"</span>);</span><br><span class="line"><span class="comment">//		Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</span></span><br><span class="line">        System.out.println(path1.getParent());</span><br><span class="line">        System.out.println(path2.getParent());</span><br><span class="line"><span class="comment">//		Path getRoot() ：返回调用 Path 对象的根路径</span></span><br><span class="line">        System.out.println(path1.getRoot());</span><br><span class="line">        System.out.println(path2.getRoot());</span><br><span class="line"><span class="comment">//		Path getFileName() : 返回与调用 Path 对象关联的文件名</span></span><br><span class="line">        System.out.println(path1.getFileName() + <span class="string">"~"</span>);</span><br><span class="line">        System.out.println(path2.getFileName() + <span class="string">"~"</span>);</span><br><span class="line"><span class="comment">//		int getNameCount() : 返回Path 根目录后面元素的数量</span></span><br><span class="line"><span class="comment">//		Path getName(int idx) : 返回指定索引位置 idx 的路径名称</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path1.getNameCount(); i++) {</span><br><span class="line">            System.out.println(path1.getName(i) + <span class="string">"*****"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="comment">//		Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</span></span><br><span class="line">        System.out.println(path1.toAbsolutePath());</span><br><span class="line">        System.out.println(path2.toAbsolutePath());</span><br><span class="line"><span class="comment">//		Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</span></span><br><span class="line">        Path path3 = Paths.get(<span class="string">"d:\\"</span>, <span class="string">"nio"</span>);</span><br><span class="line">        Path path4 = Paths.get(<span class="string">"nioo\\hi.txt"</span>);</span><br><span class="line">        path3 = path3.resolve(path4);</span><br><span class="line">        System.out.println(path3);</span><br><span class="line">----</span><br><span class="line">    </span><br><span class="line"><span class="comment">//		File toFile(): 将Path转化为File类的对象</span></span><br><span class="line">        File file = path1.toFile();<span class="comment">//Path---&gt;File的转换</span></span><br><span class="line"></span><br><span class="line">        Path newPath = file.toPath();<span class="comment">//File---&gt;Path的转换</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SeekableByteChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.DirectoryStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.LinkOption;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardCopyOption;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.StandardOpenOption;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Files工具类的使用：操作文件或目录的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilesTest</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>{</span><br><span class="line">		Path path1 = Paths.get(<span class="string">"d:\\nio"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">		Path path2 = Paths.get(<span class="string">"ccut.txt"</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</span></span><br><span class="line">		<span class="comment">//要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。</span></span><br><span class="line"><span class="comment">//		Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</span></span><br><span class="line">		<span class="comment">//要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。</span></span><br><span class="line">		Path path3 = Paths.get(<span class="string">"d:\\nio\\nio1"</span>);</span><br><span class="line"><span class="comment">//		Files.createDirectory(path3);</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</span></span><br><span class="line">		<span class="comment">//要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。</span></span><br><span class="line">		Path path4 = Paths.get(<span class="string">"d:\\nio\\hi.txt"</span>);</span><br><span class="line"><span class="comment">//		Files.createFile(path4);</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</span></span><br><span class="line"><span class="comment">//		Files.delete(path4);</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</span></span><br><span class="line">		Files.deleteIfExists(path3);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</span></span><br><span class="line">		<span class="comment">//要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。</span></span><br><span class="line"><span class="comment">//		Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">//		long size(Path path) : 返回 path 指定文件的大小</span></span><br><span class="line">		<span class="keyword">long</span> size = Files.size(path2);</span><br><span class="line">		System.out.println(size);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>{</span><br><span class="line">		Path path1 = Paths.get(<span class="string">"d:\\nio"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line">		Path path2 = Paths.get(<span class="string">"ccut.txt"</span>);</span><br><span class="line"><span class="comment">//		boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</span></span><br><span class="line">		System.out.println(Files.exists(path2, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line"><span class="comment">//		boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</span></span><br><span class="line">		<span class="comment">//不要求此path对应的物理文件存在。</span></span><br><span class="line">		System.out.println(Files.isDirectory(path1, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line"><span class="comment">//		boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//		boolean isHidden(Path path) : 判断是否是隐藏文件</span></span><br><span class="line">		<span class="comment">//要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。</span></span><br><span class="line"><span class="comment">//		System.out.println(Files.isHidden(path1));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//		boolean isReadable(Path path) : 判断文件是否可读</span></span><br><span class="line">		System.out.println(Files.isReadable(path1));</span><br><span class="line"><span class="comment">//		boolean isWritable(Path path) : 判断文件是否可写</span></span><br><span class="line">		System.out.println(Files.isWritable(path1));</span><br><span class="line"><span class="comment">//		boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</span></span><br><span class="line">		System.out.println(Files.notExists(path1, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * StandardOpenOption.READ:表示对应的Channel是可读的。</span></span><br><span class="line"><span class="comment">	 * StandardOpenOption.WRITE：表示对应的Channel是可写的。</span></span><br><span class="line"><span class="comment">	 * StandardOpenOption.CREATE：如果要写出的文件不存在，则创建。如果存在，忽略</span></span><br><span class="line"><span class="comment">	 * StandardOpenOption.CREATE_NEW：如果要写出的文件不存在，则创建。如果存在，抛异常</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>{</span><br><span class="line">		Path path1 = Paths.get(<span class="string">"d:\\nio"</span>, <span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</span></span><br><span class="line">		InputStream inputStream = Files.newInputStream(path1, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</span></span><br><span class="line">		OutputStream outputStream = Files.newOutputStream(path1, StandardOpenOption.WRITE,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//		SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</span></span><br><span class="line">		SeekableByteChannel channel = Files.newByteChannel(path1, StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//		DirectoryStream&lt;Path&gt;  newDirectoryStream(Path path) : 打开 path 指定的目录</span></span><br><span class="line">		Path path2 = Paths.get(<span class="string">"e:\\teach"</span>);</span><br><span class="line">		DirectoryStream&lt;Path&gt; directoryStream = Files.newDirectoryStream(path2);</span><br><span class="line">		Iterator&lt;Path&gt; iterator = directoryStream.iterator();</span><br><span class="line">		<span class="keyword">while</span>(iterator.hasNext()){</span><br><span class="line">			System.out.println(iterator.next());</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="14-使用第三方jar包实现数据读写"><a href="#14-使用第三方jar包实现数据读写" class="headerlink" title="14. 使用第三方jar包实现数据读写"></a>14. 使用第三方jar包实现数据读写</h2><p>apache-common.jar</p>
<hr>
<p>commons-io-2.5.jar</p>
<p>day10-&gt;新建Directory   lib–&gt;粘贴</p>
<p>点击jar包 右键Add as Library</p>
<p>实际生产用已经写好的jar包</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_35" alt="1588463430993"></p>
<h2 id="15-网络编程概述"><a href="#15-网络编程概述" class="headerlink" title="15.网络编程概述"></a>15.网络编程概述</h2><h3 id="1-网络编程概述"><a href="#1-网络编程概述" class="headerlink" title="1.网络编程概述"></a>1.网络编程概述</h3><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_36" alt="1588464193996"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_37" alt="1588464262808"></p>
<p>传输的协议</p>
<h3 id="2-网络通信要素概述"><a href="#2-网络通信要素概述" class="headerlink" title="2.网络通信要素概述"></a>2.网络通信要素概述</h3><p>IP和端口号<br>网络通信协议</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_38" alt="1588464580715"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_39" alt="1588464678863"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_40" alt="1588464792939"></p>
<p>类似:快递</p>
<p>一、网络编程中有两个主要的问题：<br>1.如何准确地定位网络上一台或多台主机；定位主机上的特定的应用<br>2.找到主机后如何可靠高效地进行数据传输<br> 二、网络编程中的两个要素：<br>1.对应问题一：IP和端口号<br>2.对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层）</p>
<h3 id="3-通信要素1-IP和端口号"><a href="#3-通信要素1-IP和端口号" class="headerlink" title="3.通信要素1 : IP和端口号"></a>3.通信要素1 : IP和端口号</h3><h2 id="16-IP的理解与InetAddress类的实例化"><a href="#16-IP的理解与InetAddress类的实例化" class="headerlink" title="16.IP的理解与InetAddress类的实例化"></a>16.IP的理解与InetAddress类的实例化</h2><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/..%5CstudyNote_Pic%5Csgg%5Cday12%5C1588467405691.png" alt="1588467405691"></p>
<p>三、通信要素一：IP和端口号</p>
<ol>
<li>IP:唯一的标识 Internet 上的计算机（通信实体）</li>
<li>在Java中使用InetAddress类代表IP</li>
<li>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</li>
<li>域名:   <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>   <a href="http://www.mi.com" target="_blank" rel="noopener">www.mi.com</a>  <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a>  <a href="http://www.jd.com" target="_blank" rel="noopener">www.jd.com</a><pre><code>www.vip.com</code></pre></li>
<li>本地回路地址：127.0.0.1 对应着：localhost</li>
<li>如何实例化InetAddress:两个方法：getByName(String host) 、 getLocalHost()<pre><code>两个常用方法：getHostName() / getHostAddress()</code></pre></li>
<li>端口号：正在计算机上运行的进程。<br>要求：不同的进程有不同的端口号<br>范围：被规定为一个 16 位的整数 0~65535。</li>
<li>端口号与IP地址的组合得出一个网络套接字：Socket</li>
</ol>
<p>InetAddress</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_41" alt="1588467722342"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_42" alt="1588467749562"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_44" alt="1588468076775"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_43" alt="如何实例化InetAddress"></p>
<h2 id="17-端口号的理解"><a href="#17-端口号的理解" class="headerlink" title="17.端口号的理解"></a>17.端口号的理解</h2><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_45" alt="1588468287432"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_46" alt="1588468395688"></p>
<p>又称socket的编程</p>
<h3 id="4-通信要素2-网络协议"><a href="#4-通信要素2-网络协议" class="headerlink" title="4.通信要素2 :网络协议"></a>4.通信要素2 :网络协议</h3><h2 id="18-TCP和UDP网络通信协议的对比"><a href="#18-TCP和UDP网络通信协议的对比" class="headerlink" title="18.TCP和UDP网络通信协议的对比."></a>18.TCP和UDP网络通信协议的对比.</h2><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_47" alt="1588468628926"></p>
<p>传输层和网络层</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_48" alt="1588468650740"></p>
<p>效率高 速度开  udp –&gt;  播放视频</p>
<p>TCP生活案例:打电话<br>UDP生活案例:发送短信、发电报</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_49" alt="1588468669762"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_50" alt="1588468691949"></p>
<p> 离别 <img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_76" alt="1588468711223"></p>
<p> 客户端或服务器均可主动发起挥手动作，在socket编程中，任何-方执行close(操作即可产生挥手操作。<br>(1)客户端A发送个FIN，用来关闭客户A到服务器B的数据传送，<br>(2 )服务器B收到这个FIN，它发回-个ACK，确认序号为收到序号加1。和SYN-样，一个FIN将占用一一个序号。<br>(3 )服务器B关闭与客户端A的连接，发送个FIN给客户端A。<br>(4)客户端A发回ACK报文确认,并将确认序号设置为收到序号加1。</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_51" alt="1588468724985"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_52" alt="1588468748340"></p>
<h3 id="5-TCP网络编程"><a href="#5-TCP网络编程" class="headerlink" title="5.TCP网络编程"></a>5.TCP网络编程</h3><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_53" alt="1588470164073"></p>
<h2 id="19-TCP网络编程例题1"><a href="#19-TCP网络编程例题1" class="headerlink" title="19.-TCP网络编程例题1"></a>19.-TCP网络编程例题1</h2><p>例子1：客户端发送信息给服务端，服务端将数据显示在控制台上</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现TCP的网络编程</span></span><br><span class="line"><span class="comment"> * 例子1：客户端发送信息给服务端，服务端将数据显示在控制台上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPTest1</span> </span>{</span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span>  </span>{</span><br><span class="line">        Socket socket = <span class="keyword">null</span>; </span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            InetAddress inet = InetAddress.getByName(<span class="string">"192.168.14.100"</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(inet,<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">"你好，我是客户端mm"</span>.getBytes());</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    os.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    socket.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span>  </span>{</span><br><span class="line">        ServerSocket ss = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> ServerSocket(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">//3.获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            <span class="comment">//不建议这样写，可能会有乱码</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">//        int len;</span></span><br><span class="line"><span class="comment">//        while((len = is.read(buffer)) != -1){</span></span><br><span class="line"><span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">//            System.out.print(str);</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">            <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>){</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">            <span class="comment">//看谁给我发的</span></span><br><span class="line">            System.out.println(<span class="string">"收到了来自于："</span> + socket.getInetAddress().getHostAddress() + <span class="string">"的数据"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="keyword">null</span>){</span><br><span class="line">                <span class="comment">//5.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    baos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    is.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    socket.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    ss.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>岛 —  》岛 的贸易   港口</p>
<h2 id="20-TCP网络编程例题2"><a href="#20-TCP网络编程例题2" class="headerlink" title="20.TCP网络编程例题2"></a>20.TCP网络编程例题2</h2><p> 相亲     2.客户端发送文件给服务端，服务端将文件保存在本地。</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_54" alt="1588470827777"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_77" alt="1588470923833"></p>
<ol>
<li>造ss</li>
<li>获取客户端socket</li>
<li>获取客户端的输入流</li>
</ol>
<p>4.保留数据到本地</p>
<p>5.读写过程</p>
<p>6.关闭资源流</p>
<h2 id="21-TCP网络编程例题"><a href="#21-TCP网络编程例题" class="headerlink" title="21.TCP网络编程例题"></a>21.TCP网络编程例题</h2><p> 例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</p>
<p>服务器端</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_55" alt="1588471281061"></p>
<p>os.close</p>
<p>客户端socket.shutdownOutput()  告诉数据结束      阻塞式的操作</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/..%5CstudyNote_Pic%5Csgg%5Cday12%5C1588471342577.png" alt="1588471342577"></p>
<p>baos.close()</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_56" alt="1588471717026"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_57" alt="1588471743634"></p>
<h2 id="22-浏览器访问Tomcat服务器资源操作"><a href="#22-浏览器访问Tomcat服务器资源操作" class="headerlink" title="22.浏览器访问Tomcat服务器资源操作"></a>22.浏览器访问Tomcat服务器资源操作</h2><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_59" alt="1588472199840"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_58" alt="1588472130611"></p>
<h3 id="6-UDP网络编程"><a href="#6-UDP网络编程" class="headerlink" title="6.UDP网络编程"></a>6.UDP网络编程</h3><h2 id="23-UDP网络编程举例"><a href="#23-UDP网络编程举例" class="headerlink" title="23.UDP网络编程举例"></a>23.UDP网络编程举例</h2><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_60" alt="1588472746348"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_61" alt="1588472798300"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_62" alt="1588472820811"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_63" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_64" alt="1588472841104"></p>
<h3 id="7-URL编程"><a href="#7-URL编程" class="headerlink" title="7.URL编程"></a>7.URL编程</h3><h2 id="24-URL类的理解与实例化"><a href="#24-URL类的理解与实例化" class="headerlink" title="24.URL类的理解与实例化"></a>24.URL类的理解与实例化</h2><p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_66" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_67" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_68" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_69" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_70" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_71" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_72" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_73" alt="1588472841104"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_74" alt="1588472841104"></p>
<h2 id="25-URL网络编程实现Tomcat服务端数据下载"><a href="#25-URL网络编程实现Tomcat服务端数据下载" class="headerlink" title="25. URL网络编程实现Tomcat服务端数据下载"></a>25. URL网络编程实现Tomcat服务端数据下载</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLTest1</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">"http://localhost:8080/examples/beauty.jpg"</span>);</span><br><span class="line"></span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">            urlConnection.connect();</span><br><span class="line">            is = urlConnection.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"day10\\beauty3.jpg"</span>);</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>){</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            }</span><br><span class="line">            System.out.println(<span class="string">"下载完成"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(is != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    is.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(urlConnection != <span class="keyword">null</span>){</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/09/2016-07-09-io-liu-yu-wang-luo-bian-cheng/27_75" alt="1588475311186"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2017/07/09/2016-07-09-io-liu-m/</url>
    <content><![CDATA[<h2 id="1-每日一问"><a href="#1-每日一问" class="headerlink" title="1.每日一问"></a>1.每日一问</h2><p>1.如何遍历Map的key集，value集,key-value集，使用上泛型</p>
<p>Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();<br>map.put();….<br>//遍历key<br>Set<string> keySet = map.keySet();<br>for(String key : keySet){<br>    System.out.println(key);<br>}</string></p>
<p>//遍历value<br>Collection<integer> values = map.values();<br>Iterator<integer> iterator = values.iterator();<br>while(iterator.hasNext()){<br>    System.out.println(iterator.next());<br>}</integer></integer></p>
<p>//遍历key-value<br>Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();<br>Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iterator =  entrySet.iterator();<br>while(iterator.hasNext()){<br>    Map.Entry&lt;String,Integer&gt; entry = iterator.next();<br>    String key = entry.getKey();<br>    Integer value = entry.getValue();<br>    System.out.println(key + “—&gt;” + value);<br>}</p>
<ol start="2">
<li>写出使用Iterator 和 增强for 循环遍历List<string>的代码,使用上泛型</string></li>
</ol>
<ol start="3">
<li>提供一个方法，用于遍历获取HashMap&lt;String,String&gt;中的所有value，并存放在List中返回。考虑上集合中泛型的使用。</li>
</ol>
<p>public List<string> getValueList(HashMap&lt;String,String&gt; map){<br>    ArrayList<string> valueList = new ArrayList&lt;&gt;():<br>    Collection<string> values = map.values();<br>    for(String value : values){<br>        valueList.add(value);<br>    }<br>    return valueList;<br>}</string></string></string></p>
<ol start="4">
<li>创建一个与a.txt文件同目录下的另外一个文件b.txt</li>
</ol>
<p>File file1 = new File(“d:\a\a.txt”);<br>File file2 = new File(file1.getParent(),”b.txt”);</p>
<ol start="5">
<li>Map接口中的常用方法有哪些<br>增：put(K k,V v)<br>删: V remove(K k)<br>改: put(K k,V v)<br>查: V get(K k)<br>长度:int size()<br>遍历</li>
</ol>
<h2 id="2-复习-集合中使用泛型"><a href="#2-复习-集合中使用泛型" class="headerlink" title="2.复习 集合中使用泛型"></a>2.复习 集合中使用泛型</h2><h3 id="泛型的理解"><a href="#泛型的理解" class="headerlink" title="泛型的理解"></a>泛型的理解</h3><p>1.泛型的概念<br>所谓泛型，就是允许在定义类、接口时通过一-个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时(例如，继承或实现这个接口，用这个类型声明变量、创建对象时)确定(即传入实际的类型参数，也称为类型实参)。</p>
<p>2.泛型的引入背景</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_17" alt="1588403457111"></p>
<h3 id="泛型在集合中的使用-豆腐渣工程"><a href="#泛型在集合中的使用-豆腐渣工程" class="headerlink" title="泛型在集合中的使用   豆腐渣工程"></a>泛型在集合中的使用   豆腐渣工程</h3><p>1.在集合中使用泛型之前的例子<br><img src="/2017/07/09/2016-07-09-io-liu-m/25_05" alt="1588324328690"><br>图示:<img src="/2017/07/09/2016-07-09-io-liu-m/26_18" alt="1588403626585"></p>
<p>2.在集合中使用泛型例子1</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/25_06" alt="1588324618982"></p>
<p>图示: .</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_19" alt="1588403716535"></p>
<p>我要卖下了你</p>
<p>3.在集合中使用泛型例子2</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/25_07" alt="1588325149840"></p>
<p>自然排序和定制排序</p>
<p>4.集合中使用泛型总结: </p>
<p> 总结：<br> ① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。<br> ② 在实例化集合类时，可以指明具体的泛型类型<br> ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。<br>   比如：add(E e)  —&gt;实例化以后：add(Integer e)<br> ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换<br> ⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。</p>
<h2 id="3-复习-自定义泛型结构与通配符"><a href="#3-复习-自定义泛型结构与通配符" class="headerlink" title="3.复习 :自定义泛型结构与通配符"></a>3.复习 :自定义泛型结构与通配符</h2><h3 id="自定义泛型类、泛型接口、泛型方法"><a href="#自定义泛型类、泛型接口、泛型方法" class="headerlink" title="自定义泛型类、泛型接口、泛型方法"></a>自定义泛型类、泛型接口、泛型方法</h3><p>1.举例:<br>[0rder.java.</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/25_13" alt="1588326158843"></p>
<p>[Sub0rder. java]</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/25_15" alt="1588326532877"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOrder</span> <span class="keyword">extends</span> <span class="title">Order</span>&lt;<span class="title">Integer</span>&gt; </span>{<span class="comment">//SubOrder:不是泛型类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span>{</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(E e : arr){</span><br><span class="line">            list.add(e);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>//实例化时 ，如下代码是错误的</p>
<p>SubOrder<integer> o=new SubOrder&lt;&gt;();    不对  不是泛型类</integer></p>
<p>[Sub0rder1. java]</p>
<p>public class SubOrder1<t> extends Order<t> {//SubOrder1<t>:仍然是泛型类<br>}</t></t></t></p>
<p>[测试]</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 如何自定义泛型结构：泛型类、泛型接口；泛型方法。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 关于自定义泛型类、泛型接口：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest1</span> </span>{</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">        <span class="comment">//要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setOrderT(<span class="number">123</span>);</span><br><span class="line">        order.setOrderT(<span class="string">"ABC"</span>);</span><br><span class="line">        <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">        Order&lt;String&gt; order1 = <span class="keyword">new</span> Order&lt;String&gt;(<span class="string">"orderAA"</span>,<span class="number">1001</span>,<span class="string">"order:AA"</span>);</span><br><span class="line">        order1.setOrderT(<span class="string">"AA:hello"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">        SubOrder sub1 = <span class="keyword">new</span> SubOrder();</span><br><span class="line">        <span class="comment">//由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型。</span></span><br><span class="line">        sub1.setOrderT(<span class="number">1122</span>);</span><br><span class="line">        SubOrder1&lt;String&gt; sub2 = <span class="keyword">new</span> SubOrder1&lt;&gt;();</span><br><span class="line">        sub2.setOrderT(<span class="string">"order2..."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//泛型不同的引用不能相互赋值。</span></span><br><span class="line"><span class="comment">//        list1 = list2;</span></span><br><span class="line">        Person p1 = <span class="keyword">null</span>;</span><br><span class="line">        Person p2 = <span class="keyword">null</span>;</span><br><span class="line">        p1 = p2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试泛型方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>{</span><br><span class="line">        Order&lt;String&gt; order = <span class="keyword">new</span> Order&lt;&gt;();</span><br><span class="line">        Integer[] arr = <span class="keyword">new</span> Integer[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};</span><br><span class="line">        <span class="comment">//泛型方法在调用时，指明泛型参数的类型。</span></span><br><span class="line">        List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line">        </span><br><span class="line">        System.out.println(list);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>2.注意点:  1-12</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/25_21" alt="1588326848230"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/25_23" alt="1588326912345"><br>3.应用场景举例:<br>[DAO.java] :定义了操作数据库中表的通用操作</p>
<p>[DAO.java] :定义了操作数据库中的表的通用操作。ORM思想(数据 库中的表和Java中的类对应)<br>……….</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DAO:data(base) access object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAO</span>&lt;<span class="title">T</span>&gt; </span>{<span class="comment">//表的共性操作的DAO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index,T t)</span></span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询一条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询多条记录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getForList</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="comment">//举例：获取表中一共有多少条记录？获取最大的员工入职时间？</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">getValue</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>[CustomerDAO. java] : </p>
<p>·public class CustomerDAO extends DAO<customer>{//只能操作某一个表的DAO<br>}</customer></p>
<p>[ StudentDAO.java] :.</p>
<p>public class StudentDAO extends DAO<student> {//只能操作某一个表的DAO<br>}</student></p>
<h3 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        obj = str;</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">null</span>;</span><br><span class="line">        String[] arr2 = <span class="keyword">null</span>;</span><br><span class="line">        arr1 = arr2;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        Date date = new Date();</span></span><br><span class="line"><span class="comment">//        str = date;</span></span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">//此时的list1和list2的类型不具有子父类关系</span></span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        list1 = list2;</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设list1 = list2;</span></span><br><span class="line"><span class="comment">           list1.add(123);导致混入非String的数据。出错。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        show(list1);</span><br><span class="line">        show1(list2);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">(List&lt;String&gt; list)</span></span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(List&lt;Object&gt; list)</span></span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">        AbstractList&lt;String&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list3 = <span class="keyword">null</span>;</span><br><span class="line">        list1 = list3;</span><br><span class="line">        list2 = list3;</span><br><span class="line">        List&lt;String&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>1.通配符的使用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 通配符的使用</span></span><br><span class="line"><span class="comment">       通配符：?</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没有关系的，二者共同的父类是：G&lt;?&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        list = list1;</span><br><span class="line">        list = list2;</span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line"><span class="comment">//        print(list1);</span></span><br><span class="line"><span class="comment">//        print(list2);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        List&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list3.add(<span class="string">"AA"</span>);</span><br><span class="line">        list3.add(<span class="string">"BB"</span>);</span><br><span class="line">        list3.add(<span class="string">"CC"</span>);</span><br><span class="line">        list = list3;</span><br><span class="line">        <span class="comment">//添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</span></span><br><span class="line">        <span class="comment">//除了添加null之外。</span></span><br><span class="line"><span class="comment">//        list.add("DD");</span></span><br><span class="line"><span class="comment">//        list.add('?');</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">        Object o = list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span></span>{</span><br><span class="line">        Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext()){</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br></pre></td></tr></tbody></table></figure>



<p>2.涉及通配符的集合的数据的写入和读取:</p>
<p>见上</p>
<p>3.有限制条件的通配符的使用</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    3.有限制条件的通配符的使用。</span></span><br><span class="line"><span class="comment">        ? extends A:</span></span><br><span class="line"><span class="comment">                G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        ? super A:</span></span><br><span class="line"><span class="comment">                G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">        List&lt;? extends Person&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;? <span class="keyword">super</span> Person&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        List&lt;Person&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        List&lt;Object&gt; list5 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        list1 = list3;</span><br><span class="line">        list1 = list4;</span><br><span class="line"><span class="comment">//        list1 = list5;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        list2 = list3;</span></span><br><span class="line">        list2 = list4;</span><br><span class="line">        list2 = list5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据：</span></span><br><span class="line">        list1 = list3;</span><br><span class="line">        Person p = list1.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">        list2 = list4;</span><br><span class="line">        Object obj = list2.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">////编译不通过</span></span><br><span class="line"><span class="comment">//        Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据：</span></span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        list2.add(<span class="keyword">new</span> Person());</span><br><span class="line">        list2.add(<span class="keyword">new</span> Student());</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-File-类的使用"><a href="#4-File-类的使用" class="headerlink" title="4.File 类的使用"></a>4.File 类的使用</h2><p>1.File类的理解</p>
<blockquote>
<ol>
<li>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</li>
<li>File类声明在java.io包下</li>
<li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li>
<li>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”</li>
</ol>
</blockquote>
<p>2.File的实例化<br>2.1常用构造器</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">File(String filePath)</span><br><span class="line">  File(String parentPath,String childPath)</span><br><span class="line">  File(File parentFile,String childPath)</span><br></pre></td></tr></tbody></table></figure>

<p>2.2路径的分类</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">相对路径：相较于某个路径下，指明的路径。 当前 相对于当前module   ，注意main方法在工程下</span><br><span class="line">绝对路径：包含盘符在内的文件或文件目录的路径</span><br><span class="line">如果大家开发使用JUinit中的单元测试方法测试，相对路径即为当前Module下。</span><br><span class="line">如果大家使用main()测试，相对路径即为当前的Project 下。</span><br><span class="line">Eclipse中:</span><br><span class="line">不管使用单元测试方法还是使用main0测试，相对路径都是当前的Project下。</span><br></pre></td></tr></tbody></table></figure>

<p>2.3路径分隔符</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">windows:\\\</span><br><span class="line"> unix:/</span><br></pre></td></tr></tbody></table></figure>

<p>3.File类的常用方法</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/..%5CstudyNote_Pic%5Csgg%5Cday12%5C26_10" alt="1588338624479"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/..%5CstudyNote_Pic%5Csgg%5Cday12%5C26_04" alt="1588338632357"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/..%5CstudyNote_Pic%5Csgg%5Cday12%5C26_05" alt="1588338672998"></p>
<h4 id="1-File类的使用"><a href="#1-File类的使用" class="headerlink" title="1.File类的使用"></a>1.File类的使用</h4><h4 id="3-节点流-或文件流"><a href="#3-节点流-或文件流" class="headerlink" title="3.节点流(或文件流)"></a>3.节点流(或文件流)</h4><h4 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4.缓冲流"></a>4.缓冲流</h4><h4 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5.转换流"></a>5.转换流</h4><h2 id="1-1-File类的实例化"><a href="#1-1-File类的实例化" class="headerlink" title="1.1 File类的实例化"></a>1.1 File类的实例化</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_01" alt="1588335327191"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_02" alt="1588338547816"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_03" alt="1588338596532"></p>
<hr>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_06" alt="1588338725336"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_07" alt="1588338745903"></p>
<ol>
<li><p>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</p>
</li>
<li><p>File类声明在java.io包下</p>
</li>
<li><p>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，<br>并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</p>
</li>
<li><p>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”.</p>
<p>1.如何创建File类的实例</p>
<pre><code>File(String filePath)
File(String parentPath,String childPath)
File(File parentFile,String childPath)</code></pre></li>
</ol>
<p>2.<br>    相对路径：相较于某个路径下，指明的路径。 当前 相对于当前module<br>    绝对路径：包含盘符在内的文件或文件目录的路径</p>
<p>3.路径分隔符<br>     windows:\<br>     unix:/<br>    <img src="/2017/07/09/2016-07-09-io-liu-m/26_09" alt="1588339469409"></p>
<h2 id="1-2File类的常用方法1"><a href="#1-2File类的常用方法1" class="headerlink" title="1.2File类的常用方法1"></a>1.2File类的常用方法1</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/..%5CstudyNote_Pic%5Csgg%5Cday12%5C26_10" alt="1588338624479"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_11" alt="1588340141873"></p>
<p>若不存在文件设置默认值</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如下的两个方法适用于文件目录：</span><br><span class="line">public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</span><br><span class="line">public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_12" alt="1588340290292"></p>
<p>1 是相对于路径       public File[] listFiles()  绝对路径</p>
<hr>
<p>  public boolean renameTo(File dest):把文件重命名为指定的文件路径<br>     比如：file1.renameTo(file2)为例：       ==移动文件<br>        要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_13" alt="1588340420160"></p>
<ul>
<li><p>如果被重命名的文件已存在，那么renameTo()不会成功</p>
</li>
<li><p>renameTo()成功后，原文件会被删除</p>
<hr>
<h2 id="1-3-File类的常用方法2"><a href="#1-3-File类的常用方法2" class="headerlink" title="1.3 File类的常用方法2"></a>1.3 File类的常用方法2</h2><p>加红的常被用到</p>
</li>
</ul>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/..%5CstudyNote_Pic%5Csgg%5Cday12%5C26_04" alt="1588338632357"></p>
<p>public boolean isDirectory()：判断是否是文件目录<br>public boolean isFile() ：判断是否是文件<br>public boolean exists() ：判断是否存在<br>public boolean canRead() ：判断是否可读<br>public boolean canWrite() ：判断是否可写<br>public boolean isHidden() ：判断是否隐藏</p>
<p>hello.txt 在硬盘中存在， io1 目录</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_14" alt="1588340947085"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/..%5CstudyNote_Pic%5Csgg%5Cday12%5C26_05" alt="1588338672998"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">创建硬盘中对应的文件或文件目录</span><br><span class="line">public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回falsepublic </span><br><span class="line">boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</span><br><span class="line">public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建    </span><br><span class="line">删除磁盘中的文件或文件目录</span><br><span class="line">public boolean delete()：删除文件或者文件夹    删除注意事项：Java中的删除不走回收站。</span><br></pre></td></tr></tbody></table></figure>



<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_15" alt="1588341273856"></p>
<ol>
<li>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)</li>
<li>File类声明在java.io包下</li>
<li>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，<br>并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li>
<li>后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”.</li>
</ol>
<h2 id="1-4-File类的课后练习"><a href="#1-4-File类的课后练习" class="headerlink" title="1.4 File类的课后练习"></a>1.4 File类的课后练习</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_08" alt="1588338769982"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_16" alt="1588341831135"></p>
<ol start="2">
<li><p>endwiths</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 课后练习2：判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindJPGFileTest</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">		File srcFile = <span class="keyword">new</span> File(<span class="string">"d:\\code"</span>);</span><br><span class="line">		</span><br><span class="line">		String[] fileNames = srcFile.list();</span><br><span class="line">		<span class="keyword">for</span>(String fileName : fileNames){</span><br><span class="line">			<span class="keyword">if</span>(fileName.endsWith(<span class="string">".jpg"</span>)){</span><br><span class="line">				System.out.println(fileName);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>{</span><br><span class="line">		File srcFile = <span class="keyword">new</span> File(<span class="string">"d:\\code"</span>);</span><br><span class="line">		</span><br><span class="line">		File[] listFiles = srcFile.listFiles();</span><br><span class="line">		<span class="keyword">for</span>(File file : listFiles){</span><br><span class="line">			<span class="keyword">if</span>(file.getName().endsWith(<span class="string">".jpg"</span>)){</span><br><span class="line">				System.out.println(file.getAbsolutePath());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * File类提供了两个文件过滤器方法</span></span><br><span class="line"><span class="comment">	 * public String[] list(FilenameFilter filter)</span></span><br><span class="line"><span class="comment">	 * public File[] listFiles(FileFilter filter)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">		File srcFile = <span class="keyword">new</span> File(<span class="string">"d:\\code"</span>);</span><br><span class="line">		</span><br><span class="line">		File[] subFiles = srcFile.listFiles(<span class="keyword">new</span> FilenameFilter() {</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>{</span><br><span class="line">				<span class="keyword">return</span> name.endsWith(<span class="string">".jpg"</span>);</span><br><span class="line">			}</span><br><span class="line">		});</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(File file : subFiles){</span><br><span class="line">			System.out.println(file.getAbsolutePath());</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>3.递归</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3. 遍历指定目录所有文件名称，包括子文件目录中的文件。</span></span><br><span class="line"><span class="comment">	拓展1：并计算指定目录占用空间的大小     file 才有大小</span></span><br><span class="line"><span class="comment">	拓展2：删除指定文件目录及其下的所有文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFilesTest</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">// 递归:文件目录</span></span><br><span class="line">		<span class="comment">/** 打印出指定目录所有文件名称，包括子文件目录中的文件 */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1.创建目录对象</span></span><br><span class="line">		File dir = <span class="keyword">new</span> File(<span class="string">"E:\\teach\\01_javaSE\\_尚硅谷Java编程语言\\3_软件"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.打印目录的子文件</span></span><br><span class="line">		printSubFile(dir);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSubFile</span><span class="params">(File dir)</span> </span>{</span><br><span class="line">		<span class="comment">// 打印目录的子文件</span></span><br><span class="line">		File[] subfiles = dir.listFiles();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (File f : subfiles) {</span><br><span class="line">			<span class="keyword">if</span> (f.isDirectory()) {<span class="comment">// 文件目录</span></span><br><span class="line">				printSubFile(f);</span><br><span class="line">			} <span class="keyword">else</span> {<span class="comment">// 文件</span></span><br><span class="line">				System.out.println(f.getAbsolutePath());</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方式二：循环实现</span></span><br><span class="line">	<span class="comment">// 列出file目录的下级内容，仅列出一级的话</span></span><br><span class="line">	<span class="comment">// 使用File类的String[] list()比较简单</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listSubFiles</span><span class="params">(File file)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) {</span><br><span class="line">			String[] all = file.list();</span><br><span class="line">			<span class="keyword">for</span> (String s : all) {</span><br><span class="line">				System.out.println(s);</span><br><span class="line">			}</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			System.out.println(file + <span class="string">"是文件！"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 列出file目录的下级，如果它的下级还是目录，接着列出下级的下级，依次类推</span></span><br><span class="line">	<span class="comment">// 建议使用File类的File[] listFiles()</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listAllSubFiles</span><span class="params">(File file)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (file.isFile()) {</span><br><span class="line">			System.out.println(file);</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			File[] all = file.listFiles();</span><br><span class="line">			<span class="comment">// 如果all[i]是文件，直接打印</span></span><br><span class="line">			<span class="comment">// 如果all[i]是目录，接着再获取它的下一级</span></span><br><span class="line">			<span class="keyword">for</span> (File f : all) {</span><br><span class="line">				listAllSubFiles(f);<span class="comment">// 递归调用：自己调用自己就叫递归</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拓展1：求指定目录所在空间的大小</span></span><br><span class="line">	<span class="comment">// 求任意一个目录的总大小</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDirectorySize</span><span class="params">(File file)</span> </span>{</span><br><span class="line">		<span class="comment">// file是文件，那么直接返回file.length()</span></span><br><span class="line">		<span class="comment">// file是目录，把它的下一级的所有大小加起来就是它的总大小</span></span><br><span class="line">		<span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (file.isFile()) {</span><br><span class="line">			size += file.length();</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			File[] all = file.listFiles();<span class="comment">// 获取file的下一级</span></span><br><span class="line">			<span class="comment">// 累加all[i]的大小</span></span><br><span class="line">			<span class="keyword">for</span> (File f : all) {</span><br><span class="line">				size += getDirectorySize(f);<span class="comment">// f的大小;</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 拓展2：删除指定的目录</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteDirectory</span><span class="params">(File file)</span> </span>{</span><br><span class="line">		<span class="comment">// 如果file是文件，直接delete</span></span><br><span class="line">		<span class="comment">// 如果file是目录，先把它的下一级干掉，然后删除自己</span></span><br><span class="line">		<span class="keyword">if</span> (file.isDirectory()) {</span><br><span class="line">			File[] all = file.listFiles();</span><br><span class="line">			<span class="comment">// 循环删除的是file的下一级</span></span><br><span class="line">			<span class="keyword">for</span> (File f : all) {<span class="comment">// f代表file的每一个下级</span></span><br><span class="line">				deleteDirectory(f);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">// 删除自己</span></span><br><span class="line">		file.delete();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h4 id="2-IO流原理及流的分类-忘了见了再瞧一瞧，来回看"><a href="#2-IO流原理及流的分类-忘了见了再瞧一瞧，来回看" class="headerlink" title="2.IO流原理及流的分类      忘了见了再瞧一瞧，来回看"></a>2.IO流原理及流的分类      忘了见了再瞧一瞧，来回看</h4><h2 id="5-IO流概述与流的分类"><a href="#5-IO流概述与流的分类" class="headerlink" title="5.IO流概述与流的分类."></a>5.IO流概述与流的分类.</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_20" alt="1588405988816"></p>
<p>水流  电流  数据流  read write (<code>以内存为基准</code>)   借钱</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_21" alt="1588406006506"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_22" alt="1588406030020"></p>
<p>操作流的基本单位: 字节流和字符流</p>
<p>字节是byte（图片 视频等非文本数据）  字符是char()</p>
<p>直接作用文件上称为节点流，|，在节点流外面  又包了一层（处理流   加快流的速度）</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_32" alt="1588406052096"></p>
<h2 id="6-IO流的体系结构"><a href="#6-IO流的体系结构" class="headerlink" title="6.IO流的体系结构"></a>6.IO流的体系结构</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_33" alt="1588411122365"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_23" alt="1588406068349"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_24" alt="1588429011700"></p>
<p>访问文件是节点流，访问文件、缓冲流 转换流</p>
<p>一、流的分类：<br>1.操作数据单位：字节流、字符流<br>2.数据的流向：输入流、输出流<br>3.流的角色：节点流、处理流<br> *<br>二、流的体系结构<br>抽象基类         节点流（或文件流）                               缓冲流（处理流的一种）<br>InputStream     FileInputStream   (read(byte[] buffer))        BufferedInputStream (read(byte[] buffer))<br>OutputStream    FileOutputStream  (write(byte[] buffer,0,len)  BufferedOutputStream (write(byte[] buffer,0,len) / flush()<br>Reader          FileReader (read(char[] cbuf))                 BufferedReader (read(char[] cbuf) / readLine())<br>Writer          FileWriter (write(char[] cbuf,0,len)           BufferedWriter (write(char[] cbuf,0,len) / flush()</p>
<h2 id="7-FileReader读入数据的基本操作"><a href="#7-FileReader读入数据的基本操作" class="headerlink" title="7.FileReader读入数据的基本操作"></a>7.FileReader读入数据的基本操作</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_34" alt="1588411839815"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_35" alt="方式一"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_36" alt="1588412292551"></p>
<p>throws 处理异常 不怎么好</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">说明点：1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</span><br><span class="line">2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理</span><br><span class="line">3. 读入的文件一定要存在，否则就会报FileNotFoundException。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReader</span><span class="params">()</span></span>{</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);<span class="comment">//相较于当前Module</span></span><br><span class="line">            <span class="comment">//2.提供具体的流</span></span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">            <span class="comment">//3.数据的读入</span></span><br><span class="line">            <span class="comment">//方式二：语法上针对于方式一的修改</span></span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span>((data = fr.read()) != -<span class="number">1</span>){</span><br><span class="line">                System.out.print((<span class="keyword">char</span>)data);</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//4.流的关闭操作</span></span><br><span class="line"><span class="comment">//            try {</span></span><br><span class="line"><span class="comment">//                if(fr != null)</span></span><br><span class="line"><span class="comment">//                    fr.close();</span></span><br><span class="line"><span class="comment">//            } catch (IOException e) {</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line">            <span class="comment">//或</span></span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fr.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>



<h2 id="8-FileReader中使用read-char-cbuf-读入数据（比7快）"><a href="#8-FileReader中使用read-char-cbuf-读入数据（比7快）" class="headerlink" title="8.FileReader中使用read(char[] cbuf)读入数据（比7快）"></a>8.FileReader中使用read(char[] cbuf)读入数据（比7快）</h2><p>后续23步 不同     一份一份送外卖，</p>
<p>char[] buff=new char[5];  外卖的车一次最多能够 搞5件</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">//对read()操作升级：使用read的重载方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileReader1</span><span class="params">()</span>  </span>{</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//1.File类的实例化</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"hello.txt"</span>);</span><br><span class="line">            <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">            <span class="comment">//3.读入的操作</span></span><br><span class="line">            <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];    <span class="comment">//*****</span></span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>){</span><br><span class="line">                <span class="comment">//方式一：</span></span><br><span class="line">                <span class="comment">//错误的写法</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++){</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                }</span></span><br><span class="line">                <span class="comment">//正确的写法</span></span><br><span class="line"><span class="comment">//                for(int i = 0;i &lt; len;i++){</span></span><br><span class="line"><span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//                }</span></span><br><span class="line">                <span class="comment">//方式二：</span></span><br><span class="line">                <span class="comment">//错误的写法,对应着方式一的错误的写法</span></span><br><span class="line"><span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//                System.out.print(str);</span></span><br><span class="line">                <span class="comment">//正确的写法</span></span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len); <span class="comment">//******</span></span><br><span class="line">                System.out.print(str);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="keyword">null</span>){</span><br><span class="line">                <span class="comment">//4.资源的关闭</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fr.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="9-FileWriter-写出数据的操作"><a href="#9-FileWriter-写出数据的操作" class="headerlink" title="9. FileWriter 写出数据的操作"></a>9. FileWriter 写出数据的操作</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">从内存中写出数据到硬盘的文件里。</span><br><span class="line">说明：1. 输出操作，对应的File可以不存在的。并不会报异常</span><br><span class="line">2.    </span><br><span class="line">File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。     </span><br><span class="line">File对应的硬盘中的文件如果存在：            </span><br><span class="line">如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原有文件的覆盖            </span><br><span class="line">如果流使用的构造器是：FileWriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_38" alt="1588413758710"></p>
<h2 id="10-使用FileReader和FileWriter实现文本文件的复制"><a href="#10-使用FileReader和FileWriter实现文本文件的复制" class="headerlink" title="10.使用FileReader和FileWriter实现文本文件的复制."></a>10.使用FileReader和FileWriter实现文本文件的复制.</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_39" alt="1588414166673"></p>
<h2 id="11-字符流不能处理图片文件的测试"><a href="#11-字符流不能处理图片文件的测试" class="headerlink" title="11.字符流不能处理图片文件的测试"></a>11.字符流不能处理图片文件的测试</h2><h2 id="12-使用FileInputStream不能读取文本文件的测试"><a href="#12-使用FileInputStream不能读取文本文件的测试" class="headerlink" title="12.使用FileInputStream不能读取文本文件的测试"></a>12.使用FileInputStream不能读取文本文件的测试</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_40" alt="1588415087195"></p>
<blockquote>
<p>结论： </p>
<blockquote>
<ol>
<li>对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</li>
<li>对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,…)，使用字节流处理</li>
</ol>
</blockquote>
</blockquote>
<h2 id="13-使用FileInputStream和FileOutputStream读写非文本文件"><a href="#13-使用FileInputStream和FileOutputStream读写非文本文件" class="headerlink" title="13.使用FileInputStream和FileOutputStream读写非文本文件"></a>13.使用FileInputStream和FileOutputStream读写非文本文件</h2><p>复制图片</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_41" alt="1588415573068"></p>
<h2 id="14-使用FileInputStream和FileOutputStream复制文件的方法测试"><a href="#14-使用FileInputStream和FileOutputStream复制文件的方法测试" class="headerlink" title="14.使用FileInputStream和FileOutputStream复制文件的方法测试."></a>14.使用FileInputStream和FileOutputStream复制文件的方法测试.</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_42" alt="1588415823026"></p>
<p>测试(复制文本文档可以的   字节流就是搬运工 ，别再内存读):</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCopyFile</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    String srcPath = <span class="string">"C:\\Users\\Administrator\\Desktop\\01-视频.avi"</span>;</span><br><span class="line">    String destPath = <span class="string">"C:\\Users\\Administrator\\Desktop\\02-视频.avi"</span>;</span><br><span class="line">    copyFile(srcPath,destPath);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"复制操作花费的时间为："</span> + (end - start));<span class="comment">//618</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>特别大占用内存 ,交互次数变少，缓冲流比之快</p>
<hr>
<h2 id="15-缓冲流-字节型-实现非文本文件的复制-更快"><a href="#15-缓冲流-字节型-实现非文本文件的复制-更快" class="headerlink" title="15.缓冲流(字节型)实现非文本文件的复制(更快)"></a>15.缓冲流(字节型)实现非文本文件的复制(更快)</h2><p>缓冲流 提高了读写效率(开发中用)</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_43" alt="1588416395639"></p>
<p>1.缓冲流：<br>BufferedInputStream<br>BufferedOutputStream<br>BufferedReader<br>BufferedWriter<br>2.作用：提供流的读取、写入的速度<br>  提高读写速度的原因：内部提供了一个缓冲区</p>
<p>3.处理流，就是“套接”在已有的流的基础上。</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_44" alt="1588417053398"></p>
<p>bos.flush 刷新缓存区</p>
<h2 id="16-缓冲流与节点流读写速度对比"><a href="#16-缓冲流与节点流读写速度对比" class="headerlink" title="16.缓冲流与节点流读写速度对比"></a>16.缓冲流与节点流读写速度对比</h2><h2 id="17-缓冲流-字符型-实现文本文件的复制"><a href="#17-缓冲流-字符型-实现文本文件的复制" class="headerlink" title="17.缓冲流(字符型)实现文本文件的复制"></a>17.缓冲流(字符型)实现文本文件的复制</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_45" alt="1588417453476"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_46" alt="1588417989885"></p>
<h2 id="18-19缓冲流课后练习1-2"><a href="#18-19缓冲流课后练习1-2" class="headerlink" title="18-19缓冲流课后练习1-2"></a>18-19缓冲流课后练习1-2</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_47" alt="1588418390352"></p>
<p>2.实现图片加密操作</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//图片的加密</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>{</span><br><span class="line">       FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">       FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           fis = <span class="keyword">new</span> FileInputStream(<span class="string">"爱情与友情.jpg"</span>);</span><br><span class="line">           fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"爱情与友情secret.jpg"</span>);</span><br><span class="line">           <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>];</span><br><span class="line">           <span class="keyword">int</span> len;</span><br><span class="line">           <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) {</span><br><span class="line">               <span class="comment">//字节数组进行修改</span></span><br><span class="line">               <span class="comment">//错误的  只对b进行了修改，buffer没变化  </span></span><br><span class="line">               <span class="comment">//            for(byte b : buffer){</span></span><br><span class="line">               <span class="comment">//                b = (byte) (b ^ 5);</span></span><br><span class="line">               <span class="comment">//            }</span></span><br><span class="line">               <span class="comment">//正确的</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">                   buffer[i] = (<span class="keyword">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">               }</span><br><span class="line">               fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">           }</span><br><span class="line">       } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       } <span class="keyword">finally</span> {</span><br><span class="line">           <span class="keyword">if</span> (fos != <span class="keyword">null</span>) {</span><br><span class="line">               <span class="keyword">try</span> {</span><br><span class="line">                   fos.close();</span><br><span class="line">               } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (fis != <span class="keyword">null</span>) {</span><br><span class="line">               <span class="keyword">try</span> {</span><br><span class="line">                   fis.close();</span><br><span class="line">               } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>解密</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//图片的解密</span></span><br><span class="line">        只需要更改 fis和fos文件路径 即可</span><br></pre></td></tr></tbody></table></figure>

<ol start="3">
<li><p>统计字符的个数</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 练习3:获取文本上字符出现的次数,把数据写入文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 思路：</span></span><br><span class="line"><span class="comment"> * 1.遍历文本每一个字符</span></span><br><span class="line"><span class="comment"> * 2.字符出现的次数存在Map中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Map&lt;Character,Integer&gt; map = new HashMap&lt;Character,Integer&gt;();</span></span><br><span class="line"><span class="comment"> * map.put('a',18);</span></span><br><span class="line"><span class="comment"> * map.put('你',2);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3.把map中的数据写入文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>{</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明：如果使用单元测试，文件相对路径为当前module</span></span><br><span class="line"><span class="comment">          如果使用main()测试，文件相对路径为当前工程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWordCount</span><span class="params">()</span> </span>{</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">//1.创建Map集合</span></span><br><span class="line">            Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.遍历每一个字符,每一个字符出现的次数放到map中</span></span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(<span class="string">"dbcp.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) {</span><br><span class="line">                <span class="comment">//int 还原 char</span></span><br><span class="line">                <span class="keyword">char</span> ch = (<span class="keyword">char</span>) c;</span><br><span class="line">                <span class="comment">// 判断char是否在map中第一次出现</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(ch) == <span class="keyword">null</span>) {</span><br><span class="line">                    map.put(ch, <span class="number">1</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    map.put(ch, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.把map中数据存在文件count.txt</span></span><br><span class="line">            <span class="comment">//3.1 创建Writer</span></span><br><span class="line">            bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"wordcount.txt"</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.2 遍历map,再写入数据</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entrySet) {</span><br><span class="line">                <span class="keyword">switch</span> (entry.getKey()) {</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                        bw.write(<span class="string">"空格="</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\t'</span>:<span class="comment">//\t表示tab 键字符</span></span><br><span class="line">                        bw.write(<span class="string">"tab键="</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\r'</span>:<span class="comment">//</span></span><br><span class="line">                        bw.write(<span class="string">"回车="</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'\n'</span>:<span class="comment">//</span></span><br><span class="line">                        bw.write(<span class="string">"换行="</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        bw.write(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                bw.newLine();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">//4.关流</span></span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fr.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (bw != <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    bw.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h2 id="20-转换流概述与InputStreamReader的使用-—-处理流"><a href="#20-转换流概述与InputStreamReader的使用-—-处理流" class="headerlink" title="20.转换流概述与InputStreamReader的使用 — 处理流"></a>20.转换流概述与InputStreamReader的使用 — 处理流</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_48" alt="1588419368648"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_49" alt="1588419406818"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_50" alt="1588419424427"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_51" alt="1588419462018"></p>
<p>处理流之二：转换流的使用<br>1.转换流：属于字符流  看末尾<br>  InputStreamReader：将一个字节的输入流转换为字符的输入流<br>  OutputStreamWriter：将一个字符的输出流转换为字节的输出流<br>2.作用：提供字节流与字符流之间的转换</p>
<ol start="3">
<li><p>解码：字节、字节数组  —&gt;字符数组、字符串<br>编码：字符数组、字符串 —&gt; 字节、字节数组<br>4.字符集<br> *ASCII：美国标准信息交换码。<br> 用一个字节的7位可以表示。<br> ISO8859-1：拉丁码表。欧洲码表<br> 用一个字节的8位表示。<br> GB2312：中国的中文编码表。最多两个字节编码所有字符<br> GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码<br> Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。<br> UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</p>
<ul>
<li><blockquote>
<p>InputStreamReader的使用，实现字节的输入流到字符的输入流的转换</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_52" alt="1588421377417"></p>
<p>字符集设置不区分大小写</p>
<h2 id="21-转换流实现文件的读入和写出-字符集的转化"><a href="#21-转换流实现文件的读入和写出-字符集的转化" class="headerlink" title="21.转换流实现文件的读入和写出(字符集的转化)"></a>21.转换流实现文件的读入和写出(字符集的转化)</h2><p>情景 ，当初文件是utf-8，想把它转化为gbk，    (抛异常 IOE)</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_53" alt="1588421703979"></p>
<h2 id="22-多种字符编码集的说明"><a href="#22-多种字符编码集的说明" class="headerlink" title="22.多种字符编码集的说明."></a>22.多种字符编码集的说明.</h2><p> *ASCII：美国标准信息交换码。<br> 用一个字节的7位可以表示。<br> ISO8859-1：拉丁码表。欧洲码表<br> 用一个字节的8位表示。<br> GB2312：中国的中文编码表。最多两个字节编码所有字符<br> GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码<br> Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。<br> UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_54" alt="1588421887246">)<img src="/2017/07/09/2016-07-09-io-liu-m/26_55" alt="1588421917978"></p>
<p>在标准UTF-8编码中，超出基本多语言范围( BMP-Basic Mutilingual Plane )的字符被编码为4字节格式，但是在修正的UTF-8编码中，他们由代理编码对( srrogatepairs )表示，然后这些代理编码对在列中分别重新编码。结果标准UTF 8编码中需要4个字节的字符，在修正后的UTF-8编码中将需要6个字节。</p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_58" alt="1588421980945"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_56" alt="1588421948125"></p>
<h4 id="6-标准输入、输出流"><a href="#6-标准输入、输出流" class="headerlink" title="6.标准输入、输出流"></a>6.标准输入、输出流</h4><h4 id="7-打印流"><a href="#7-打印流" class="headerlink" title="7.打印流"></a>7.打印流</h4><h4 id="8-数据流-几个流作为了解-就够了"><a href="#8-数据流-几个流作为了解-就够了" class="headerlink" title="8.数据流   几个流作为了解  就够了"></a>8.数据流   几个流作为了解  就够了</h4><h2 id="23-标准的输入、输出流"><a href="#23-标准的输入、输出流" class="headerlink" title="23. 标准的输入、输出流"></a>23. 标准的输入、输出流</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_59" alt="1588422904536"></p>
<p>   1.标准的输入、输出流<br>    1.1<br>    System.in:标准的输入流，默认从键盘输入<br>    System.out:标准的输出流，默认从控制台输出<br>    1.2<br>    System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流。<br>    1.3练习：<br>    从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，<br>    直至当输入“e”或者“exit”时，退出程序。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">方法一：使用Scanner实现，调用next()返回一个字符串</span><br><span class="line">方法二：使用System.in实现。System.in  ---&gt;  转换流 ---&gt; BufferedReader的readLine()</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_60" alt="1588423626404"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_61" alt="1588423782048"><br>strng 和int  转换不是学过吗？</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// MyInput.java: Contain the methods for reading int, double, float, boolean, short, byte and</span></span><br><span class="line"><span class="comment">// string values from the keyboard</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> </span>{</span><br><span class="line">    <span class="comment">// Read a string from the keyboard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readString</span><span class="params">()</span> </span>{</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare and initialize the string</span></span><br><span class="line">        String string = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            string = br.readLine();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (IOException ex) {</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read an int value from the keyboard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(readString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a double value from the keyboard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(readString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a byte value from the keyboard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">readByte</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Byte.parseByte(readString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a short value from the keyboard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">readShort</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Short.parseShort(readString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a long value from the keyboard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">readLong</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(readString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a float value from the keyboard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">readFloat</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> Float.parseFloat(readString());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="24-打印流-只有输出-System-Out-，从控制台输出"><a href="#24-打印流-只有输出-System-Out-，从控制台输出" class="headerlink" title="24. 打印流  只有输出         System.Out ，从控制台输出"></a>24. 打印流  只有输出         System.Out ，从控制台输出</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_62" alt="1588424247904"></p>
<ol start="2">
<li>打印流：PrintStream 和PrintWriter</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2.1 提供了一系列重载的print() 和 println()</span><br><span class="line">2.2 练习：</span><br><span class="line">setOut  重新制定打印流</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_63" alt="1588424434217">  </p>
<p>应用:   保存日志</p>
<h2 id="25-数据流"><a href="#25-数据流" class="headerlink" title="25.数据流"></a>25.数据流</h2><p><img src="/2017/07/09/2016-07-09-io-liu-m/26_64" alt="1588424695477"></p>
<ol start="3">
<li><p>数据流<br>3.1 DataInputStream 和 DataOutputStream    需要的时候可以将内存文件进行保存<br>3.2 作用：用于读取或写出基本数据类型的变量或字符串</p>
<p>练习：将内存中的字符串、基本数据类型的变量写出到文件中。注意：处理异常的话，仍然应该使用try-catch-finally.     只能对基本类型有效</p>
</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">练习：将内存中的字符串、基本数据类型的变量写出到文件中。</span><br><span class="line"></span><br><span class="line">   注意：处理异常的话，仍然应该使用<span class="keyword">try</span>-<span class="keyword">catch</span>-<span class="keyword">finally</span>.</span><br><span class="line">    */</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">       <span class="comment">//1.</span></span><br><span class="line">       DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">       <span class="comment">//2.</span></span><br><span class="line">       dos.writeUTF(<span class="string">"Tony"</span>);</span><br><span class="line">       dos.flush();<span class="comment">//刷新操作，将内存中的数据写入文件</span></span><br><span class="line">       dos.writeInt(<span class="number">23</span>);</span><br><span class="line">       dos.flush();</span><br><span class="line">       dos.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">       dos.flush();</span><br><span class="line">       <span class="comment">//3.</span></span><br><span class="line">       dos.close();</span><br><span class="line">           }</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment">   注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">       <span class="comment">//1.造流</span></span><br><span class="line">       DataInputStream dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"data.txt"</span>));</span><br><span class="line">       <span class="comment">//2. 读</span></span><br><span class="line">       String name = dis.readUTF();</span><br><span class="line">       <span class="keyword">int</span> age = dis.readInt();</span><br><span class="line">       <span class="keyword">boolean</span> isMale = dis.readBoolean();</span><br><span class="line">       System.out.println(<span class="string">"name = "</span> + name);</span><br><span class="line">       System.out.println(<span class="string">"age = "</span> + age);</span><br><span class="line">       System.out.println(<span class="string">"isMale = "</span> + isMale);</span><br><span class="line">       <span class="comment">//3.关闭流</span></span><br><span class="line">       dis.close();</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_65" alt="1588424967925"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_66" alt="1588424990108"></p>
<hr>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_25" alt="1588406118216"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_26" alt="1588406144749"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_27" alt="1588406166824"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_28" alt="1588406183250"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_29" alt="1588406201799"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_30" alt="1588406220704"></p>
<p><img src="/2017/07/09/2016-07-09-io-liu-m/26_31" alt="1588406242868"></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2017/07/08/2016-07-08-fan-xing/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><ul>
<li>1.Map存储数据的特点是什么？并指明key，value，entry存储数据的特点。</li>
</ul>
<p>双列数据，存储key-value对数据。</p>
<p>key：无序的、不可重复的-&gt;Set存储</p>
<p>value:无序的、可重复的 –&gt;Collection存储</p>
<p>key-value:无序的、不可重复 -&gt;Set存储</p>
<ul>
<li><p>2.描述HashMap的底层实现原理(jdk 8版)</p>
</li>
<li><p>3.Map中常用实现类有哪些？各自有什么特点？</p>
</li>
<li><p>4.如何遍历Map中的key-value对，代码实现</p>
</li>
<li><p>5.Collection和Collections的区别？</p>
</li>
</ul>
<p>处理出核心   ，在逐渐细化</p>
<h2 id="2-复习Map"><a href="#2-复习Map" class="headerlink" title="2.复习Map"></a>2.复习Map</h2><p>双列集合框架: Map<br>1.常用实现类结构</p>
<p> |—-Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)<br>        |—-HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value<br>             |—-LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。<br>                     原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。<br>                     对于频繁的遍历操作，此类执行效率高于HashMap。<br>        |—-TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序<br>                     底层使用红黑树<br>        |—-Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value<br>             |—-Properties:常用来处理配置文件。key和value都是String类型<br>     HashMap的底层：数组+链表  （jdk7及之前）<br>                   数组+链表+红黑树 （jdk 8）</p>
<p>[面试题]</p>
<ol>
<li>HashMap的底层实现原理？</li>
<li>HashMap 和 Hashtable的异同？</li>
<li>CurrentHashMap 与 Hashtable的异同？（暂时不讲）<br>*</li>
</ol>
<p>2.存储结构的理解:</p>
<pre><code>Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）
 Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()
 一个键值对：key-value构成了一个Entry对象。
 Map中的entry:无序的、不可重复的，使用Set存储所有的entry</code></pre><p>图示:</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/24_12" alt="1588300324391"></p>
<p>3.常用方法</p>
<p>添加：put(Object key,Object value)<br>删除：remove(Object key)<br>修改：put(Object key,Object value)<br>查询：get(Object key)<br>长度：size()<br>遍历：keySet() / values() / entrySet()</p>
<p>4.内存结构说明: (难点)<br>4.1 HashMap在jdk7中实现原理:</p>
<p>  HashMap map = new HashMap():<br>     在实例化以后，底层创建了长度是16的一维数组Entry[] table。<br>     …可能已经执行过多次put…<br>     map.put(key1,value1):<br>     首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。<br>     如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1<br>     如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据<br>     的哈希值：<br>             如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2<br>             如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：<br>                     如果equals()返回false:此时key1-value1添加成功。—-情况3<br>                     如果equals()返回true:使用value1替换value2。<br> *<br>      补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。<br> *<br>     在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<p>4.2 HashMap在jdk8中相较于jdk7在底层实现方面的不同:</p>
<ol>
<li>new HashMap():底层没有创建一个长度为16的数组</li>
<li>jdk 8底层的数组是：Node[],而非Entry[]</li>
<li>首次调用put()方法时，底层创建长度为16的数组</li>
<li>jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。<br>*形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）<br>*当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li>
</ol>
<p>4.3 HashMap底层典型属性的属性的说明:</p>
<pre><code>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
 DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
 threshold：扩容的临界值，=容量*填充因子：16\*0.75 =&gt; 12
 TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
 MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</code></pre><p>4.4 LinkedHashMap的底层实现原理(了解)</p>
<p>LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继 承于HashMap.<br>区别就在于: LinkedHashMap内 部提供了Entry,替换HashMap中的Node.</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/24_25" alt="1588306337685"></p>
<p>5.TreeMap的使用<br>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象<br>因为要按照key进行排序：自然排序 、定制排序</p>
<p>6.使用Properties读取配置文件</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/24_39" alt="1588312710514"></p>
<h2 id="3-复习Collections和数据结构"><a href="#3-复习Collections和数据结构" class="headerlink" title="3.复习Collections和数据结构"></a>3.复习Collections和数据结构</h2><p>Colectiorls工具类<br>1.作用:操作Collection和Map的工具类<br>2.常用方法:</p>
<p>reverse(List)：反转 List 中元素的顺序<br>shuffle(List)：对 List 集合元素进行随机排序<br>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序<br>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
<p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素<br>Object min(Collection)<br>Object min(Collection，Comparator)<br>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数<br>void copy(List dest,List src)：将src中的内容复制到dest中<br>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
<p>返回线程安全的<br><img src="/2017/07/08/2016-07-08-fan-xing/24_42" alt="1588313045587"><br>说明: ArayList和Hashlap都是线程不安全的，如果程序要求线程安全，我们可以将ArrayList、HashMap转换为线程安全的。<br>使用synchronizedList(List list) 和synchronizedMap (Map map)</p>
<p>3.’面试题:<br> 面试题：Collection 和 Collections的区别？<br>数据结构</p>
<p>1.为什么要有泛型</p>
<h2 id="4-为什么使用泛型"><a href="#4-为什么使用泛型" class="headerlink" title="4.为什么使用泛型"></a>4.为什么使用泛型</h2><p><img src="/2017/07/08/2016-07-08-fan-xing/25_01" alt="1588323642655"></p>
<p>写上之后只能放大黄</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_02" alt="1588323885911"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_03" alt="1588323961456"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_04" alt="1588324008545"></p>
<p>泛型的使用<br>1.jdk 5.0新增的特性<br> *<br>2.在集合中使用泛型：<br> 总结：<br> ① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。<br> ② 在实例化集合类时，可以指明具体的泛型类型<br> ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。<br>   比如：add(E e)  —&gt;实例化以后：add(Integer e)<br> ④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换<br> ⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.Object类型。<br> *<br>3.如何自定义泛型结构：泛型类、泛型接口；泛型方法。见 GenericTest1.java ##7. </p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_05" alt="1588324328690"></p>
<h2 id="5-在集合中使用泛型"><a href="#5-在集合中使用泛型" class="headerlink" title="5.在集合中使用泛型"></a>5.在集合中使用泛型</h2><p>泛型不能是基本数据类型，需要用包装类</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_06" alt="1588324618982"></p>
<p>2.在集合中使用泛型</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_07" alt="1588325149840"></p>
<h2 id="6-集合中使用泛型的练习"><a href="#6-集合中使用泛型的练习" class="headerlink" title="6.集合中使用泛型的练习"></a>6.集合中使用泛型的练习</h2><p><img src="/2017/07/08/2016-07-08-fan-xing/25_08" alt="1588325325110"></p>
<ul>
<li><p>自然排序<br><img src="/2017/07/08/2016-07-08-fan-xing/25_09" alt="1588325379865"><br><img src="/2017/07/08/2016-07-08-fan-xing/25_10" alt="1588325447329"></p>
</li>
<li><p>定制排序:</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_11" alt="1588325740164"></p>
<p>MyDate</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_12" alt="1588325919271"></p>
</li>
</ul>
<p>3.自定义泛型结构</p>
<h2 id="7-自定义泛型类举例"><a href="#7-自定义泛型类举例" class="headerlink" title="7.自定义泛型类举例"></a>7.自定义泛型类举例</h2><p>自定义泛型类， T是一个参数 </p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_13" alt="1588326158843"></p>
<p>不使用T认为是object类型</p>
<p>加泛型做了不必要的强转、或判断类型</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_14" alt="1588326446496"></p>
<p>子类实现父类  order后面的参数</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_15" alt="1588326532877"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_16" alt="1588326570785"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_17" alt="1588326670561"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_18" alt="1588326696998"></p>
<h2 id="8-自定义泛型类泛型接口的注意点"><a href="#8-自定义泛型类泛型接口的注意点" class="headerlink" title="8 .自定义泛型类泛型接口的注意点"></a>8 .自定义泛型类泛型接口的注意点</h2><p><img src="/2017/07/08/2016-07-08-fan-xing/25_19" alt="1588326800412"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_20" alt="1588326826440"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_21" alt="1588326848230"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_22" alt="1588326883741"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_23" alt="1588326912345"></p>
<ol start="9">
<li>泛型是实例化执行的</li>
</ol>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_24" alt="1588326934639"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_25" alt="1588326955562"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_26" alt="1588326982639"></p>
<h2 id="9-自定义泛型方法举例"><a href="#9-自定义泛型方法举例" class="headerlink" title="9.自定义泛型方法举例"></a>9.自定义泛型方法举例</h2><p>泛型方法  只针对方法来说，与接口和类无关</p>
<p>泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。<br>换句话说，泛型方法所属的类是不是泛型类都没有关系。<br>泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_30" alt="1588327885599"></p>
<p>测试<img src="/2017/07/08/2016-07-08-fan-xing/25_31" alt="1588327996559"></p>
<p>参数确定好类型，也就确定了返回值的类型&amp;&amp;  可声明称static ，因为此时E 由于传入的integer 已经确定了，调用的时候确定的，调用的时候告诉我就可以</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_27" alt="1588327021068"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_28" alt="1588327041797"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_29" alt="1588327063542"></p>
<h2 id="10-举例泛型类和泛型方法的使用情境"><a href="#10-举例泛型类和泛型方法的使用情境" class="headerlink" title="10.举例泛型类和泛型方法的使用情境"></a>10.举例泛型类和泛型方法的使用情境</h2><p>dao    数据访问对象</p>
<p>ORM思想</p>
<p>表对应一个java类</p>
<p>不确定那个表    public class<t>{   操作表的共性操作</t></p>
<p>}</p>
<p>public class CustomerDAO extends DAO<customer>{}</customer></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_32" alt="1588328575792"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_33" alt="1588328619914"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_34" alt="1588328666240"></p>
<p>另外一张表：</p>
<p>studentDao  extends DAO<studetn>{ 只能操作某一个表的dao</studetn></p>
<p>}</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_35" alt="1588328877633"></p>
<p>4.泛型在继承上的体现</p>
<h2 id="11-泛型在继承方面的体现"><a href="#11-泛型在继承方面的体现" class="headerlink" title="11.泛型在继承方面的体现"></a>11.泛型在继承方面的体现</h2><p><img src="/2017/07/08/2016-07-08-fan-xing/25_36" alt="1588329874945"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_37" alt="1588329905787"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_38" alt="1588329948614"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_39" alt="1588330095294"></p>
<h4 id="此时的lists1和list2的类型不具有子父类的关系，因此编译不通过"><a href="#此时的lists1和list2的类型不具有子父类的关系，因此编译不通过" class="headerlink" title="此时的lists1和list2的类型不具有子父类的关系，因此编译不通过"></a>此时的lists1和list2的类型不具有子父类的关系，因此编译不通过</h4><ol>
<li><p>泛型在继承方面的体现</p>
<p>  虽然类A是类B的父类，但是G<a> 和G<b>二者不具备子父类关系，二者是并列关系。</b></a></p>
<p>   补充：类A是类B的父类，A<g> 是 B<g> 的父类</g></g></p>
</li>
</ol>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_40" alt="1588330332577"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_41" alt="1588330392030"></p>
<hr>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_42" alt="补充"></p>
<p>5.通配符的使用</p>
<h2 id="12-通配符的使用"><a href="#12-通配符的使用" class="headerlink" title="12. 通配符的使用"></a>12. 通配符的使用</h2><p><img src="/2017/07/08/2016-07-08-fan-xing/25_43" alt="1588330682268"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_44" alt="1588330701996"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_45" alt="1588330742514"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_46" alt="1588330760910"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_47" alt="1588330782660"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_48" alt="1588330802243"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_49" alt="1588330823181"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_50" alt="1588330876670"></p>
<p>他两的父类</p>
<p> 通配符：?<br>类A是类B的父类，G<a>和G<b>是没有关系的，二者共同的父类是：G&lt;?&gt;</b></a></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_51" alt="1588331008908"></p>
<h2 id="13-使用通配符后数据的读取和写入要求"><a href="#13-使用通配符后数据的读取和写入要求" class="headerlink" title="13.使用通配符后数据的读取和写入要求"></a>13.使用通配符后数据的读取和写入要求</h2><p><img src="/2017/07/08/2016-07-08-fan-xing/25_52" alt="1588331323208"></p>
<h2 id="14-有限制条件的通配符的使用"><a href="#14-有限制条件的通配符的使用" class="headerlink" title="14.有限制条件的通配符的使用"></a>14.有限制条件的通配符的使用</h2><p>extends &lt;=</p>
<p>super &gt;=</p>
<p>  ? extends A:          若 ？ 比student 还小<br>                G&lt;? extends A&gt; 可以作为G<a>和G<b>的父类，其中B是A的子类</b></a></p>
<p>  ? super A:<br>                G&lt;? super A&gt; 可以作为G<a>和G<b>的父类，其中B是A的父类</b></a></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_53" alt="1588332375330"></p>
<p>list1可以作为list3、list4 的父类出现，   可以person（list1）的子类 甚至自己</p>
<hr>
<p>super 可以是person  甚至比它大</p>
<hr>
<p>list1   不是小于等于person list1=list4  可以用person  或object</p>
<p>list1=list3</p>
<p>虽然可以  当list1小于等于person最小写person</p>
<p>–</p>
<p>list2 =list4</p>
<p>list2.get(0) 只能写object     大于等于person 是person的父类</p>
<p>–</p>
<p>list2.add(new student)   可以   由于  super  student  继承于person</p>
<hr>
<p>list1.add(new Student)   报错  ，若list1  比student还要小   子类可以付给父类，父类不能赋值给子类</p>
<p>不能把右边的赋值给左边</p>
<p>6.泛型应用举例</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_54" alt="1588332429730"></p>
<h2 id="15-自定义泛型类练习"><a href="#15-自定义泛型类练习" class="headerlink" title="15.自定义泛型类练习."></a>15.自定义泛型类练习.</h2><p><img src="/2017/07/08/2016-07-08-fan-xing/25_55" alt="1588333926311"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_56" alt="1588334311572"></p>
<p>map 重写equals hashCode</p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_57" alt="1588334568809"></p>
<p><img src="/2017/07/08/2016-07-08-fan-xing/25_58" alt="1588334667212"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义个泛型类 DAO&lt;T&gt;，在其中定义一个Map 成员变量，Map 的键为 String 类型，值为 T 类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 分别创建以下方法：</span></span><br><span class="line"><span class="comment"> public void save(String id,T entity)： 保存 T 类型的对象到 Map 成员变量中</span></span><br><span class="line"><span class="comment"> public T get(String id)：从 map 中获取 id 对应的对象</span></span><br><span class="line"><span class="comment"> public void update(String id,T entity)：替换 map 中key为id的内容,改为 entity 对象</span></span><br><span class="line"><span class="comment"> public List&lt;T&gt; list()：返回 map 中存放的所有 T 对象</span></span><br><span class="line"><span class="comment"> public void delete(String id)：删除指定 id 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAO</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,T&gt; map = <span class="keyword">new</span> HashMap&lt;String,T&gt;();</span><br><span class="line">    <span class="comment">//保存 T 类型的对象到 Map 成员变量中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(String id,T entity)</span></span>{</span><br><span class="line">        map.put(id,entity);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//从 map 中获取 id 对应的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(String id)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> map.get(id);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//替换 map 中key为id的内容,改为 entity 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String id,T entity)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(id)){</span><br><span class="line">            map.put(id,entity);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//返回 map 中存放的所有 T 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">list</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//错误的：</span></span><br><span class="line"><span class="comment">//        Collection&lt;T&gt; values = map.values();</span></span><br><span class="line"><span class="comment">//        return (List&lt;T&gt;) values;</span></span><br><span class="line">        <span class="comment">//正确的：</span></span><br><span class="line">        ArrayList&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collection&lt;T&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span>(T t : values){</span><br><span class="line">            list.add(t);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//删除指定 id 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String id)</span></span>{</span><br><span class="line">        map.remove(id);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>集合(补1)</title>
    <url>/2017/07/06/2016-07-06-ji-he-bu-1/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>1.集合Collection中存储的如果是自定义类的对象，需要自定义类重写哪个方法？为什么？</p>
<p>equals()方法。  contains() /remove()/retainsAll() ….</p>
<p>List：equals()方法</p>
<p>Set：(HashSet、LinkedHashSet为例)：equals()、hashCode()</p>
<p>  (TreeSet为例)：Comparable：compareTo(Object obj)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Comparator：compare(Object o1,Object o2)</span><br></pre></td></tr></tbody></table></figure>

<ol start="2">
<li>ArrayList,LinkedList,Vector三者的相同点与不同点？【面试题】</li>
</ol>
<p>List  Map(多)  Set (用的少、禁飞名单 人员)<br>都实现了List接口   底层都是数组<br>查找快<br>实现方式</p>
<p>3.List 接口的常用方法有哪些？(增、删、改、查、插、长度、遍历)</p>
<p>add(Object obj)</p>
<p>remove(Object obj)/remove(int index)</p>
<p>set(int index,Object obj)</p>
<p>get(int index)</p>
<p>add(int index,Object obj)</p>
<p>size()    实际长度</p>
<p>使用Iterator;foreach;普通的for<br>4.如何使用Iterator和增强for循环遍历List。举例说明<br>5.Set存储数据的特点是什么？常见的实现类有什么？说明一下彼此的特点。<br>无需不可重复的</p>
<p>HashSet  LinkedHashSet  TreeSet</p>
<p>HashMap    LinkedHashMap   TreeMap</p>
<h2 id="2-复习-Collection及Collection的遍历"><a href="#2-复习-Collection及Collection的遍历" class="headerlink" title="2.复习:Collection及Collection的遍历"></a>2.复习:Collection及Collection的遍历</h2><p>2.Collection接口常用方法:</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_01" alt="1588293364258"></p>
<p>3.Collection集合与数组间的转换</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_02" alt="1588232608177"> String 不用加new String 就可以</p>
<p>4.使用Collection集合存储对象，要求对象所属的类满足:</p>
<p>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重 写equals(). </p>
<p>5.本章节对大家的要求:</p>
<p>层次一:选择合适的集合类去实现数据的保存，调用其内部的相关方法。<br>层次二:不同的集合类底层的数据结构为何?如何实现数据的操作的:增删改查等，|</p>
<h4 id="Collection接口与-foreach遍历"><a href="#Collection接口与-foreach遍历" class="headerlink" title="Collection接口与 foreach遍历"></a>Collection接口与 foreach遍历</h4><p>1.遍历collection的两种方式:<br>①使用迭代器Iterator<br>② foreach循环(或增强for循环)</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_03" alt="1588293947305"></p>
<p>2.java.utils包下定义的迭代器接口: Iterator<br>2.1说明:</p>
<p>●lteratr对象称为迭代器(设计模式的一种), 主要用于遍历Cllction集合中的元素。<br>●GOF给迭代器模式的定义为:提供-种方法访问一一个容器(container)对象中各个元素， 而又不需暴露该对<br>象的内部细节。迭代器模式，就是为容器而生。</p>
<p>2.2作用:遍历集合元素  Collection元素<br>2.3如何获取实例:   coll.iterator()返回一个迭代器实例<br>2.4遍历的代码实现:</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_04" alt="1588294090220"></p>
<p>2.5图示说明:</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_05" alt="1588233312775"></p>
<p>2.6 remove()的使用:</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/23_23" alt="1588233352886"></p>
<p>3.jdk5. 0新特性–增强for循环: (foreach循环)<br>1.遍历集合举例:<br><img src="/2017/07/06/2016-07-06-ji-he-bu-1/23_26" alt="1588235758885"></p>
<p>说明:<br>内部依然调用迭代器</p>
<p>2.遍历数组举例:<img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_06" alt="1588294337913"></p>
<h2 id="3-复习-List接口"><a href="#3-复习-List接口" class="headerlink" title="3.复习:List接口"></a>3.复习:List接口</h2><p>1.存储的数据特点:<br>|—-Collection接口：单列集合，用来存储一个一个的对象<br>|—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组,替换原有的数组<br>    |—-ArrayList：作为List接口的<code>主要实现类</code>；线程不安全的，效率高；底层使用Object[] elementData存储<br>    |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储  —》 铁链子 内部   打比方 传话<br>    |—-Vector：作为List接口的<code>古老实现类</code>；线程安全的，效率低；底层使用Object[] elementData存储      打比方  不怎么用，   皇帝与旧臣</p>
<p>2.常用方法: (记住)<br>增：add(Object obj)<br>删：remove(int index) / remove(Object obj)<br>改：set(int index, Object ele)<br>查：get(int index)<br>插：add(int index, Object ele)<br>长度：size()<br>遍历：① Iterator迭代器方式<br>② 增强for循环<br>③ 普通的循环</p>
<p>3.常用实现类:<br>|—-Collection接口：单列集合，用来存储一个一个的对象<br>|—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组,替换原有的数组<br>    |—-ArrayList：作为List接口的<code>主要实现类</code>；线程不安全的，效率高；底层使用Object[] elementData存储<br>    |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储  —》 铁链子 内部   打比方 传话<br>    |—-Vector：作为List接口的<code>古老实现类</code>；线程安全的，效率低；底层使用Object[] elementData存储      打比方  不怎么用，   皇帝与旧臣</p>
<p>4.源码分析(难点)</p>
<ol>
<li><p>ArrayList的源码分析：<br>2.1 jdk 7情况下<br> ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData<br> list.add(123);//elementData[0] = new Integer(123);<br> …<br> list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。<br> 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。<br>*<br> <strong><strong><strong>**</strong></strong></strong>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)；<br>*</p>
<p>2.2 jdk 8中ArrayList的变化：<br>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组</p>
</li>
</ol>
<p>*<br>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]<br>…<br>后续的添加和扩容操作与jdk 7 无异。<br> 2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象<br>     的创建类似于单例的懒汉式，–&gt;延迟了数组的创建，节省内存。</p>
<p>4.2 LinkedList的源码分析：<br>   LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null<br>    list.add(123);//将123封装到Node中，创建了Node对象。<br>    *<br>    其中，Node定义为：体现了LinkedList的双向链表的说法<br>    private static class Node<e> {<br>     E item;<br>     Node<e> next;<br>     Node<e> prev;</e></e></e></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"> Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</span><br><span class="line"> this.item = element;</span><br><span class="line"> this.next = next;</span><br><span class="line"> this.prev = prev;</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line">*</span><br></pre></td></tr></tbody></table></figure>

<p>4.3 Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。<br>   在扩容方面，默认扩容为原来的数组长度的2倍。  stack</p>
<p>left right  二叉树</p>
<p>5.存储的元素的要求:<br>添加的对象:所在的类要重写equals()方法|</p>
<p>[面试题]</p>
<p>面试题：ArrayList、LinkedList、Vector三者的异同？<br>同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据<br>不同：见上</p>
<h2 id="4-复习"><a href="#4-复习" class="headerlink" title="4.复习"></a>4.复习</h2><p>1.存储的数据特点:无序的、不可重复的元素</p>
<p>具体的:<br>以HashSet为例说明:</p>
<ol>
<li>无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</li>
<li>不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。<br>2.元素添加过程: ( 以HashSet为例)<br> 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br> 此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断<br>  数组此位置上是否已经有元素：<br>   如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>   如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<pre><code>        如果hash值不相同，则元素a添加成功。---&gt;情况2
        如果hash值相同，进而需要调用元素a所在类的equals()方法：
               equals()返回true,元素a添加失败
               equals()返回false,则元素a添加成功。---&gt;情况2
对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。
jdk 7 :元素a放到数组中，指向原来的元素。
jdk 8 :原来的元素在数组中，指向元素a
总结：七上八下</code></pre></li>
</ol>
<p>HashSet底层：数组+链表的结构。（前提jdk7）</p>
<p>3.常用方法<br>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</p>
<p>4.常用实现类:<br>|—-Collection接口：单列集合，用来存储一个一个的对象<br>     |—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”<br>         |—-HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值<br>             |—-LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历<br>|在添加数据的同时，每个数据还维护J两个引用，记录此数据前一一个数据和后一个数据。</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">                        对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">|----TreeSet：可以按照添加对象的指定属性，进行排序。  红黑树</span><br></pre></td></tr></tbody></table></figure>

<p>5.存储对象所在类的要求:<br>HashSet/LinkedHashSet:<br>要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()<br>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码<br> 重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p>
<p>TreeSet:<br>1.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().<br>2.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</p>
<ol start="6">
<li>TreeSet的使用<br>6.1使用说明:<br>1.向TreeSet中添加的数据，要求是相同类的对象。<br>2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）<br>6.2常用的排序方式:<br><img src="/2017/07/06/2016-07-06-ji-he-bu-1/23_57" alt="自然排序"><br><img src="/2017/07/06/2016-07-06-ji-he-bu-1/23_61" alt="定制排序"></li>
</ol>
<h2 id="5-TreeSet的课后练习"><a href="#5-TreeSet的课后练习" class="headerlink" title="5.TreeSet的课后练习"></a>5.TreeSet的课后练习</h2><p>1.定义一个Employee类。<br>该类包含:private 成员变量name,age,birthday，其中birthday 为MyDate类的对象;并为每-一个属性定义getter, setter方法;并重写toString方法输出name, age, birthday</p>
<p>MyDate类包含:private成员变量year,month,day;并为每一个属性定 义getter, setter<br>方法;</p>
<p>创建该类的5个对象，并把这些对象放入TreeSet 集合中(下一章:TreeSet需使用泛型来定义)<br>分别按以下两种方式对集合中的元素进行排序，并遍历输出:<br>1).使Employee实现Comparable 接口，并按name排序<br>2).创建TreeSet 时传入Comparator 对象，按生日日期的先后排序。</p>
<p>MyDate m1=new MyDate(2020,11,31);<br>Employee e2=new  Employee(“jim”,17,new MyDate(2001,11,26));</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_07" alt="1588299061194"></p>
<p>方式二在MyDate 实现Com  的接口</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_08" alt="1588299129432"></p>
<h2 id="6-Set-课后2道面试题"><a href="#6-Set-课后2道面试题" class="headerlink" title="6. Set 课后2道面试题"></a>6. Set 课后2道面试题</h2><p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/23_59" alt="1588258563702"><br>删除先去找hash值</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_09" alt="1588299877584"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/23_60" alt="1588258589496"></p>
<p>位置hashCode 没错；然后    报错了，没有equals</p>
<h2 id="7-Map接口及其多个实现类的对比"><a href="#7-Map接口及其多个实现类的对比" class="headerlink" title="7.Map接口及其多个实现类的对比"></a>7.Map接口及其多个实现类的对比</h2><p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_10" alt="1588300201403"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_11" alt="1588300302969"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_12" alt="1588300324391"></p>
<p>一、Map的实现类的结构：<br> |—-Map:双列数据，存储key-value对的数据   —类似于高中的函数：y = f(x)<br>        |—-HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value<br>             |—-LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。<br>                     原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。<br>                     对于频繁的遍历操作，此类执行效率高于HashMap。<br>        |—-TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序<br>                     底层使用红黑树<br>        |—-Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value<br>             |—-Properties:常用来处理配置文件。key和value都是String类型<br>     HashMap的底层：数组+链表  （jdk7及之前）<br>                   数组+链表+红黑树 （jdk 8）<br> *<br> *<br> 面试题：</p>
<ol>
<li>HashMap的底层实现原理？</li>
<li>HashMap 和 Hashtable的异同？</li>
<li>CurrentHashMap 与 Hashtable的异同？（暂时不讲）<br>*</li>
</ol>
<h2 id="8-Map中存储的key-value的特点"><a href="#8-Map中存储的key-value的特点" class="headerlink" title="8.Map中存储的key-value的特点"></a>8.Map中存储的key-value的特点</h2><p>二、Map结构的理解：<br>      Map中的key:无序的、不可重复的，使用Set存储所有的key  —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）<br>      Map中的value:无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()<br>      一个键值对：key-value构成了一个Entry对象。<br>      Map中的entry:无序的、不可重复的，使用Set存储所有的entry</p>
<h2 id="9-HashMap在JDK7中的底层实现原理"><a href="#9-HashMap在JDK7中的底层实现原理" class="headerlink" title="9.HashMap在JDK7中的底层实现原理"></a>9.HashMap在JDK7中的底层实现原理</h2><p> 三、HashMap的底层实现原理？以jdk7为例说明：<br>     HashMap map = new HashMap():<br>     在实例化以后，底层创建了长度是16的一维数组Entry[] table。<br>     …可能已经执行过多次put…<br>     map.put(key1,value1):<br>     首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。<br>     如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1<br>     如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据<br>     的哈希值：<br>             如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2<br>             如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：<br>                     如果equals()返回false:此时key1-value1添加成功。—-情况3<br>                     如果equals()返回true:使用value1替换value2。<br> *<br>      补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。<br> *<br>     在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<h2 id="10-HashMap在JDK8中的底层实现原理"><a href="#10-HashMap在JDK8中的底层实现原理" class="headerlink" title="10.HashMap在JDK8中的底层实现原理"></a>10.HashMap在JDK8中的底层实现原理</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">jdk8 相较于jdk7在底层实现方面的不同：</span><br><span class="line">1. new HashMap():底层没有创建一个长度为16的数组</span><br><span class="line">2. jdk 8底层的数组是：Node[],而非Entry[]</span><br><span class="line">3. 首次调用put()方法时，底层创建长度为16的数组</span><br><span class="line">4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</span><br><span class="line">   4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</span><br><span class="line">      4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="11-HashMap在JDK7中的源码分析"><a href="#11-HashMap在JDK7中的源码分析" class="headerlink" title="11.HashMap在JDK7中的源码分析."></a>11.HashMap在JDK7中的源码分析.</h2><h2 id="12-HashMap在JDK8中的源码分析"><a href="#12-HashMap在JDK8中的源码分析" class="headerlink" title="12.HashMap在JDK8中的源码分析."></a>12.HashMap在JDK8中的源码分析.</h2><p> 在第12个  如果存储的是null  不扩容<br>     DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16<br>     DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75<br>     threshold：扩容的临界值，=容量<em>填充因子：16\</em>0.75 =&gt; 12<br>     TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8<br>     MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64<br> *</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_13" alt="1588305937157"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_14" alt="1588305963226"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_15" alt="1588305984564"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_16" alt="1588306013458"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_17" alt="1588306051967"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_18" alt="1588306080705"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_19" alt="1588306114766"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_20" alt="1588306139611"></p>
<p> <img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_21" alt="1588306157975"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_22" alt="1588306176088"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_23" alt="1588306192670"></p>
<p>出现链表的情况少</p>
<h2 id="13-LinkedHashMap的底层实现原理"><a href="#13-LinkedHashMap的底层实现原理" class="headerlink" title="13.LinkedHashMap的底层实现原理"></a>13.LinkedHashMap的底层实现原理</h2><p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_24" alt="1588306320593"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_25" alt="1588306337685"></p>
<p>四、LinkedHashMap的底层实现原理（了解）<br>     源码中：<br>     static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {<br>             Entry&lt;K,V&gt; before, after;//能够记录添加的元素的先后顺序<br>             Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {<br>                super(hash, key, value, next);<br>             }<br>         }<br> *Present=new Object</p>
<h2 id="14-Map中的常用方法"><a href="#14-Map中的常用方法" class="headerlink" title="14. Map中的常用方法"></a>14. Map中的常用方法</h2><p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_26" alt="1588306693853"></p>
<p>​    <img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_27" alt="1588306714103"></p>
<p>  五、Map中定义的方法：<br> 添加、删除、修改操作：<br> Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_28" alt="1588306821736"></p>
<p> void putAll(Map m):将m中的所有key-value对存放到当前map中<br> Object remove(Object key)：移除指定key的key-value对，并返回value</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_29" alt="1588306909088"></p>
<p> 不存在null</p>
<p>void clear()：清空当前map中的所有数据</p>
<p>{}  size:0</p>
<p> 元素查询的操作：</p>
<p>   Object get(Object key)：获取指定key对应的value</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_30" alt="1588307047376"></p>
<p> boolean containsKey(Object key)：是否包含指定的key<br> boolean containsValue(Object value)：是否包含指定的value<br> int size()：返回map中key-value对的个数</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_31" alt="1588307157255"></p>
<p> boolean isEmpty()：判断当前map是否为空   new的·对象依然存在</p>
<p> boolean equals(Object obj)：判断当前map和参数对象obj是否相等</p>
<h2 id="15-Map中的常用方法2"><a href="#15-Map中的常用方法2" class="headerlink" title="15.Map中的常用方法2"></a>15.Map中的常用方法2</h2><p> 元视图操作的方法：<br> Set keySet()：返回所有key构成的Set集合<br> Collection values()：返回所有value构成的Collection集合<br> Set entrySet()：返回所有key-value对构成的Set集合</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_32" alt="1588311167816"></p>
<p> 总结：常用方法：<br>添加：put(Object key,Object value)<br>删除：remove(Object key)<br>修改：put(Object key,Object value)<br>查询：get(Object key)<br>长度：size()<br>遍历：keySet() / values() / entrySet()</p>
<h2 id="16-TreeMap两种添加方式的使用"><a href="#16-TreeMap两种添加方式的使用" class="headerlink" title="16.TreeMap两种添加方式的使用"></a>16.TreeMap两种添加方式的使用</h2><p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_33" alt="1588311543622"></p>
<p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象<br>因为要按照key进行排序：自然排序 、定制排序<br>自然排序</p>
<p>person  implements Compable </p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_34" alt="1588311960563"></p>
<p>定制排序:</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_35" alt="1588312030825"></p>
<p>不能按照 value 排序</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_36" alt="1588312121291"></p>
<h2 id="17-Properties处理属性文件"><a href="#17-Properties处理属性文件" class="headerlink" title="17.Properties处理属性文件"></a>17.Properties处理属性文件</h2><p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_37" alt="1588312158878"></p>
<p>​    //Properties:常用来处理配置文件。key和value都是String类型   ，文件读到内存当中</p>
<p>workspace-&gt;</p>
<p>new -&gt; Resource  Bundle-&gt;jdbc-&gt;ok</p>
<p>name=tom</p>
<p>password=abc123</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_38" alt="1588312564631"></p>
<p>File Encodings-Transparent-native&gt;打钩 </p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_39" alt="1588312710514"></p>
<h2 id="18-Collections工具类常用方法的测试"><a href="#18-Collections工具类常用方法的测试" class="headerlink" title="18.Collections工具类常用方法的测试"></a>18.Collections工具类常用方法的测试</h2><p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_40" alt="1588312942185"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_41" alt="1588312989372"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_42" alt="1588313045587"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_43" alt="1588313074625"> 不用了听一下就可以</p>
<p> 面试题：Collection 和 Collections的区别？</p>
<p>reverse(List)：反转 List 中元素的顺序<br>shuffle(List)：对 List 集合元素进行随机排序<br>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序<br>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序<br>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
<p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素<br>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素<br>Object min(Collection)<br>Object min(Collection，Comparator)<br>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_47" alt="1588313901489"></p>
<p>void copy(List dest,List src)：将src中的内容复制到dest中</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_48" alt="1588314164802"></p>
<p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
<p>返回线程安全的</p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_49" alt="1588314240465"></p>
<h2 id="19-集合课后几道练习题说明"><a href="#19-集合课后几道练习题说明" class="headerlink" title="19. 集合课后几道练习题说明."></a>19. 集合课后几道练习题说明.</h2><p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_44" alt="1588313104484"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_45" alt="1588313136326"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_50" alt="1588314515984"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he-bu-1/24_46" alt="1588313155704"></p>
<p>hashSet</p>
<h2 id="20-java数据结构的简述"><a href="#20-java数据结构的简述" class="headerlink" title="20.java数据结构的简述"></a>20.java数据结构的简述</h2><p>战术与策略 ： 数据结构</p>
<p>研究数据结构的目的是:加快程序执行速度，减少内存占有空间</p>
<p>算法是为了解决实际问题而设计的,数据结构是算法需要处理的问题载体。</p>
<p>数据结构与算法分析Java语言描述(第2版) [美] 卡拉罗(Carrano,FM.)<br>著金名，等译</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2017/07/06/2016-07-06-ji-he/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>1.什么是枚举类？枚举类的对象声明的修饰符都有哪些？</p>
<p>枚举类：类中的对象的个数是确定的，有限个。</p>
<p>private final (No)</p>
<p>public static final (Yes)</p>
<p>2.什么是元注解？说说Retention和Target元注解的作用</p>
<p>元注解：对现有的注解进行解释说明的注解。</p>
<p>Retention：指明所修饰的注解的生命周期。SOURCE CLASS RUNTIME</p>
<ol start="3">
<li>说说你所理解的集合框架都有哪些接口，存储数据的特点是什么</li>
</ol>
<ol start="4">
<li>比较throw 和 throws 的异同</li>
</ol>
<p>同：</p>
<p>throw:生成一个异常对象，并抛出。使用在方法内部 &lt;-&gt; 自动抛出异常对象</p>
<p>throws:处理异常的方式。使用在方法声明处的末尾&lt;-&gt;try-catch-finally</p>
<p>“上游排污，下游治污”</p>
<ol start="5">
<li>谈谈你对同步代码块中同步监视器和共享数据的理解及各自要求。<br>同步监视器：俗称锁。①任何一个类的对象都可以充当锁。② 多个线程共用同一把锁。<br>共享数据：多个线程共同操作的数据，即为共享数据。<br>需要使用同步机制将操作共享数据的代码包起来。不能包多了，也不能包少了。<h2 id="2-复习枚举类"><a href="#2-复习枚举类" class="headerlink" title="2.复习枚举类"></a>2.复习枚举类</h2></li>
<li>枚举类的说明:</li>
</ol>
<p>1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类<br>2.当需要定义一组常量时，强烈建议使用枚举类<br>3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</p>
<p>2.如何自定义枚举类?步骤:<br><img src="/2017/07/06/2016-07-06-ji-he/22_03" alt="自定义枚举类"></p>
<ol start="3">
<li>jdk 5.0新增使用enum定义枚举类。步骤:<br><img src="/2017/07/06/2016-07-06-ji-he/22_04.png" alt="自定义枚举类"></li>
<li>使用enum定 义枚举类之后，枚举类常用方法: (继承于java. lang. Enum类)<br><img src="/2017/07/06/2016-07-06-ji-he/22_09.png" alt="enum类的常用方法"></li>
</ol>
<p>5.使用enum定义枚举类之后，如何让枚举类对象分别实现接口:</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/22_10.png" alt="枚举类对象分别实现接口"></p>
<h2 id="3-复习-注解"><a href="#3-复习-注解" class="headerlink" title="3.复习:注解"></a>3.复习:注解</h2><p>1.注解的理解<br>① jdk 5.0 新增的功能<br>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,<br>程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。<br>③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。<br>框架=注解+反射机制+设计模式</p>
<p>2.注解的使用示例<br>示例一：生成文档相关的注解<br>示例二：在编译时进行格式检查(JDK内置的三个基本注解)<br>  @Override: 限定重写父类方法, 该注解只能用于方法;;加上注解编译的时候校验,不加在运行时校验<br>  @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择(向下兼容)<br>  @SuppressWarnings: 抑制编译器警告<br>示例:跟踪代码依赖性,实现替代配置文件功能</p>
<p>3.如何自定义注解</p>
<p>如何自定义注解：参照@SuppressWarnings定义<br>     ① 注解声明为：@interface<br>     ② 内部定义成员，通常使用value表示<br>     ③ 可以指定成员的默认值，使用default定义<br>     ④ 如果自定义注解没有成员，表明是一个标识作用。override<br>说明:<br>仿照这些<br>如果注解有成员，在使用注解时，需要指明成员的值。<br> 自定义注解必须配上注解的信息处理流程(使用反射)才有意义。<br> 自定义注解通过都会指明两个元注解：Retention、Target<br>代码举例:<br>@Inherited<br>@Repeatable(MyAnnotations . class)<br>@Retention( RetentionPolicy.RUNTIME)<br>@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_ ,VARIABLE , TYPE_ PARAMETER,<br>TYPE_ USE})<br>public @interface MyAnnotation {<br>String value() default “hello”;<br>}<br>4.元注解:对现有的注解进行解释说明的注解。<br>.jdk 提供的4种元注解<br>Retention：指定所修饰的 Annotation 的生命周期：SOURCE javac 不保留注解  \CLASS（默认行为） 运行时不保留注解 不会加载内存 \RUNTIME(运行时候需要调  反射)只有声明为RUNTIME生命周期的注解，才能通过反射获取。<br>Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素<br>     <strong>***</strong>出现的频率较低<strong>***</strong><br>Documented:表示所修饰的注解在被javadoc解析时，保留下来。<br>Inherited:被它修饰的 Annotation 将具有继承性。<br>String name 都是他的元数据<br>—&gt;类比:元数据的概念: String name = “Tom” ;<br>5.如何获取注解信息: 通过反射来进行获取、调用<br>前提:<br>前提:要求此注解的元注解Retention中声明的生命周期状态为: RUNTIME.<br>6. JDK8中注解的新特性:可重复注解、类型注解<br> 6.1 可重复注解：<br>   ① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class  两个注解关联在一起<br>   ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。<br> 6.2 类型注解：<br>    ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。<br>    ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
<h2 id="4-复习集合"><a href="#4-复习集合" class="headerlink" title="4. 复习集合"></a>4. 复习集合</h2><p>1.集合与数组存储数据概述:</p>
<p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。<br> 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）</p>
<p>2.数组存储的特点:</p>
<blockquote>
<p>一旦初始化以后，其长度就确定了。<br>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。<br>   比如：String[] arr;int[] arr1;Object[] arr2;</p>
</blockquote>
<p>3.数组存储的弊端:</p>
<blockquote>
<p>一旦初始化以后，其长度就不可修改。<br>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。<br>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用<br>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</p>
</blockquote>
<p>4.集合存储的优点:</p>
<p>解决数组存储数据方面的弊端</p>
<h4 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h4><p>1.单列集合框架结构</p>
<blockquote>
<p>  |—-Collection接口：单列集合，用来存储一个一个的对象<br>        |—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组<br>            |—-ArrayList、LinkedList、Vector<br>  *<br>        |—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”<br>            |—-HashSet、LinkedHashSet、TreeSet<br>  *<br>    |—-Map接口：双列集合，用来存储一对(key - value)一对的数据   –&gt;高中函数：y = f(x)<br>            |—-HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</p>
</blockquote>
<p>对应图示: <img src="/2017/07/06/2016-07-06-ji-he/23_04.png" alt="集合框架与数组的对比"></p>
<p>2.Collection接口常用方法:</p>
<p>3.Collection集合与数组间的转换<br>4.使用Collection集合存储对象，要求对象所属的类满足:<br>5.本章节对大家的要求:<br>层次一:选择合适的集合类去实现数据的保存，调用其内部的相关方法。</p>
<p>1.Java集合框架概述<br>2.Collection接口方法–</p>
<h2 id="1-1集合框架与数组的对比及概述"><a href="#1-1集合框架与数组的对比及概述" class="headerlink" title="1.1集合框架与数组的对比及概述"></a>1.1集合框架与数组的对比及概述</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_01.png" alt="集合框架与数组的对比"></p>
<p>一、集合框架的概述<br> *<br>1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器。<br> 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）<br> *<br>2.1 数组在存储多个数据方面的特点：<br>     &gt; 一旦初始化以后，其长度就确定了。<br>     &gt; 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。<br>      比如：String[] arr;int[] arr1;Object[] arr2;<br>2.2 数组在存储多个数据方面的缺点：<br>     &gt; 一旦初始化以后，其长度就不可修改。<br>     &gt; 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。<br>     &gt; 获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用<br>     &gt; 数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。<br> *<br>二、集合框架<br>     |—-Collection接口：单列集合，用来存储一个一个的对象<br>         |—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组<br>             |—-ArrayList、LinkedList、Vector<br> *<br>         |—-Set接口：存储无序的、不可重复的数据   –&gt;高中讲的“集合”<br>             |—-HashSet、LinkedHashSet、TreeSet<br> *<br>     |—-Map接口：双列集合，用来存储一对(key - value)一对的数据   –&gt;高中函数：y = f(x)<br>             |—-HashMap、LinkedHashMap、TreeMap、Hashtable、Properties<br> *<br> *<br>三、Collection接口中的方法的使用</p>
<p>使用场景应用:</p>
<p>外卖、</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_02.png" alt="集合框架与数组的对比"></p>
<h2 id="1-2-集合框架涉及到API"><a href="#1-2-集合框架涉及到API" class="headerlink" title="1.2 集合框架涉及到API"></a>1.2 集合框架涉及到API</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_03.png" alt="集合框架与数组的对比"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_04.png" alt="集合框架与数组的对比"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_05.png" alt="集合框架与数组的对比"></p>
<h2 id="1-3接口中的常用方法1"><a href="#1-3接口中的常用方法1" class="headerlink" title="1.3接口中的常用方法1"></a>1.3接口中的常用方法1</h2><p>什么容器干什么事</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_06.png" alt="集合框架与数组的对比"></p>
<h2 id="5-7-接口中的常用方法2-4"><a href="#5-7-接口中的常用方法2-4" class="headerlink" title="5-7.接口中的常用方法2-4"></a>5-7.接口中的常用方法2-4</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">结论：* 向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/06/2016-07-06-ji-he/23_07.png" alt="集合框架与数组的对比"><br><img src="/2017/07/06/2016-07-06-ji-he/23_08.png" alt="集合框架与数组的对比"><br><img src="/2017/07/06/2016-07-06-ji-he/23_09.png" alt="集合框架与数组的对比"></p>
<p>先学会用  ，里面怎么用，</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_11" alt="1588230154121"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_12" alt="1588230537727"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_13" alt="1588230434174"></p>
<p>在判断的时候回调用obj对象所在类的equals方法，</p>
<p>向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals().</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_14" alt="containerAll"></p>
<p>需要中需要删除一个数据  boolean值，</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_15" alt="1588231122638"></p>
<p>交集</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_16" alt="1588231454011"></p>
<p>比较两个集合元素相等，下面是不相等的，由于456的123位置，ArrayList是有序的<br><img src="/2017/07/06/2016-07-06-ji-he/23_17" alt="1588231530970"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_18" alt="hashcode"></p>
<p>``8.集合与数组之间的转换</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_19" alt="1588232608177"></p>
<h4 id="11-3-Iterator迭代器接口"><a href="#11-3-Iterator迭代器接口" class="headerlink" title="11.3.Iterator迭代器接口"></a>11.3.Iterator迭代器接口</h4><h2 id="8-使用Iterator遍历Collection"><a href="#8-使用Iterator遍历Collection" class="headerlink" title="8.使用Iterator遍历Collection"></a>8.使用Iterator遍历Collection</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_20" alt="1588233247542"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_21" alt="1588233287913"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_22" alt="1588233312775"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_23" alt="1588233352886"></p>
<p>Iterator it=coll.iterator();</p>
<p>iterator.next() 取数据   走悬崖 在next 就输了</p>
<p>iterator.hasNext() 取数据时判断有没有下一个</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_10" alt="1588233835930"></p>
<p>集合元素的遍历操作，使用迭代器Iterator接口<br>1.内部的方法：hasNext() 和  next()<br>2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，<br>默认游标都在集合的第一个元素之前。<br>3.内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</p>
<h2 id="9-迭代器的执行原理"><a href="#9-迭代器的执行原理" class="headerlink" title="9.迭代器的执行原理"></a>9.迭代器的执行原理</h2><p>next 下移了</p>
<h2 id="10-Iterator遍历集合的两种错误写法"><a href="#10-Iterator遍历集合的两种错误写法" class="headerlink" title="10.Iterator遍历集合的两种错误写法"></a>10.Iterator遍历集合的两种错误写法</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">//错误方式一：</span></span><br><span class="line"><span class="comment">//        Iterator iterator = coll.iterator();</span></span><br><span class="line"><span class="comment">//        while((iterator.next()) != null){</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//错误方式二： 死循环</span></span><br><span class="line">        <span class="comment">//集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span></span><br><span class="line">        <span class="keyword">while</span> (coll.iterator().hasNext()){</span><br><span class="line">            System.out.println(coll.iterator().next());</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="11-Iterator跌代器remove-的使用"><a href="#11-Iterator跌代器remove-的使用" class="headerlink" title="11.Iterator跌代器remove()的使用"></a>11.Iterator跌代器remove()的使用</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_24" alt="1588235037160"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_25" alt="1588235187171"></p>
<p>迭代器只适用于 Collection 不适合Map</p>
<h2 id="12-使用foreach循环遍历集合或数组"><a href="#12-使用foreach循环遍历集合或数组" class="headerlink" title="12.使用foreach循环遍历集合或数组"></a>12.使用foreach循环遍历集合或数组</h2><p><strong><img src="/2017/07/06/2016-07-06-ji-he/..%5CstudyNote_Pic%5Csgg%5Cday12%5C1588235499265.png" alt="1588235499265"></strong></p>
<p>jdk 5.0 新增了foreach循环，用于遍历集合、数组</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_26" alt="1588235758885"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/F:%5Cdocument%5CstudyNote_Pic%5Csgg%5Cday24%5C24_06" alt="1588294337913"></p>
<p>4.Collection子接口一: List</p>
<h2 id="13-List接口常用实现类的对比"><a href="#13-List接口常用实现类的对比" class="headerlink" title="13. List接口常用实现类的对比"></a>13. List接口常用实现类的对比</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_27" alt="1588238240273"></p>
<p>动态数组</p>
<blockquote>
<ol>
<li>List接口框架</li>
</ol>
<p>*<br>|—-Collection接口：单列集合，用来存储一个一个的对象<br>   |—-List接口：存储有序的、可重复的数据。  –&gt;“动态”数组,替换原有的数组<br>       |—-ArrayList：作为List接口的<code>主要实现类</code>；线程不安全的，效率高；底层使用Object[] elementData存储<br>       |—-LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储  —》 铁链子 内部   打比方 传话<br>       |—-Vector：作为List接口的<code>古老实现类</code>；线程安全的，效率低；底层使用Object[] elementData存储      打比方  不怎么用，   皇帝与旧臣<br>*<br>*</p>
<ol start="2">
<li><p>ArrayList的源码分析：<br>2.1 jdk 7情况下<br>ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData<br>list.add(123);//elementData[0] = new Integer(123);<br>…<br>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。<br>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p>
<pre><code>*</code></pre><p><strong><strong><strong>**</strong></strong></strong>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)；</p>
<pre><code>*</code></pre><p>2.2 jdk 8中ArrayList的变化：<br>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组<br>*<br>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]<br>…<br>后续的添加和扩容操作与jdk 7 无异。<br>2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象<br>的创建类似于单例的懒汉式，–&gt;延迟了数组的创建，节省内存。<br>*</p>
<ol start="3">
<li><p>LinkedList的源码分析：<br>LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null<br>list.add(123);//将123封装到Node中，创建了Node对象。<br> *<br>其中，Node定义为：体现了LinkedList的双向链表的说法<br>private static class Node<e> {<br>E item;<br>Node<e> next;<br>Node<e> prev;</e></e></e></p>
<p>Node(Node<e> prev, E element, Node<e> next) {<br>this.item = element;<br>this.next = next;<br>this.prev = prev;<br>}<br> }<br> *</e></e></p>
</li>
</ol>
</li>
<li><p>Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。<br>在扩容方面，默认扩容为原来的数组长度的2倍。</p>
<pre><code>*</code></pre></li>
<li><p>面试题：ArrayList、LinkedList、Vector三者的异同？<br>   同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据<br>   不同：见上<br>   *<br>   *<br>   *</p>
</li>
<li><p>List接口中的常用方法</p>
<pre><code>*</code></pre><p>*/<br>public class ListTest {</p>
</li>
</ol>
<p>/*<br>void add(int index, Object ele):在index位置插入ele元素<br>boolean addAll(int index, Collection eles):从index位置开始将el中的所有元素添加进来<br>Object get(int index):获取指定index位置的元素<br>int indexOf(Object obj):返回obj在集合中首次出现的位置<br>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置<br>Object remove(int index):移除指定index位置的元素，并返回此元素<br>Object set(int index, Object ele):设置指定index位置的元素为ele<br>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</p>
<p>总结：常用方法<br>增：add(Object obj)<br>删：remove(int index) / remove(Object obj)<br>改：set(int index, Object ele)<br>查：get(int index)<br>插：add(int index, Object ele)<br>长度：size()<br>遍历：① Iterator迭代器方式<br>② 增强for循环<br>③ 普通的循环</p>
</blockquote>
<h2 id="14-ArrayList的源码分析"><a href="#14-ArrayList的源码分析" class="headerlink" title="14.ArrayList的源码分析."></a>14.ArrayList的源码分析.</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_28" alt="1588248406497"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_29" alt="1588248456802"></p>
<p>1 2   删除对象的2  new Integer(2);</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_30" alt="1588249313814"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_31" alt="1588249357520"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_32" alt="1588250168534"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_33" alt="1588250191038"></p>
<h2 id="17-List接口中的常用方法测试"><a href="#17-List接口中的常用方法测试" class="headerlink" title="17.List接口中的常用方法测试"></a>17.List接口中的常用方法测试</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_34" alt="1588250685082"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_35" alt="1588250811845"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_36" alt="1588250919730"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_37" alt="1588250995382"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_38" alt="1588251488259"></p>
<h2 id="18-List遍历及方法总结，"><a href="#18-List遍历及方法总结，" class="headerlink" title="18.List遍历及方法总结，"></a>18.List遍历及方法总结，</h2><h2 id="19-List一个面试小题"><a href="#19-List一个面试小题" class="headerlink" title="19.List一个面试小题"></a>19.List一个面试小题</h2><p>new Integer(123)  编程对象</p>
<p>5.Collection子接口二: Set</p>
<h2 id="20-Set接口实现类的对比"><a href="#20-Set接口实现类的对比" class="headerlink" title="20.Set接口实现类的对比"></a>20.Set接口实现类的对比</h2><ol>
<li><p>Set接口的框架：<br>*<br>|—-Collection接口：单列集合，用来存储一个一个的对象</p>
<pre><code>|----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”
    |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值
        |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历
                            对于频繁的遍历操作，LinkedHashSet效率高于HashSet.
    |----TreeSet：可以按照添加对象的指定属性，进行排序。  红黑树</code></pre><ol>
<li><p>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</p>
</li>
<li><p>要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()<br>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码<br>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="21-Set的无序性与不可重复性的理解-开发使用set-相对较少"><a href="#21-Set的无序性与不可重复性的理解-开发使用set-相对较少" class="headerlink" title="21.Set的无序性与不可重复性的理解(开发使用set 相对较少)"></a>21.Set的无序性与不可重复性的理解(开发使用set 相对较少)</h2><p>一、Set：存储无序的、不可重复的数据<br>    以HashSet为例说明：</p>
<pre><code>1. 无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。
2. 不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</code></pre><p><img src="/2017/07/06/2016-07-06-ji-he/23_44" alt="1588255431446"></p>
<h2 id="22-HashSet中元素的添加过程"><a href="#22-HashSet中元素的添加过程" class="headerlink" title="22.HashSet中元素的添加过程"></a>22.HashSet中元素的添加过程</h2><p>二、添加元素的过程：以HashSet为例：</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_45" alt="1588255855277"></p>
<p>7上⑧下  equal是true 才真一样，，首先比较code</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_46" alt="1588256082550"></p>
<p> 我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，<br>  此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断<br>     数组此位置上是否已经有元素：<br>      如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1<br>      如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<br>                如果hash值不相同，则元素a添加成功。—&gt;情况2<br>                如果hash值相同，进而需要调用元素a所在类的equals()方法：<br>                       equals()返回true,元素a添加失败<br>                       equals()返回false,则元素a添加成功。—&gt;情况2<br>        对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。<br>        jdk 7 :元素a放到数组中，指向原来的元素。<br>        jdk 8 :原来的元素在数组中，指向元素a<br>        总结：七上八下</p>
<p>HashSet底层：数组+链表的结构。</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_39" alt="1588254051229"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_40" alt="1588254073703"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_41" alt="1588254100816"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_42" alt="1588254130148"></p>
<h2 id="23-关于hashCode0和equals0的重写"><a href="#23-关于hashCode0和equals0的重写" class="headerlink" title="23.关于hashCode0和equals0的重写"></a>23.关于hashCode0和equals0的重写</h2><p>object hashcode 是随机算一个数</p>
<p>简单   return name.hashCode()+age    *31  相撞的概率降低</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_43" alt="1588254149292"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_47" alt="1588257098672"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_48" alt="1588257121779"></p>
<h2 id="24-LinkedHashSet的使用"><a href="#24-LinkedHashSet的使用" class="headerlink" title="24.LinkedHashSet的使用"></a>24.LinkedHashSet的使用</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_49" alt="1588257382531"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_50" alt="1588257404377"></p>
<pre><code>//LinkedHashSet的使用
//LinkedHashSet作为HashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个
//数据和后一个数据。
//优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet</code></pre><h2 id="25-TreeSet的自然排序"><a href="#25-TreeSet的自然排序" class="headerlink" title="25.TreeSet的自然排序"></a>25.TreeSet的自然排序</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_51" alt="1588257765196"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_52" alt="1588257797735"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/..%5CstudyNote_Pic%5Csgg%5Cday12%5C1588257833503.png" alt="1588257833503"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_53" alt="1588257928340"></p>
<p> 1.向TreeSet中添加的数据，要求是相同类的对象。</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_54" alt="1588257974316"></p>
<pre><code>2.两种排序方式：自然排序（实现Comparable接口） 和 定制排序（Comparator）


3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0.不再是equals().
4.定制排序中，比较两个对象是否相同的标准为：compare()返回0.不再是equals().</code></pre><p>自然排序 <img src="/2017/07/06/2016-07-06-ji-he/..%5CstudyNote_Pic%5Csgg%5Cday12%5C1588258133647.png" alt="1588258133647"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_55" alt="1588258169601"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_56" alt="1588258224022"></p>
<p>compareTo 为0，他就认为是一样的</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_57" alt="1588258371921"></p>
<p>二叉排序树</p>
<h2 id="26-TreeSet的定制排序"><a href="#26-TreeSet的定制排序" class="headerlink" title="26.TreeSet的定制排序"></a>26.TreeSet的定制排序</h2><p><img src="/2017/07/06/2016-07-06-ji-he/23_58" alt="1588258533624"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_59" alt="1588258563702"></p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_60" alt="1588258589496"></p>
<p>(com) 定制排序，没写按照默认排序</p>
<p><img src="/2017/07/06/2016-07-06-ji-he/23_61" alt="1588258673989"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举类与注解</title>
    <url>/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><ol>
<li>将字符串”2017-08-16”转换为对应的java.sql.Date类的对象。</li>
</ol>
<p>（使用JDK8之前或JDK8中的API皆可）</p>
<p>SimpleDateFormat  sdf = new SimpleDateFormat(“yyyy-MM-dd”);</p>
<p>解析：java.util.Date date = sdf.parse(“2017-08-16”);</p>
<p>DateTimeFormatter dtf= DateTimeFormatter.ofPattern(“yyyy-MM-dd”); </p>
<p>new + 构造器</p>
<p>单例、Calendar.getInstance()</p>
<ol start="2">
<li>解释何为编码？解码？ 何为日期时间的格式化？解析？</li>
</ol>
<p>编码：字符串 -&gt;字节</p>
<p>解码：字节 -&gt;字符串</p>
<p>格式化：日期 -&gt;字符串 format</p>
<p>解析：字符串 -&gt;日期  parse </p>
<ol start="3">
<li>自定义Person类如下，如何实现自然排序（按姓名从小到大排序），代码说明</li>
</ol>
<p>class Person implements Comparable{</p>
<p>​       private String name;</p>
<p>​       private int age;</p>
<p>​       public int compareTo(Object obj){</p>
<p>​              //…  this.name.compareTo(s.name);</p>
<p>}</p>
<p>}</p>
<ol start="4">
<li>提供定制排序涉及到的接口的实现类对象，并按Person类的年龄从大到小排序</li>
</ol>
<p>Comparator com = new Comparator(){</p>
<p>​       public int compare(Object obj1,Object obj2){</p>
<p>​              if(){</p>
<p>}</p>
<p>}</p>
<p>};</p>
<ol start="5">
<li>JDK 8之前和JDK8中日期、时间相关的类分别有哪些？</li>
</ol>
<p>java.util.Date 和 java.sql.Date  -&gt; Instant</p>
<p>SimpleDateFormat  -&gt;DateTimeFormatter</p>
<p>Calendar  -&gt; LocalDate、LocalTime、LocalDateTime</p>
<h2 id="2-复习-日期时间API"><a href="#2-复习-日期时间API" class="headerlink" title="2.复习 日期时间API"></a>2.复习 日期时间API</h2><p>痛苦才有所变化</p>
<ol start="3">
<li>java . text. SimpleDataFormat类<br>SimpleDateFormat对日期Date类的格式化和解析<br>1.两个操作:<br>1.1 格式化:日期—&gt;字符串<br>1.2解析:格式化的逆过程，字符串—&gt; 日期<br>2.SimpleDateFormat的实例化:new +构造器</li>
</ol>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_18.png" alt="##SimpleDateFormat"></p>
<p>小练习:</p>
<p>练习一：字符串”2020-09-08”转换为java.sql.Date</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   String birth = <span class="string">"2020-09-08"</span>;</span><br><span class="line">  SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">  Date date = sdf1.parse(birth);</span><br><span class="line"><span class="comment">// System.out.println(date);</span></span><br><span class="line">java.sql.Date birthDate = <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">System.out.println(birthDate);</span><br></pre></td></tr></tbody></table></figure>

<p>练习二：”三天打渔两天晒网”   1990-01-01  xxxx-xx-xx 打渔？晒网？<br>    举例：2020-09-08 ？ 总天数</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">总天数 % 5 == 1,2,3 : 打渔</span><br><span class="line">总天数 % 5 == 4,0 : 晒网</span><br><span class="line"></span><br><span class="line">总天数的计算？</span><br><span class="line">方式一：( date2.getTime() - date1.getTime()) / (1000606024) + 1（小数）=...天</span><br><span class="line">方式二：1990-01-01  --&gt; 2019-12-31  +  2020-01-01 --&gt;2020-09-08</span><br></pre></td></tr></tbody></table></figure>

<p>4.Calendar类： 日历类，抽象类</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_20" alt="calendar的使用"></p>
<h4 id="JDK8新日期时间API"><a href="#JDK8新日期时间API" class="headerlink" title="JDK8新日期时间API"></a>JDK8新日期时间API</h4><p>1.日期时间API的迭代:<br>第一代: jdk1.0Date类<br>第二代: jdk 1.1 Calendar类，一定程度 上替换Date类<br>第三代: jdk 1.8提出了新的一套API</p>
<p>2.前两代存在的问题举例:<br>可变性:像日期和时间这样的类应该是不可变的。<br>偏移性: Date中的年份是从1900开始的，而月份都从0开始。<br>格式化:格式化只对Date用，Calendar则不行。<br>此外，它们也不是线程安全的;不能处理闰秒等。</p>
<p>3.java 8中新的日期时间API涉及到的包</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_24.png" alt="calendar的使用"></p>
<p>4.本地日期、本地时间、本地日期时间的使用: LocalDate / LocalTime / LocalDateTime</p>
<p>4.1说明:</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_25.png" alt="calendar的使用"></p>
<p>说明：<br>        1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高<br>        2.类似于Calendar</p>
<p>4.2常用方法:</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_26.png" alt="calendar的使用"></p>
<p>5.时间点: Instant<br>5.1说明:</p>
<p>①时间线上的一个瞬时点。概念上讲， 它只是简单的表示自1970年1月1日0时0分0秒(UTC开始的秒数。)<br>②类似于java.util.Date类</p>
<p>5.2常用方法:</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_30.png" alt="Instant"></p>
<p>6.日期时间格式化类: DateTimeFormatter<br>6.1说明:</p>
<p>6.日期时间格式化类: DateTimeFormatter<br>6.1说明:</p>
<p>①格式化或解析日期、时间<br>②类似于SimpleDateFormat</p>
<p>6.2常用方法:</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_32.png" alt="Instant"></p>
<p>特别的:自定义的格式。如: ofPattern(“””yy-MM-dd h:mmss”);方式三</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_33" alt="1588165071299"></p>
<p>7.其它API的使用(不讲)</p>
<h2 id="3-复习-Java比较器"><a href="#3-复习-Java比较器" class="headerlink" title="3.复习 Java比较器"></a>3.复习 Java比较器</h2><p>1.Java比较器的使用背景:.</p>
<p>Java中的对象，正常情况下，只能进行比较:==或!=。不能使用〉或&lt;的<br>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。如何实现?使用两个接口中的任何-一个: Comparable 或Comparator</p>
<p>2.自然排序:使用Comparable接口<br>2.1说明</p>
<p>1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。<br>2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列</p>
<p>3.重写compareTo(obj)的规则：<br>       如果当前对象this大于形参对象obj，则返回正整数，<br>       如果当前对象this小于形参对象obj，则返回负整数，<br>       如果当前对象this等于形参对象obj，则返回零。<br>4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。<br>       在compareTo(obj)方法中指明如何排序</p>
<p>2.2自定义类代码举例:</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_48.png" alt="1588165488963"></p>
<p>3.定制排序:使用Comparator接口</p>
<p>3.1 说明</p>
<p> 1.背景：<br>    当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，<br>    或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，<br>    那么可以考虑使用 Comparator 的对象来排序<br>    2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：<br>    如果方法返回正整数，则表示o1大于o2；<br>    如果返回0，表示相等；<br>    返回负整数，表示o1小于o2。</p>
<p>3.2代码举例:</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_52.png" alt="1588165488963"></p>
<p>使用:</p>
<p>Arrays.sort(goods,com);</p>
<p>Collections.sort(coll,com);</p>
<p>new TreeSet(com)</p>
<p>4.两种排序方式对比</p>
<p>   Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。(一劳永逸)<br>   Comparator接口属于临时性的比较。(临时工)</p>
<h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><p>1.System类<img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_54.png" alt="System类"></p>
<p>native long currentTimeMillis()<br>void exitint status)<br>void gc()<br>String getProperty(String key)</p>
<p>2.Math类</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_57.png" alt="Math类"></p>
<p>3.BigInteger类、BigDecimal类<br>说明:</p>
<p>①java. math包的BigInteger可以表示不可变的任意精度的整数。<br>❷要求数字精度比较高，用到java.math.BigDecimal类</p>
<p>代码举例:</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/21_61.png" alt="BigDecimal类"></p>
<h4 id="10-1枚举类的使用"><a href="#10-1枚举类的使用" class="headerlink" title="10.1枚举类的使用"></a>10.1枚举类的使用</h4><p>如何使用关键字enum定义枚举类<br>Enum类的主要方法</p>
<h2 id="4-枚举类的理解"><a href="#4-枚举类的理解" class="headerlink" title="4.枚举类的理解"></a>4.枚举类的理解</h2><p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_01.png" alt="BigDecimal类"></p>
<p>列全</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_02.png" alt="BigDecimal类"></p>
<p>一、枚举类的使用<br>1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类<br>2.当需要定义一组常量时，强烈建议使用枚举类<br>3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。<br> *<br>二、如何定义枚举类<br>方式一：jdk5.0之前，自定义枚举类<br>方式二：jdk5.0，可以使用enum关键字定义枚举类<br> *<br>三、Enum类中的常用方法：<br>   values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。<br>   valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。<br>   toString()：返回当前枚举类对象常量的名称<br> *<br>四、使用enum关键字定义的枚举类实现接口的情况<br>  情况一：实现接口，在enum类中实现抽象方法<br>  情况二：让枚举类的对象分别实现接口中的抽象方法</p>
<h2 id="5-自定义枚举类"><a href="#5-自定义枚举类" class="headerlink" title="5.自定义枚举类"></a>5.自定义枚举类</h2><p>5.0  自动装箱 拆箱 ，stringbuilder，注解</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_03" alt="自定义枚举类"></p>
<h2 id="6-使用enum关键字定义枚举类"><a href="#6-使用enum关键字定义枚举类" class="headerlink" title="6.使用enum关键字定义枚举类"></a>6.使用enum关键字定义枚举类</h2><p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_04.png" alt="自定义枚举类"></p>
<p>​                                        public String getSeasonDesc(){ return seasonDesc }</p>
<p>不用重写toString      ‘’‘’ System.out.println(Season1.class.getSuperclass());</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_05.png" alt="自定义枚举类"></p>
<h2 id="7-enum类的常用方法"><a href="#7-enum类的常用方法" class="headerlink" title="7.enum类的常用方法"></a>7.enum类的常用方法</h2><p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_06.png" alt="自定义枚举类"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_07.png" alt="自定义枚举类"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_08.png" alt="自定义枚举类"></p>
<p>单个枚举值用 ，隔开</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_09.png" alt="enum类的常用方法"></p>
<h2 id="8-使用enum关键字定义的枚举类实现接口"><a href="#8-使用enum关键字定义的枚举类实现接口" class="headerlink" title="8.使用enum关键字定义的枚举类实现接口"></a>8.使用enum关键字定义的枚举类实现接口</h2><p> 情况一：实现接口，在enum类中实现抽象方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">interface Info{    void show();}</span><br></pre></td></tr></tbody></table></figure>

<p> enum Season1 implements Info{</p>
<p>重写方法</p>
<p>public void show() {<br>System. out. println(“这是- -个季节”);<br>}4</p>
<p>}</p>
<p>主方法:</p>
<p>winter. show();|</p>
<p>情况二：让枚举类的对象分别实现接口中的抽象方法</p>
<p>希望每个对象调用方法展示不同内容，由于情况一都是“ 这是- -个季节”</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_10.png" alt="枚举类对象分别实现接口"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_11.png" alt="自定义枚举类"></p>
<h2 id="9-修改status-为enum的定义"><a href="#9-修改status-为enum的定义" class="headerlink" title="9.修改status 为enum的定义"></a>9.修改status 为enum的定义</h2><p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_12.png" alt="自定义枚举类"></p>
<p>把myproject03放置module中，</p>
<p>setting-&gt;module-&gt;加号</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_13" alt="1588209226627"></p>
<p>两个字的名字  可以中间整空格</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_14" alt="1588209371076"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_15.png" alt="1588209371076"></p>
<p>switch 可以实现</p>
<h4 id="10-2注解的使用"><a href="#10-2注解的使用" class="headerlink" title="10.2注解的使用"></a>10.2注解的使用</h4><h2 id="10-注解的理解"><a href="#10-注解的理解" class="headerlink" title="10.注解的理解"></a>10.注解的理解</h2><p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_16.png" alt="1588209371076"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_17.png" alt="1588209371076"></p>
<p>放射  读取操作注解</p>
<h2 id="11-Annotation的使用实例"><a href="#11-Annotation的使用实例" class="headerlink" title="11.Annotation的使用实例"></a>11.Annotation的使用实例</h2><p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_18.png" alt="1588209371076"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_19.png" alt="1588209371076"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_20.png" alt="1588209371076"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_21.png" alt="1588209371076"></p>
<p>下面的替换掉</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_22.png" alt="1588209371076"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_23.png" alt="1588209371076"></p>
<ol>
<li>理解Annotation:<br>① jdk 5.0 新增的功能<br>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,<br>程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。<br>③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li>
</ol>
<h3 id="12-JDK内置的三个基本注解"><a href="#12-JDK内置的三个基本注解" class="headerlink" title="12.JDK内置的三个基本注解"></a>12.JDK内置的三个基本注解</h3><ol start="2">
<li><p>Annocation的使用示例<br>示例一：生成文档相关的注解<br>示例二：在编译时进行格式检查(JDK内置的三个基本注解)<br>  @Override: 限定重写父类方法, 该注解只能用于方法;;加上注解编译的时候校验,不加在运行时校验<br>  @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择(向下兼容)<br>  @SuppressWarnings: 抑制编译器警告</p>
<p>示例:跟踪代码依赖性,实现替代配置文件功能</p>
</li>
</ol>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_24.png" alt="1588209371076"></p>
<p> 示例三：跟踪代码依赖性，实现替代配置文件功能</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_25" alt="1588211605579"></p>
<p>rawtypes 泛型警告</p>
<p>3.如何自定义注解：参照@SuppressWarnings定义<br>     ① 注解声明为：@interface<br>     ② 内部定义成员，通常使用value表示<br>     ③ 可以指定成员的默认值，使用default定义<br>     ④ 如果自定义注解没有成员，表明是一个标识作用。override</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">如果注解有成员，在使用注解时，需要指明成员的值。</span><br><span class="line">自定义注解必须配上注解的信息处理流程(使用反射)才有意义。</span><br><span class="line">自定义注解通过都会指明两个元注解：Retention、Target</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_26.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_27" alt="1588212033250"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_28.png" alt="1588212033250"></p>
<p>指定默认值<img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_29.png" alt="1588212033250"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_30.png" alt="1588211605579"></p>
<p>回头用反射读取注解值，看想做什么</p>
<h2 id="14-15-jdk中4个基本的元注解的使用"><a href="#14-15-jdk中4个基本的元注解的使用" class="headerlink" title="14-15.jdk中4个基本的元注解的使用"></a>14-15.jdk中4个基本的元注解的使用</h2><p>4.jdk 提供的4种元注解<br>         元注解：对现有的注解进行解释说明的注解</p>
<p>Retention：指定所修饰的 Annotation 的生命周期：SOURCE javac 不保留注解  \CLASS（默认行为） 运行时不保留注解 不会加载内存 \RUNTIME(运行时候需要调  反射)只有声明为RUNTIME生命周期的注解，才能通过反射获取。<br>Target:用于指定被修饰的 Annotation 能用于修饰哪些程序元素<br>     <strong>***</strong>出现的频率较低<strong>***</strong><br>     Documented:表示所修饰的注解在被javadoc解析时，保留下来。<br>     Inherited:被它修饰的 Annotation 将具有继承性。</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_31.png" alt="1588211605579"><br><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_32.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_33.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_34" alt="1588213206634"><br>注解继承演示  具有继承性 在注解上加<br><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_35.png" alt="1588211605579"><br>5.通过反射获取注解信息 —到反射内容时系统讲解<br><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_36.png" alt="1588211605579"></p>
<h2 id="16-jdk-8-中注解的新特性"><a href="#16-jdk-8-中注解的新特性" class="headerlink" title="16.jdk 8 中注解的新特性"></a>16.jdk 8 中注解的新特性</h2><p>6.jdk 8 中注解的新特性：可重复注解、类型注解<br>  6.1 可重复注解：<br>   ① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class  两个注解关联在一起<br>   ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。<br>    <img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_37.png" alt="1588211605579"></p>
<p>   <img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_38.png" alt="1588211605579"><br>    上面是jdk8 之前</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_39.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_40.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_41.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_42.png" alt="1588211605579"></p>
<h2 id="17-类型注解"><a href="#17-类型注解" class="headerlink" title="17 类型注解"></a>17 类型注解</h2><p>  6.2 类型注解：<br>     ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。<br>     ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_43.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_44.png" alt="1588211605579"></p>
<p>注解可以修饰参数</p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_45.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_46.png" alt="1588211605579"></p>
<p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_47.png" alt="1588211605579"></p>
<h2 id="18-可重复注解中元注解不一致的问题解决"><a href="#18-可重复注解中元注解不一致的问题解决" class="headerlink" title="18.可重复注解中元注解不一致的问题解决"></a>18.可重复注解中元注解不一致的问题解决</h2><p><img src="/2017/07/05/2016-07-05-mei-ju-lei-yu-zhu-jie/22_48" alt="1588215653288"></p>
<p>元注解 解释哈哈哈</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>常用类Date</title>
    <url>/2017/07/04/2016-07-04-chang-yong-lei-date/</url>
    <content><![CDATA[<p>Java高级编程   使用层面</p>
<p>理解是可以长久保存的，别死记硬背</p>
<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>1.画出如下几行代码的内容结构:。<br>String s1 = “hello”;<br>String s2 = “hell’”;,<br>String s3 = new String(“hello”);<br>s1 += “world”;</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_01.png" alt="StringBuffer中的常用方法"></p>
<p>s1还是在堆里面，，</p>
<p>2.如何理解String类的不可变性。</p>
<p>数据不能做任何修改，s1该了  s2不能改变 </p>
<p>现有字符串的操作，必须新造</p>
<p>3.String 类是否可以被继承?为什么? </p>
<p>Strings = new Stringl”hello”);在内存中创建了几个对象?请说明</p>
<p>不能被继承， final 了</p>
<p>4.String, StringBuffer, StringBuilder 三者的对比</p>
<p>char[]</p>
<p>5.String的常用方法有哪些? (至少 7个) 4</p>
<p>length  substring equal startwith endwith  contains</p>
<p>CharAt</p>
<h2 id="2-复习-String类"><a href="#2-复习-String类" class="headerlink" title="2.复习 String类"></a>2.复习 String类</h2><p>java .lang .String类的使用<br>1.概述</p>
<p>String:字符串，使用一对””引起来表示。</p>
<ul>
<li>1.String声明为final的，不可被继承</li>
<li>2.String实现了Serializable接口：表示字符串是支持序列化的。<pre><code>实现了Comparable接口：表示String可以比较大     </code></pre></li>
<li>3.String内部定义了final char[] value用于存储字符串数据</li>
<li>4.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li>
<li>5.字符串常量池中是不会存储相同内容（使用String类的equals()比较，返回true）的字符串的。</li>
</ul>
<p>2.String的不可变性<br>2.1说明</p>
<p>1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p>
<p>2.2代码举例</p>
<p>2.3图示<br><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_02.png" alt="StringBuffer中的常用方法"></p>
<p>3.String实例化的不同方式<br>3.1方式说明</p>
<p>方式一:通过字面量定义的方式<br>方式二:通过new+构造器的方式</p>
<p>3.2 代码举例</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/20_10.png" alt="String实例化方式"></p>
<p>3.3 面试题</p>
<p>面试题: string s = new String(“abc”);方式创建对象，在内存中创建了几个对象?<br>两个:一个是堆空间中new结构，另一个是char[ ]对应的常量池中的数据: “abc “</p>
<p>3.4 图示</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_03.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_04.png" alt="StringBuffer中的常用方法"></p>
<p>4.字符串拼接方式赋值的对比<br>4.1说明</p>
<p>1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。<br>2.只要其中一个是变量，结果就在堆中。<br>3.如果拼接的结果调用intern()方法，返回值就在常量池中</p>
<p>4.2代码举例</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/20_12.png" alt="String的特性"></p>
<p>String s1 = “javaEEhadoop” ;<br>String s2 = “javaEE” ;<br>String s3 = s2 + “hadoop” ;<br>System. out.println(s1 == s3);//false<br>final String s4 = “javaEE” ;//s4:常量<br>String s5 = s4 + “hadoop” ;<br>System. out.println(s1 == s5);//true</p>
<p>String s8=s5.intern();</p>
<p>sout(s3==s8)；</p>
<p>5.常用方法</p>
<p>忘了去找  找</p>
<p>重点-&gt;反反复复用<br>6. String与其它结构的转换<br>6.1与基本数据类型、包装类之间的转换<br>String str1=”123”</p>
<p>int num=Integer.parseInt(str1)</p>
<hr>
<p>String.valueOf(num);</p>
<p>或者   num+””      .concat</p>
<p>6.2与字符数组之间的转换<br><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_05.png" alt="StringBuffer中的常用方法"></p>
<p>6.3与字节数组之间的转换<br> 编码：String –&gt; byte[]:调用String的getBytes()<br>   解码：byte[] –&gt; String:调用String的构造器</p>
<p>6.4与StringBuffer、 StringBuilder之 间的转换</p>
<p>String –&gt;StringBuffer、 StringBuilder: 调用StringBuffer、StringBuilder构造器</p>
<p>StringBuffer、StringBuilder –&gt;String调 ①用String构造器; ②StringBuffer、 StringBuilder的<br>toString()</p>
<p>7.JVM中字符串常量池存放位置说明:<br>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区(永久区)<br>jdk1.7:字符串常量池存储在堆空间<br>jdk 1.8:字符串常量池存储在方法区(元空间)</p>
<p>8.常见算法题目的考查:</p>
<h2 id="3-复习-string、StringBuffer、-StringBuilder"><a href="#3-复习-string、StringBuffer、-StringBuilder" class="headerlink" title="3.复习 string、StringBuffer、 StringBuilder"></a>3.复习 string、StringBuffer、 StringBuilder</h2><p>1.string、StringBuffer、 StringBuilder三者的对比<br>String:不可变的字符序列;底层使用char[]存储<br>StringBuffer:可变的字符序列;线程安全的，效率低;底层使用char[]存储<br>StringBuilder:可变的字符序列; jdk5. 8新增的，线程不安全的，效率高;底层使用char[]存储</p>
<p>2.StringBuffer.与StringBuilder的内存解析<br>以StringBuffer为例:<br> 源码分析：<br>    String str = new String();//char[] value = new char[0];   length=0</p>
<pre><code>String str1 = new String("abc");//char[] value = new char[]{'a','b','c'};
StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。
System.out.println(sb1.length());//
sb1.append('a');//value[0] = 'a';
sb1.append('b');//value[1] = 'b';

StringBuffer sb2 = new StringBuffer("abc");//char[] value = new char["abc".length() + 16];</code></pre><p>问题1. System.out.println(sb2.length());//3<br>    //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。<br>     默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。<br>     指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</p>
<p>应届生 学校好  底子扎实</p>
<p>3.对比String、StringBuffer、 StringBuilder三者 的执行效率<br>从高到低排列：StringBuilder &gt; StringBuffer &gt; String<br>4.stringBuffer、StringBuilder中的常用方法</p>
<pre><code>增：append(xxx)
    删：delete(int start,int end)
    改：setCharAt(int n ,char ch) / replace(int start, int end, String str)
    查：charAt(int n )
    插：insert(int offset, xxx)
    长度：length();
    *遍历：for() + charAt() / toString()</code></pre><h2 id="4-复习-日期时间的API"><a href="#4-复习-日期时间的API" class="headerlink" title="4.复习:日期时间的API"></a>4.复习:日期时间的API</h2><p>1.获取系统当前时间</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1.System类中的currentTimeMillis()</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">       <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line">       <span class="comment">//称为时间戳</span></span><br><span class="line">       System.out.println(time);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>

<p>2.java.util.Date类与java. sql .Date类<br>1.两个构造器的使用<br>    &gt;构造器一：Date()：创建一个对应当前时间的Date对象<br>    &gt;构造器二：创建指定毫秒数的Date对象<br>2.两个方法的使用<br>    &gt;toString():显示当前的年、月、日、时、分、秒<br>    &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）</p>
<p>3.java.sql.Date对应着数据库中的日期类型的变量<br>    &gt;如何实例化<br>    &gt;如何将java.util.Date对象转换为java.sql.Date对象</p>
<p>3.java. text .SimpleDataFormat类<br>4.Calendar类</p>
<h2 id="5-8-课后算法题目"><a href="#5-8-课后算法题目" class="headerlink" title="5-8 课后算法题目"></a>5-8 课后算法题目</h2><p>11111111111111</p>
<p>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_06.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_07.png" alt="StringBuffer中的常用方法"></p>
<p>方式二</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_09.png" alt="StringBuffer中的常用方法"></p>
<p>方式三:</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_10.png" alt="StringBuffer中的常用方法"></p>
<p>111111111111111</p>
<p>2222222</p>
<p>.获取一个字符串在另-一个字符串中出现的次数。<br>比如:获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_11.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_12.png" alt="改进"></p>
<p>2222222</p>
<p>33333333</p>
<p>4.获取两个字符串中最大相同子串。比如:<br>str1 = “abcwerthelloyuiodef;str2 = “cvhellobnm’<br>提示:将短的那个串进行长度依次递减的子串与较长的串比较。</p>
<p>前提是:两个字符串中只有一个最大相同子串</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_13.png" alt="改进"></p>
<p>多个定义arraylist</p>
<pre><code>// 如果存在多个长度相同的最大相同子串
// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便
public String[] getMaxSameSubString1(String str1, String str2) {
    if (str1 != null &amp;&amp; str2 != null) {
        StringBuffer sBuffer = new StringBuffer();
        String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;
        String minString = (str1.length() &gt; str2.length()) ? str2 : str1;

        int len = minString.length();
        for (int i = 0; i &lt; len; i++) {
            for (int x = 0, y = len - i; y &lt;= len; x++, y++) {
                String subString = minString.substring(x, y);
                if (maxString.contains(subString)) {
                    sBuffer.append(subString + ",");
                }
            }
            System.out.println(sBuffer);
            if (sBuffer.length() != 0) {
                break;
            }
        }
        String[] split = sBuffer.toString().replaceAll(",$", "").split("\\,");
        return split;
    }

    return null;
}</code></pre><p>33333333</p>
<h2 id="9-IDEA中Debug的调试"><a href="#9-IDEA中Debug的调试" class="headerlink" title="9.IDEA中Debug的调试"></a>9.IDEA中Debug的调试</h2><p>逻辑能力</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_14.png" alt="改进">  长度 </p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_15.png" alt="面试题"></p>
<h2 id="10-simpleDateFormat的使用"><a href="#10-simpleDateFormat的使用" class="headerlink" title="10.simpleDateFormat的使用"></a>10.simpleDateFormat的使用</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_16.png" alt="面试题"></p>
<p>1.两个操作：<br>    1.1 格式化：日期 —&gt;字符串<br>    1.2 解析：格式化的逆过程，字符串 —&gt; 日期</p>
<p>2.SimpleDateFormat的实例化</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_17.png" alt="SimpleDateFormat"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_18.png" alt="##SimpleDateFormat"></p>
<h2 id="11-12-SimpleDateFormat的课后练习1-2"><a href="#11-12-SimpleDateFormat的课后练习1-2" class="headerlink" title="11-12.SimpleDateFormat的课后练习1-2"></a>11-12.SimpleDateFormat的课后练习1-2</h2><p>练习一：字符串”2020-09-08”转换为java.sql.Date</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   String birth = <span class="string">"2020-09-08"</span>;</span><br><span class="line">  SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">  Date date = sdf1.parse(birth);</span><br><span class="line"><span class="comment">// System.out.println(date);</span></span><br><span class="line">java.sql.Date birthDate = <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">System.out.println(birthDate);</span><br></pre></td></tr></tbody></table></figure>

<p>练习二：”三天打渔两天晒网”   1990-01-01  xxxx-xx-xx 打渔？晒网？<br>    举例：2020-09-08 ？ 总天数</p>
<pre><code>总天数 % 5 == 1,2,3 : 打渔
总天数 % 5 == 4,0 : 晒网

总天数的计算？
方式一：( date2.getTime() - date1.getTime()) / (1000606024) + 1（小数）=...天
方式二：1990-01-01  --&gt; 2019-12-31  +  2020-01-01 --&gt;2020-09-08</code></pre><h2 id="13-Calendar日历类的使用"><a href="#13-Calendar日历类的使用" class="headerlink" title="13.Calendar日历类的使用"></a>13.Calendar日历类的使用</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_19.png" alt="##SimpleDateFormat"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_20" alt="calendar的使用"></p>
<h2 id="14-JDK8中新日期时间API的介绍"><a href="#14-JDK8中新日期时间API的介绍" class="headerlink" title="14.JDK8中新日期时间API的介绍"></a>14.JDK8中新日期时间API的介绍</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_21.png" alt="calendar的使用"></p>
<h3 id="9-3-JDK8中新日期时间API"><a href="#9-3-JDK8中新日期时间API" class="headerlink" title="9.3 JDK8中新日期时间API"></a>9.3 JDK8中新日期时间API</h3><p>LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter、其他类</p>
<p>偏移性:<img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_22.png" alt="calendar的使用"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_23.png" alt="calendar的使用"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_24.png" alt="calendar的使用"></p>
<h2 id="15-LocalDate、LocalTime、LocalDateTime的使用"><a href="#15-LocalDate、LocalTime、LocalDateTime的使用" class="headerlink" title="15.LocalDate、LocalTime、LocalDateTime的使用"></a>15.LocalDate、LocalTime、LocalDateTime的使用</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_25.png" alt="calendar的使用"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_26.png" alt="calendar的使用"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_27.png" alt="calendar的使用"></p>
<p>说明：<br>        1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高<br>        2.类似于Calendar</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_28" alt=".LocalDateTime、LocalDate、LocalTime的使用"></p>
<h2 id="16-Instant类的使用-date"><a href="#16-Instant类的使用-date" class="headerlink" title="16.Instant类的使用 ==date"></a>16.Instant类的使用 ==date</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_29.png" alt="Instant"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_30.png" alt="Instant"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_31.png" alt="Instant"></p>
<h2 id="17-Date-TimeFormatter的使用"><a href="#17-Date-TimeFormatter的使用" class="headerlink" title="17.Date TimeFormatter的使用"></a>17.Date TimeFormatter的使用</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_32.png" alt="Instant"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_33" alt="1588165071299"></p>
<h2 id="18-其他日期时间相关的API的使用"><a href="#18-其他日期时间相关的API的使用" class="headerlink" title="18.其他日期时间相关的API的使用"></a>18.其他日期时间相关的API的使用</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_34.png" alt="1588165071299"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_35" alt="1588165384561"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_36.png" alt="1588165384561"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_37" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_38.png" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_39.png" alt="1588165488963"></p>
<h2 id="19-导入module-模块"><a href="#19-导入module-模块" class="headerlink" title="19.导入module 模块"></a>19.导入module 模块</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_40" alt="1588165711475"></p>
<h2 id="20-java比较器的概述"><a href="#20-java比较器的概述" class="headerlink" title="20.java比较器的概述"></a>20.java比较器的概述</h2><h3 id="9-4-Java-比较器"><a href="#9-4-Java-比较器" class="headerlink" title="9.4 Java 比较器"></a>9.4 Java 比较器</h3><ul>
<li>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。</li>
<li>Java实现对象排序的方式有两种:<br>➢自然排序: java.lang.Comparable<br>➢定制排序: java.util.Comparator</li>
</ul>
<p>一、说明：Java中的对象，正常情况下，只能进行比较：==  或  != 。不能使用 &gt; 或 &lt; 的<br>       但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。<br>         如何实现？使用两个接口中的任何一个：Comparable 或 Comparator<br>二、Comparable接口与Comparator的使用的对比：<br>   Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。(一劳永逸)<br>   Comparator接口属于临时性的比较。(临时工)</p>
<h2 id="21-Comparable-自然排序举例"><a href="#21-Comparable-自然排序举例" class="headerlink" title="21.Comparable 自然排序举例:"></a>21.Comparable 自然排序举例:</h2><pre><code>Comparable接口的使用举例：  自然排序</code></pre><p>1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。<br>2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列</p>
<p>3.重写compareTo(obj)的规则：<br>        如果当前对象this大于形参对象obj，则返回正整数，<br>        如果当前对象this小于形参对象obj，则返回负整数，<br>        如果当前对象this等于形参对象obj，则返回零。<br>4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。<br>       在compareTo(obj)方法中指明如何排序<br><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_41.png" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_42.png" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_43.png" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_44.png" alt="1588165488963"></p>
<h2 id="22-自定义类实现Comparable自然排序"><a href="#22-自定义类实现Comparable自然排序" class="headerlink" title="22.自定义类实现Comparable自然排序"></a>22.自定义类实现Comparable自然排序</h2><p>public class Goods. implements  Comparable{</p>
<p>}</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_45.png" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_46.png" alt="1588165488963"></p>
<p>当价格相同时,按书名排序</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_47.png" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_48.png" alt="1588165488963"></p>
<h2 id="23-使用Comparator实现定制排序"><a href="#23-使用Comparator实现定制排序" class="headerlink" title="23.使用Comparator实现定制排序"></a>23.使用Comparator实现定制排序</h2><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_49.png" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_50.png" alt="1588165488963"></p>
<p>  Comparator接口的使用：定制排序<br>    1.背景：<br>    当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，<br>    或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，<br>    那么可以考虑使用 Comparator 的对象来排序<br>    2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：<br>    如果方法返回正整数，则表示o1大于o2；<br>    如果返回0，表示相等；<br>    返回负整数，表示o1小于o2。</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_51.png" alt="1588165488963"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_52.png" alt="1588165488963"></p>
<p>sout(Arrays.toString(arr));</p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_53.png" alt="商品的定制"></p>
<p>用哪一种都可以</p>
<h2 id="24-System、Math、BigInteger、BigDecimal的使用"><a href="#24-System、Math、BigInteger、BigDecimal的使用" class="headerlink" title="24.System、Math、BigInteger、BigDecimal的使用"></a>24.System、Math、BigInteger、BigDecimal的使用</h2><h3 id="9-5-System类"><a href="#9-5-System类" class="headerlink" title="9.5 System类"></a>9.5 System类</h3><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_54.png" alt="System类"><br><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_55.png" alt="System类"><br><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_56.png" alt="System类"></p>
<h3 id="9-6-Math类"><a href="#9-6-Math类" class="headerlink" title="9.6 Math类"></a>9.6 Math类</h3><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_57.png" alt="Math类"></p>
<h3 id="9-7-BigInteger和BigDecimal"><a href="#9-7-BigInteger和BigDecimal" class="headerlink" title="9.7 BigInteger和BigDecimal"></a>9.7 BigInteger和BigDecimal</h3><p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_58.png" alt="Math类"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_59.png" alt="Math类"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_60.png" alt="BigDecimal类"></p>
<p><img src="/2017/07/04/2016-07-04-chang-yong-lei-date/21_61.png" alt="BigDecimal类"></p>
<p>//  报错   由于没有除尽</p>
<p>支持任意精度的小数位</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>常用类</tag>
      </tags>
  </entry>
  <entry>
    <title>常用类String</title>
    <url>/2017/07/02/2016-07-02-chang-yong-lei-string/</url>
    <content><![CDATA[<p>Java高级编程   使用层面</p>
<p>理解是可以长久保存的，别死记硬背</p>
<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>1.画图说明线程的生命周期，以及各状态切换使用到的方法等，<br>五种状态     状态转换   方法<br>2.同步代码块中涉及到<code>同步监视器</code>和<code>共享数据</code>，谈谈你对同步监视器和共享数据的理解，以及注意点。<br>synchronized（同步监视器)<br>/操作共享数据的代码(不能包括多了，也不能包括少了)<br>}</p>
<p>把握核心的东西<br>3.sleep()和wait()的区别。<br>4.写一个线程安全的懒汉式<br>需要会手写<br>5.创建多线程有哪几种方式。<br>继承Thread类<br>实现Runnable接口<br>实现Cllable接口。<br>线程池  （响应速度提高了，提高了资源的重用率，便于管理)</p>
<h2 id="2-生命周期与同步机制"><a href="#2-生命周期与同步机制" class="headerlink" title="2.生命周期与同步机制"></a>2.生命周期与同步机制</h2><p>图示:<br><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_01.png" alt="线程的声明周期"><br>说明:<br>1.生命周期关注两个概念:状态、相应的方法<br>2.关注:状态a–&gt;状态b:哪些方法执行了(回调方法)<br>某个方法主动调用:状态a–&gt;状态b ;<br>3.阻塞:临时状态，不可以作为最终状态<br>死亡:最终状态。|</p>
<h4 id="线程的同步机制"><a href="#线程的同步机制" class="headerlink" title="线程的同步机制"></a>线程的同步机制</h4><p>1.背景<br>火车票卖票</p>
<p>2.Java解决方案: 同步机制</p>
<p> 方式一：同步代码块<br>  synchronized(同步监视器){<br>     //需要被同步的代码<br>  }<br> 说明：1.操作共享数据的代码，即为需要被同步的代码。  –&gt;不能包含代码多了，也不能包含代码少了。<br>      2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。<br>      3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。任意<br>         要求：多个线程必须要共用同一把锁。<br>  补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</p>
<p>   在继承Thread类创建多线程的方式中，慎用this 充当同步监视器，考虑使用当前类充当同步监视器。   </p>
<p><strong>方式二：同步方法。</strong><br>    如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<p>解决线程安全问题的方式三：Lock锁  — JDK5.0新增<br> *</p>
<ol>
<li>面试题：synchronized 与 Lock的异同？<br>相同：二者都可以解决线程安全问题<br>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器<br>Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）</li>
</ol>
<p>关于同步方法的总结：</p>
<ol>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法，同步监视器是：this静态的同步方法，同步监视器是：当前类本身</li>
</ol>
<p>理解下，自己把它写一下</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_02.png" alt="线程的声明周期"></p>
<p>Lock -&gt; 同步代码块（已经进入了方法体，分配了相应资源） -&gt;同步方法（在方法体之外）</p>
<p>3.利弊</p>
<p>同步的方式，解决了线程的安全问题。—好处<br>   操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 —局限性</p>
<p>4.<br>面试题: Java是如何解决线程安全问题的，有几种方式?并对比几种方式的不同</p>
<p>面试题：synchronized 与 Lock的异同？<br>相同：二者都可以解决线程安全问题<br>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器<br>Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）</p>
<p>面试题: synchronized和Lock方 式解决线程安全问题的对比</p>
<p>异步  喊你吃饭，他走了，你也走了，他在你前面</p>
<p>##3.线程通信和新的线程创建方式</p>
<p>使用同步机制将单例模式中的懒汉式改写为线程安全的。</p>
<p>懒汉式:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同步机制将单例模式中的懒汉式改写为线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) {</span></span><br><span class="line"><span class="comment">//            if(instance == null){</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            }</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (Bank<span class="class">.<span class="keyword">class</span>) </span>{</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>){</span><br><span class="line"></span><br><span class="line">                    instance = <span class="keyword">new</span> Bank();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>面试题::写一个线程安全的单例模式</p>
<p>饿汉式</p>
<p>懒汉式 写上面优化的</p>
<p>死锁:</p>
<p>1.死锁的理解:<br>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁<br>2.说明:</p>
<p>1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续<br>2）我们使用同步时，要避免出现死锁。</p>
<p>3.举例:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        StringBuffer s2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s1){</span><br><span class="line">                    s1.append(<span class="string">"a"</span>);</span><br><span class="line">                    s2.append(<span class="string">"1"</span>);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (s2){</span><br><span class="line">                        s1.append(<span class="string">"b"</span>);</span><br><span class="line">                        s2.append(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">synchronized</span> (s2){</span><br><span class="line"></span><br><span class="line">                    s1.append(<span class="string">"c"</span>);</span><br><span class="line">                    s2.append(<span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">synchronized</span> (s1){</span><br><span class="line">                        s1.append(<span class="string">"d"</span>);</span><br><span class="line">                        s2.append(<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">                        System.out.println(s1);</span><br><span class="line">                        System.out.println(s2);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h4 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h4><p>1.线程通信涉及到的三个方法:</p>
<p>两个线程之间并行  有交流</p>
<p>例题: 使用两个线程打印1-100。线程1,线程2交替打印</p>
<p>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。<br>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。<br>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</p>
<p>2.说明:</p>
<ul>
<li>1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。<br>2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常  外面生成一个object 要是同一把锁 </li>
<li><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/..%5CstudyNote_Pic%5Csgg%5Cday19%5C19_26.png" alt="制造 加sleep 死锁的问题"></li>
<li>3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</li>
</ul>
<p>3.面试题</p>
<p>面试题：sleep() 和 wait()的异同？<br>1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>2.不同点：</p>
<ul>
<li>1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li>
<li>2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li>
<li>3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li>
</ul>
<p>4.<br>小结释放锁的操作:</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_03.png" alt="释放锁的操作"></p>
<p>小结不会释放锁的操作:</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_04.png" alt="释放锁的操作"></p>
<h4 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h4><p>新增方式一:实现Callable接口</p>
<p>说明:</p>
<p>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</p>
<ol>
<li>call()可以有返回值的。</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的</li>
</ol>
<p>新增方式二:使用线程池<br>说明:</p>
<p>好处:<br>提高响应速度(减少了创建新线程的时间)<br>降低资源消耗(重复利用线程池中线程，不需要每次都创建)<br>便于线程管理<br>V corePoolSize: 核心池的大小<br>V maximumPoolSize: 最大线程数<br>VkeepAliveTime:线程没有任务时最多保持多长时间后会终止</p>
<p>面试题: Java中 多线程的创建有几种方式?四种</p>
<p>创建线程的两种方式（继承Thread类，实现Runnable接口 ）+新特性</p>
<h2 id="4-Java常用类的概述"><a href="#4-Java常用类的概述" class="headerlink" title="4.Java常用类的概述"></a>4.Java常用类的概述</h2><h2 id="5-String类的概述"><a href="#5-String类的概述" class="headerlink" title="5.String类的概述"></a>5.String类的概述</h2><h2 id="6-理解String-不可变性"><a href="#6-理解String-不可变性" class="headerlink" title="6.理解String 不可变性"></a>6.理解String 不可变性</h2><h3 id="9-1-字符串相关的类"><a href="#9-1-字符串相关的类" class="headerlink" title="9.1 字符串相关的类"></a>9.1 字符串相关的类</h3><p>String类及常用方法和StringBuffer、StringBuilder    数组实现</p>
<h4 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h4><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_05.png" alt="String的特性"></p>
<ul>
<li>String:字符串，使用一对””引起来表示。<ul>
<li>1.String声明为final的，不可被继承</li>
<li>2.String实现了Serializable接口：表示字符串是支持序列化的。<pre><code>实现了Comparable接口：表示String可以比较大     </code></pre></li>
<li>3.String内部定义了final char[] value用于存储字符串数据</li>
<li>4.String:代表不可变的字符序列。简称：不可变性。<pre><code>体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
     2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
              3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</code></pre></li>
<li>5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li>
<li>6.字符串常量池中是不会存储相同内容的字符串的。<br><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_06.png" alt="String的特性"></li>
</ul>
</li>
</ul>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_07.png" alt="String的特性"></p>
<h2 id="7-不同实例化方式的对比"><a href="#7-不同实例化方式的对比" class="headerlink" title="7.不同实例化方式的对比"></a>7.不同实例化方式的对比</h2><p>s5=s4.replace(‘a’,’m’);</p>
<p>String 对象的创建</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_08.png" alt="String的特性"></p>
<p>第一种在常量池种</p>
<p>第二种 在堆种</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_09.png" alt="String的特性"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_10.png" alt="String实例化方式"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_11.png" alt="String的特性"></p>
<p>面试题: string s = new String(“abc”);方式创建对象，在内存中创建了几个对象?<br>两个:一个是堆空间中new结构，另一个是char[ ]对应的常量池中的数据: “abc “</p>
<h2 id="8-String-不同拼接操作的对比"><a href="#8-String-不同拼接操作的对比" class="headerlink" title="8.String 不同拼接操作的对比"></a>8.String 不同拼接操作的对比</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_12.png" alt="String的特性"></p>
<p>通过变量名参与，此时均不在常量池，需要在堆空间开辟</p>
<p>说明:</p>
<p>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。<br>只要其中有一个是变量，结果就在堆中</p>
<p>String s8=s5.intern();</p>
<p>sout(s3==s8)；   s8使用了常量值种已经存在的数据</p>
<p>如果拼接的结果调用intern()方法，返回值就在常量池中</p>
<h2 id="9-String的一道面试题"><a href="#9-String的一道面试题" class="headerlink" title="9.String的一道面试题"></a>9.String的一道面试题</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_13.png" alt="String的特性"></p>
<p>String  不可变</p>
<h2 id="10-JVM中设计字符串的内存结构"><a href="#10-JVM中设计字符串的内存结构" class="headerlink" title="10.JVM中设计字符串的内存结构"></a>10.JVM中设计字符串的内存结构</h2><p>jvm 7 字符串方法区在堆种     jvm8在元空间(永久区)</p>
<h2 id="11-String-的常用方法1-3"><a href="#11-String-的常用方法1-3" class="headerlink" title="11. String 的常用方法1-3"></a>11. String 的常用方法1-3</h2><p>明确做啥</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_14.png" alt="String 的常用方法1"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_15.png" alt="String 的常用方法2"></p>
<p>//什么情况下，index0f(str) 和astIndex0f(str)返回值相同?<br>//情况一:存在唯一的一个str.<br>。情况二:不存在str</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_16.png" alt="String 的常用方法3"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_17.png" alt="String 的常用方法3"></p>
<p>数据库是从1开始</p>
<p>正则表达式</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_18.png" alt="String 的常用方法3"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_19.png" alt="String 的常用方法3"></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">String s1="123hello456world789";                        //开头有,或者结尾有逗号  | 或者String s2 = s1.replaceAll("\\d+", ",").replaceAll("^,|,$", "");System.out.println(s2);</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_20.png" alt="String 的常用方法3"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_21.png" alt="String 的常用方法切割"></p>
<h2 id="14-String与基本数据类型包装类的转换"><a href="#14-String与基本数据类型包装类的转换" class="headerlink" title="14.String与基本数据类型包装类的转换"></a>14.String与基本数据类型包装类的转换</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_22.png" alt="String 的常用方法切割"></p>
<p>String str1=”123”</p>
<p>int num=Integer.parseInt(str1)</p>
<hr>
<p>String.valueOf(num);</p>
<p>或者   num+””      .concat</p>
<h2 id="15-String与char-之间的转换"><a href="#15-String与char-之间的转换" class="headerlink" title="15.String与char[]之间的转换"></a>15.String与char[]之间的转换</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_23.png" alt="String 的常用方法切割"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_26.png" alt="String 的常用方法切割"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_25.png" alt="String 的常用方法切割"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_24.png" alt="String 的常用方法切割"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_27.png" alt="String 的常用方法切割"></p>
<p>  <img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_28.png" alt="String 的常用方法切割"></p>
<p> 编码：String –&gt; byte[]:调用String的getBytes()<br>   解码：byte[] –&gt; String:调用String的构造器</p>
<p>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)<br>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）<br>  说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p>
<h2 id="17-解决一个拼接问题"><a href="#17-解决一个拼接问题" class="headerlink" title="17.解决一个拼接问题"></a>17.解决一个拼接问题</h2><p>  <img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_29.png" alt="String 的常用方法切割"></p>
<h2 id="18-面试中String-算法考查说明"><a href="#18-面试中String-算法考查说明" class="headerlink" title="18.面试中String 算法考查说明"></a>18.面试中String 算法考查说明</h2><p>1.模拟一个trim方法，去除字符串两端的空格。<br>2.将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”<br>3.获取一个字符串在另-一个字符串中出现的次数。<br>比如:获取“ab”在“abkkcadkabkebfkabkskab”中出现的次数<br>4.获取两个字符串中最大相同子串。比如:<br>str1 = “abcwerthelloyuiodef;str2 = “cvhellobnm’<br>提示:将短的那个串进行长度依次递减的子串与较长的串比较。<br>5.对字符串中字符进行自然顺序排序。<br>提示:<br>1)字符串变成字符数组。<br>2)对数组排序，选择，冒泡，Arrays. sort();<br>3)将排序后的数组变成字符串。</p>
<p>自己去想</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.模拟一个trim方法，去除字符串两端的空格。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.将一个字符串进行反转。将字符串中指定部分进行反转。比如将“abcdefg”反转为”abfedcg”</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.获取一个字符串在另一个字符串中出现的次数。</span></span><br><span class="line"><span class="comment">      比如：获取“ab”在 “cdabkkcadkabkebfkabkskab”    </span></span><br><span class="line"><span class="comment">      中出现的次数</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">4.获取两个字符串中最大相同子串。比如：</span></span><br><span class="line"><span class="comment">   str1 = "abcwerthelloyuiodef“;str2 = "cvhellobnm"//10</span></span><br><span class="line"><span class="comment">   提示：将短的那个串进行长度依次递减的子串与较长  </span></span><br><span class="line"><span class="comment">   的串比较。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5.对字符串中字符进行自然顺序排序。"abcwerthelloyuiodef"</span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1）字符串变成字符数组。</span></span><br><span class="line"><span class="comment">2）对数组排序，选择，冒泡，Arrays.sort(str.toCharArray());</span></span><br><span class="line"><span class="comment">3）将排序后的数组变成字符串。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第1题</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">myTrim</span><span class="params">(String str)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (str != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="keyword">int</span> start = <span class="number">0</span>;<span class="comment">// 用于记录从前往后首次索引位置不是空格的位置的索引</span></span><br><span class="line">			<span class="keyword">int</span> end = str.length() - <span class="number">1</span>;<span class="comment">// 用于记录从后往前首次索引位置不是空格的位置的索引</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(start) == <span class="string">' '</span>) {</span><br><span class="line">				start++;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(end) == <span class="string">' '</span>) {</span><br><span class="line">				end--;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span> (str.charAt(start) == <span class="string">' '</span>) {</span><br><span class="line">				<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> str.substring(start, end + <span class="number">1</span>);</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第2题</span></span><br><span class="line">	<span class="comment">// 方式一：</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverse1</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{<span class="comment">// start:2,end:5</span></span><br><span class="line">		<span class="keyword">if</span> (str != <span class="keyword">null</span>) {</span><br><span class="line">			<span class="comment">// 1.</span></span><br><span class="line">			<span class="keyword">char</span>[] charArray = str.toCharArray();</span><br><span class="line">			<span class="comment">// 2.</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) {</span><br><span class="line">				<span class="keyword">char</span> temp = charArray[i];</span><br><span class="line">				charArray[i] = charArray[j];</span><br><span class="line">				charArray[j] = temp;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">// 3.</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String(charArray);</span><br><span class="line"></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方式二：</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverse2</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line">		<span class="comment">// 1.</span></span><br><span class="line">		String newStr = str.substring(<span class="number">0</span>, start);<span class="comment">// ab</span></span><br><span class="line">		<span class="comment">// 2.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) {</span><br><span class="line">			newStr += str.charAt(i);</span><br><span class="line">		} <span class="comment">// abfedc</span></span><br><span class="line">			<span class="comment">// 3.</span></span><br><span class="line">		newStr += str.substring(end + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> newStr;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 方式三：推荐 （相较于方式二做的改进）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverse3</span><span class="params">(String str, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{<span class="comment">// ArrayList list = new ArrayList(80);</span></span><br><span class="line">		<span class="comment">// 1.</span></span><br><span class="line">		StringBuffer s = <span class="keyword">new</span> StringBuffer(str.length());</span><br><span class="line">		<span class="comment">// 2.</span></span><br><span class="line">		s.append(str.substring(<span class="number">0</span>, start));<span class="comment">// ab</span></span><br><span class="line">		<span class="comment">// 3.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= start; i--) {</span><br><span class="line">			s.append(str.charAt(i));</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 4.</span></span><br><span class="line">		s.append(str.substring(end + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 5.</span></span><br><span class="line">		<span class="keyword">return</span> s.toString();</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReverse</span><span class="params">()</span> </span>{</span><br><span class="line">		String str = <span class="string">"abcdefg"</span>;</span><br><span class="line">		String str1 = reverse3(str, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(str1);<span class="comment">// abfedcg</span></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第3题</span></span><br><span class="line">	<span class="comment">// 判断str2在str1中出现的次数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String mainStr, String subStr)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (mainStr.length() &gt;= subStr.length()) {</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// while((index = mainStr.indexOf(subStr)) != -1){</span></span><br><span class="line">			<span class="comment">// count++;</span></span><br><span class="line">			<span class="comment">// mainStr = mainStr.substring(index + subStr.length());</span></span><br><span class="line">			<span class="comment">// }</span></span><br><span class="line">			<span class="comment">// 改进：</span></span><br><span class="line">			<span class="keyword">while</span> ((index = mainStr.indexOf(subStr, index)) != -<span class="number">1</span>) {</span><br><span class="line">				index += subStr.length();</span><br><span class="line">				count++;</span><br><span class="line">			}</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		} <span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetCount</span><span class="params">()</span> </span>{</span><br><span class="line">		String str1 = <span class="string">"cdabkkcadkabkebfkabkskab"</span>;</span><br><span class="line">		String str2 = <span class="string">"ab"</span>;</span><br><span class="line">		<span class="keyword">int</span> count = getCount(str1, str2);</span><br><span class="line">		System.out.println(count);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyTrim</span><span class="params">()</span> </span>{</span><br><span class="line">		String str = <span class="string">"   a   "</span>;</span><br><span class="line">		<span class="comment">// str = " ";</span></span><br><span class="line">		String newStr = myTrim(str);</span><br><span class="line">		System.out.println(<span class="string">"---"</span> + newStr + <span class="string">"---"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第4题</span></span><br><span class="line">	<span class="comment">// 如果只存在一个最大长度的相同子串</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMaxSameSubString</span><span class="params">(String str1, String str2)</span> </span>{</span><br><span class="line">		<span class="keyword">if</span> (str1 != <span class="keyword">null</span> &amp;&amp; str2 != <span class="keyword">null</span>) {</span><br><span class="line">			String maxStr = (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">			String minStr = (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> len = minStr.length();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {<span class="comment">// 0 1 2 3 4 此层循环决定要去几个字符</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) {</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> (maxStr.contains(minStr.substring(x, y))) {</span><br><span class="line"></span><br><span class="line">						<span class="keyword">return</span> minStr.substring(x, y);</span><br><span class="line">					}</span><br><span class="line"></span><br><span class="line">				}</span><br><span class="line"></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果存在多个长度相同的最大相同子串</span></span><br><span class="line">	<span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line">	<span class="keyword">public</span> String[] getMaxSameSubString1(String str1, String str2) {</span><br><span class="line">		<span class="keyword">if</span> (str1 != <span class="keyword">null</span> &amp;&amp; str2 != <span class="keyword">null</span>) {</span><br><span class="line">			StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">			String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">			String minString = (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> len = minString.length();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) {</span><br><span class="line">					String subString = minString.substring(x, y);</span><br><span class="line">					<span class="keyword">if</span> (maxString.contains(subString)) {</span><br><span class="line">						sBuffer.append(subString + <span class="string">","</span>);</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">				System.out.println(sBuffer);</span><br><span class="line">				<span class="keyword">if</span> (sBuffer.length() != <span class="number">0</span>) {</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			String[] split = sBuffer.toString().replaceAll(<span class="string">",$"</span>, <span class="string">""</span>).split(<span class="string">"\\,"</span>);</span><br><span class="line">			<span class="keyword">return</span> split;</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 如果存在多个长度相同的最大相同子串：使用ArrayList</span></span><br><span class="line"><span class="comment">//	public List&lt;String&gt; getMaxSameSubString1(String str1, String str2) {</span></span><br><span class="line"><span class="comment">//		if (str1 != null &amp;&amp; str2 != null) {</span></span><br><span class="line"><span class="comment">//			List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span></span><br><span class="line"><span class="comment">//			String maxString = (str1.length() &gt; str2.length()) ? str1 : str2;</span></span><br><span class="line"><span class="comment">//			String minString = (str1.length() &gt; str2.length()) ? str2 : str1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			int len = minString.length();</span></span><br><span class="line"><span class="comment">//			for (int i = 0; i &lt; len; i++) {</span></span><br><span class="line"><span class="comment">//				for (int x = 0, y = len - i; y &lt;= len; x++, y++) {</span></span><br><span class="line"><span class="comment">//					String subString = minString.substring(x, y);</span></span><br><span class="line"><span class="comment">//					if (maxString.contains(subString)) {</span></span><br><span class="line"><span class="comment">//						list.add(subString);</span></span><br><span class="line"><span class="comment">//					}</span></span><br><span class="line"><span class="comment">//				}</span></span><br><span class="line"><span class="comment">//				if (list.size() != 0) {</span></span><br><span class="line"><span class="comment">//					break;</span></span><br><span class="line"><span class="comment">//				}</span></span><br><span class="line"><span class="comment">//			}</span></span><br><span class="line"><span class="comment">//			return list;</span></span><br><span class="line"><span class="comment">//		}</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		return null;</span></span><br><span class="line"><span class="comment">//	}</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetMaxSameSubString</span><span class="params">()</span> </span>{</span><br><span class="line">		String str1 = <span class="string">"abcwerthelloyuiodef"</span>;</span><br><span class="line">		String str2 = <span class="string">"cvhellobnmiodef"</span>;</span><br><span class="line">		String[] strs = getMaxSameSubString1(str1, str2);</span><br><span class="line">		System.out.println(Arrays.toString(strs));</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第5题</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSort</span><span class="params">()</span> </span>{</span><br><span class="line">		String str = <span class="string">"abcwerthelloyuiodef"</span>;</span><br><span class="line">		<span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">		Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">		String newStr = <span class="keyword">new</span> String(arr);</span><br><span class="line">		System.out.println(newStr);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="19-StringBuffer和StringBuilder的介绍"><a href="#19-StringBuffer和StringBuilder的介绍" class="headerlink" title="19.StringBuffer和StringBuilder的介绍"></a>19.StringBuffer和StringBuilder的介绍</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_30.png" alt="String 的常用方法切割"></p>
<p>   String、StringBuffer、StringBuilder三者的异同？<br>    String:不可变的字符序列；底层使用char[]存储<br>    StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储<br>    StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_31.png" alt="String 的常用方法切割"></p>
<p>原字符上变</p>
<h2 id="20-StringBuffer的源码分析"><a href="#20-StringBuffer的源码分析" class="headerlink" title="20.StringBuffer的源码分析"></a>20.StringBuffer的源码分析</h2><p>  源码分析：<br>    String str = new String();//char[] value = new char[0];   length=0</p>
<p>​    String str1 = new String(“abc”);//char[] value = new char[]{‘a’,’b’,’c’};<br>​    StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。<br>​    System.out.println(sb1.length());//<br>​    sb1.append(‘a’);//value[0] = ‘a’;<br>​    sb1.append(‘b’);//value[1] = ‘b’;</p>
<p>​    StringBuffer sb2 = new StringBuffer(“abc”);//char[] value = new char[“abc”.length() + 16];</p>
<p>问题1. System.out.println(sb2.length());//3<br>    //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。<br>     默认情况下，扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。<br>     指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)<br>vlane&lt;&lt;1  == *2  append 多少次</p>
<h2 id="21-StringBuffer中的常用方法"><a href="#21-StringBuffer中的常用方法" class="headerlink" title="21.StringBuffer中的常用方法"></a>21.StringBuffer中的常用方法</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_32.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_33.png" alt="StringBuffer中的常用方法"></p>
<p>substring 需要返回值</p>
<p>setCharAt 指定字符改成新的</p>
<p>总结: 增删改查 插 长度 遍历</p>
<p>总结：<br>        增：append(xxx)<br>        删：delete(int start,int end)<br>        改：setCharAt(int n ,char ch) / replace(int start, int end, String str)<br>        查：charAt(int n )<br>        插：insert(int offset, xxx)<br>        长度：length();<br>        *遍历：for() + charAt() / toString()</p>
<h2 id="22-对比String、StringBuffer、StringBuilder三者的效率"><a href="#22-对比String、StringBuffer、StringBuilder三者的效率" class="headerlink" title="22.对比String、StringBuffer、StringBuilder三者的效率"></a>22.对比String、StringBuffer、StringBuilder三者的效率</h2><p>   从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   对比String、StringBuffer、StringBuilder三者的效率：</span></span><br><span class="line"><span class="comment">   从高到低排列：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line">       <span class="comment">//初始设置</span></span><br><span class="line">       <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">       <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">       String text = <span class="string">""</span>;</span><br><span class="line">       StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">       StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">       <span class="comment">//开始对比</span></span><br><span class="line">       startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) {</span><br><span class="line">           buffer.append(String.valueOf(i));</span><br><span class="line">       }</span><br><span class="line">       endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">"StringBuffer的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">       startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) {</span><br><span class="line">           builder.append(String.valueOf(i));</span><br><span class="line">       }</span><br><span class="line">       endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">"StringBuilder的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">       startTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) {</span><br><span class="line">           text = text + i;</span><br><span class="line">       }</span><br><span class="line">       endTime = System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">"String的执行时间："</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure>



<h3 id="9-2-JDK8之前的日期时间API"><a href="#9-2-JDK8之前的日期时间API" class="headerlink" title="9.2 JDK8之前的日期时间API"></a>9.2 JDK8之前的日期时间API</h3><p>System静态方法、Date类、Calender类、SimpleDateFormat类</p>
<h2 id="23-System类中获取时间戳的方法"><a href="#23-System类中获取时间戳的方法" class="headerlink" title="23.System类中获取时间戳的方法"></a>23.System类中获取时间戳的方法</h2><p> <img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_34.png" alt="StringBuffer中的常用方法"></p>
<p> <img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_35.png" alt="StringBuffer中的常用方法"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1.System类中的currentTimeMillis()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line">    <span class="comment">//称为时间戳</span></span><br><span class="line">    System.out.println(time);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="24-Java中两个Date类的使用"><a href="#24-Java中两个Date类的使用" class="headerlink" title="24.Java中两个Date类的使用"></a>24.Java中两个Date类的使用</h2><p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_36.png" alt="StringBuffer中的常用方法"></p>
<p> java.util.Date类<br>        |—java.sql.Date类</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.两个构造器的使用</span><br><span class="line">    &gt;构造器一：Date()：创建一个对应当前时间的Date对象</span><br><span class="line">    &gt;构造器二：创建指定毫秒数的Date对象</span><br><span class="line">2.两个方法的使用</span><br><span class="line">    &gt;toString():显示当前的年、月、日、时、分、秒</span><br><span class="line">    &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）</span><br><span class="line"></span><br><span class="line">3.java.sql.Date对应着数据库中的日期类型的变量</span><br><span class="line">    &gt;如何实例化</span><br><span class="line">    &gt;如何将java.util.Date对象转换为java.sql.Date对象</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_37.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_38.png" alt="StringBuffer中的常用方法"></p>
<p>情况一</p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_40.png" alt="StringBuffer中的常用方法"></p>
<p><img src="/2017/07/02/2016-07-02-chang-yong-lei-string/20_41.png" alt="StringBuffer中的常用方法"></p>
<h3 id="9-3-JDK8中新日期时间API"><a href="#9-3-JDK8中新日期时间API" class="headerlink" title="9.3 JDK8中新日期时间API"></a>9.3 JDK8中新日期时间API</h3><p>LocalDate、LocalTime、LocalDateTime、Instant、DateTimeFormatter、其他类</p>
<h3 id="9-4-Java-比较器"><a href="#9-4-Java-比较器" class="headerlink" title="9.4 Java 比较器"></a>9.4 Java 比较器</h3><p>Comparable接口<br>Comparator接口</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>常用类</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程（补1）多</title>
    <url>/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><ul>
<li>1.谈谈你对程序、进程、线程的理解。</li>
</ul>
<p>说出来  </p>
<p>程序:为完成特定任务、用某种语言编写的一组指令的集合</p>
<p>进程:正在运行的程序</p>
<p>线程:程序内部一条执行路径</p>
<ul>
<li>2.代码完成继承Thread的方式创建分线程，并遍历100以内的自然数.</li>
<li>3.代码完成实现Runnable接口的方法创建分线程，并遍历100以内的自然数</li>
<li>4.对比两种创建方式<br>开发中如何选择<br>什么时候用这些  他们有啥不同呀</li>
<li>5.说说你对IDEA中Project 和Module的理解。<h2 id="2-IDEA的使用和多线程的概念"><a href="#2-IDEA的使用和多线程的概念" class="headerlink" title="2.IDEA的使用和多线程的概念"></a>2.IDEA的使用和多线程的概念</h2></li>
</ul>
<p>01.程序(programm)<br>概念: 是为完成持定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。|</p>
<p>02.进程(process)<br>概念:程序的一次执行过程,或是<code>正在运行的一个程序</code>。</p>
<p>说明:<code>进程作为资源分配的单位</code>，系统在运行时会为每个进程分配不同的内存区域</p>
<ol start="3">
<li>线程(thread)<br>概念:进程可进一步细化为线程,是一-个程序内部的一一条执行路径。</li>
</ol>
<p>说明:<br>线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc),线程切换的开销小</p>
<p>01.单核CPU与多核CPU的理解</p>
<p>02.并行与并发的理解<br>并行:多个CPU同时执行多个任务。比如:多个人同时做不同的事。<br>并发:一个CPU(采用时间片)同时执行多个任务。比如:秒杀、多个人做同一件事</p>
<h2 id="3-线程的创建与常用方法"><a href="#3-线程的创建与常用方法" class="headerlink" title="3.线程的创建与常用方法"></a>3.线程的创建与常用方法</h2><p>方式一:继承Thread类的方式:<br>1.创建一个继承于Thread类的子类<br>2.重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中<br>3.创建Thread类的子类的对象<br>4.通过此对象调用start()<br>说明两个问题:<br>①启动当前线程 ②调用当前线程的run()</p>
<p>问题一:我们启动一个线程，必须调用start(), 不能调用run()的方式启动线程。<br>问题二:如果再启动-一个线程，必须重新创建一个Thread子类的对象， 调用此对象的start().</p>
<p>方式二:实现Runnable接口的方式:<br>1.创建一个实现了Runnable接口的类<br>2.实现类去实现Runnable中的抽象方法: run()<br>3.创建实现类的对象<br>4.将此对象作为参数传递到Thread类的构造器中， 创建Thread类的对象<br>5.通过Thread类的对象调用start()</p>
<p>两种方式的对比:<br>开发中:优先选择:实现Runnable接口的方式<br>原因:<br>1.实现的方式没类的单继承性的局限性<br>2.实现的方式更适合来处理多个线程共享数据的情况。<br>联系: public class Thread implements Runnable<br>相同点:两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。<br>目前两种方式，要想启动线程，都是调用的Thread类中的start()。</p>
<p>Thread类中的常用方法:<br>1.start():启动当前线程;调用当前线程的run()<br>2.run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中<br>3.currentThread(): 静态方法，返回执行当前代码的线程<br>4.getName(): 获取当前线程的名字<br>5.setName(): 设置当前线程的名字<br>6.yield(): 释放当前cpu的执行权<br>7.join(): 在线程a中调用线程b的join(),此时线程a就进入阻塞状态,直到线程b完全执行完以后，线程a才结束阻塞状态。<br>8.stop():已过时。 当执行此方法时，强制结束当前线程。<br>9.sleep(long millitime): 让当前线程“睡眠”指定的millitime毫秒。在指定的millitime 毫秒时间内,当前线程是阻塞状态。<br>10.isAlive():判断当前线程是否存活</p>
<p>线程的优先级:<br>1.<br>MAX_ PRIORITY: 10<br>MIN_ PRIORITY: 1<br>NORM PRIORITY: 5 –&gt;默认优先级<br>2.如何获取和设置当前线程的优先级:<br>getPriority():获取线程的优先级<br>setPriority(int p): 设置线程的优先级<br>说明:高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲,高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p>
<p>线程通信: wait() / notify() / notifyAll() ::此三个方法定义在0bject类中的。</p>
<p>进程可以细化为多个线程，<br>每个线程，拥有自己独立的:栈、程序计数器<br>多个线程，共享同一个进程中的结构:方法区、堆</p>
<p>补充线程分类:<br><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_01.png" alt="线程分类"></p>
<p>主线程  就是用户线程‘</p>
<p>守护线程:gc垃圾回收线程</p>
<p>守护线程依赖主线程</p>
<p>用户线程死了   守护线程就没用了</p>
<p>同步机制</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><h3 id="8-3-线程的生命周期"><a href="#8-3-线程的生命周期" class="headerlink" title="8-3 线程的生命周期"></a>8-3 线程的生命周期</h3><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_02.png" alt="线程分类"></p>
<p>五种状态的转换</p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_03.png" alt="五种状态的转换"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_04.png" alt="五种状态的转换"></p>
<h3 id="8-4-线程的同步-难点-安全"><a href="#8-4-线程的同步-难点-安全" class="headerlink" title="8-4 线程的同步(难点) 安全"></a>8-4 线程的同步(难点) 安全</h3><h2 id="5-理解线程安全问题"><a href="#5-理解线程安全问题" class="headerlink" title="5.理解线程安全问题"></a>5.理解线程安全问题</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_05.png" alt="理解线程安全问题"></p>
<h2 id="6-理解线程安全问题举例和解决措施"><a href="#6-理解线程安全问题举例和解决措施" class="headerlink" title="6..理解线程安全问题举例和解决措施"></a>6..理解线程安全问题举例和解决措施</h2><p>例子：创建三个窗口卖票，总票数为100张.使用实现Runnable接口的方式<br>1.问题：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题<br>2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。<br>3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。   打比方–&gt;厕所<br>4.在Java中，我们通过同步机制，来解决线程的安全问题。</p>
<p> 5.同步的方式，解决了线程的安全问题。—好处<br>   操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 —局限性</p>
<p> 方式一：同步代码块<br>  synchronized(同步监视器){<br>     //需要被同步的代码<br>  }<br> 说明：1.操作共享数据的代码，即为需要被同步的代码。  –&gt;不能包含代码多了，也不能包含代码少了。<br>      2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。<br>      3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。任意<br>         要求：多个线程必须要共用同一把锁。<br>  补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</p>
<h2 id="7-同步代码块处理实现Runnable的线程安全问题"><a href="#7-同步代码块处理实现Runnable的线程安全问题" class="headerlink" title="7.同步代码块处理实现Runnable的线程安全问题"></a>7.同步代码块处理实现Runnable的线程安全问题</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_06.png" alt="理解线程安全问题"></p>
<p>方式二 ：可把obj 改成this </p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_07.png" alt="理解线程安全问题"></p>
<h2 id="8-同步代码块处理继承Thread类的线程安全问题-—注意用同一把锁"><a href="#8-同步代码块处理继承Thread类的线程安全问题-—注意用同一把锁" class="headerlink" title="8.同步代码块处理继承Thread类的线程安全问题 —注意用同一把锁"></a>8.同步代码块处理继承Thread类的线程安全问题 —注意用同一把锁</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_08.png" alt="理解线程安全问题"></p>
<p>上面的不能解决</p>
<p>下图解决   对象加个static 就可以了</p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_09.png" alt="理解线程安全问题"></p>
<p>第二手段  把obj改成Windows2.class，因为Windows2.class只会加载一次</p>
<p>错误this 代表着t1，t2，t3三个对象</p>
<p>补充:在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。</p>
<h2 id="9-同步方法处理实现Runnable的线程安全问题"><a href="#9-同步方法处理实现Runnable的线程安全问题" class="headerlink" title="9. 同步方法处理实现Runnable的线程安全问题."></a>9. 同步方法处理实现Runnable的线程安全问题.</h2><p>方式二：同步方法。<br>    如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_10.png" alt="理解线程安全问题"></p>
<p>同步监视器就是this</p>
<h2 id="10-同步方法处理继承Thread类的线程安全问题"><a href="#10-同步方法处理继承Thread类的线程安全问题" class="headerlink" title="10.同步方法处理继承Thread类的线程安全问题"></a>10.同步方法处理继承Thread类的线程安全问题</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_11.png" alt="理解线程安全问题"></p>
<p>同步方法的总结:</p>
<ol>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法，同步监视器是：this静态的同步方法，同步监视器是：当前类本身</li>
</ol>
<p>理解下，自己把它写一下</p>
<h2 id="11-线程安全的单例模式之懒汉式"><a href="#11-线程安全的单例模式之懒汉式" class="headerlink" title="11.线程安全的单例模式之懒汉式"></a>11.线程安全的单例模式之懒汉式</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_12.png" alt="理解线程安全问题"></p>
<p>问题:</p>
<p>修改如下:</p>
<p>方式一<img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_13.png" alt="理解线程安全问题"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_14.png" alt="理解线程安全问题"></p>
<p>上面的效率差</p>
<p>打比方:  抢苹果手机</p>
<p>效率超高</p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_15.png" alt="理解线程安全问题"></p>
<h2 id="12-死锁的问题"><a href="#12-死锁的问题" class="headerlink" title="12.死锁的问题"></a>12.死锁的问题</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_16.png" alt="死锁的问题"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_17.png" alt="死锁的问题"></p>
<p>}.start();</p>
<p>new Thread（code ).start();</p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_18.png" alt="死锁的问题"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_19.png" alt="制造 加sleep 死锁的问题"></p>
<p>1.死锁的理解：不同的线程分别占用对方需要的同步资源不放弃，<br>都在等待对方放弃自己需要的同步资源，就形成了线程的死锁<br>2.说明：<br>1）出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续<br>2）我们使用同步时，要避免出现死锁。</p>
<p>修改线程名字</p>
<p>Thread.currentThread().setName(“线程名字”)</p>
<h2 id="13-Lock方式解决线程安全问题"><a href="#13-Lock方式解决线程安全问题" class="headerlink" title="13.Lock方式解决线程安全问题"></a>13.Lock方式解决线程安全问题</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_20.png" alt="制造 加sleep 死锁的问题"></p>
<p>解决线程安全问题的方式三：Lock锁  — JDK5.0新增<br> *</p>
<ol>
<li>面试题：synchronized 与 Lock的异同？<br> 相同：二者都可以解决线程安全问题<br> 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器<br> Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）</li>
</ol>
<p>2.使用的优先顺序：    synchronized使用多<br>Lock -&gt; 同步代码块（已经进入了方法体，分配了相应资源） -&gt;同步方法（在方法体之外）</p>
<p>面试题:如何解决线程安全问题?有几种方式</p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_21.png" alt="制造 加sleep 死锁的问题"></p>
<p>公平是先进先出的 括号里面true</p>
<p>默认是false 抢占式</p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_22.png" alt="制造 加sleep 死锁的问题"></p>
<p>2-3之间类似单线程的</p>
<h2 id="14-同步机制的课后练习"><a href="#14-同步机制的课后练习" class="headerlink" title="14.同步机制的课后练习"></a>14.同步机制的课后练习</h2><p>有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。</p>
<pre><code>分析：</code></pre><p> 1.是否是多线程问题？ 是，两个储户线程<br> 2.是否有共享数据？ 有，账户（或账户余额）<br> 3.是否有线程安全问题？有<br> 4.需要考虑如何解决线程安全问题？同步机制：有三种方式。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 银行有一个账户。</span></span><br><span class="line"><span class="comment"> 有两个储户分别向同一个账户存3000元，每次存1000，存3次。每次存完打印账户余额。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment"> 1.是否是多线程问题？ 是，两个储户线程</span></span><br><span class="line"><span class="comment"> 2.是否有共享数据？ 有，账户（或账户余额）</span></span><br><span class="line"><span class="comment"> 3.是否有线程安全问题？有</span></span><br><span class="line"><span class="comment"> 4.需要考虑如何解决线程安全问题？同步机制：有三种方式。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amt)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(amt &gt; <span class="number">0</span>){</span><br><span class="line">            balance += amt;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":存钱成功。余额为："</span> + balance);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">extends</span>  <span class="title">Thread</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account acct;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(Account acct)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.acct = acct;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) {</span><br><span class="line">            acct.deposit(<span class="number">1000</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Account acct = <span class="keyword">new</span> Account(<span class="number">0</span>);</span><br><span class="line">        Customer c1 = <span class="keyword">new</span> Customer(acct);</span><br><span class="line">        Customer c2 = <span class="keyword">new</span> Customer(acct);</span><br><span class="line"></span><br><span class="line">        c1.setName(<span class="string">"甲"</span>);</span><br><span class="line">        c2.setName(<span class="string">"乙"</span>);</span><br><span class="line"></span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>写  extends，lock 要生成静态的，，在这里是使用了this</p>
<h2 id="15-线程通讯的例题"><a href="#15-线程通讯的例题" class="headerlink" title="15.线程通讯的例题"></a>15.线程通讯的例题</h2><h3 id="8-5-线程的通信"><a href="#8-5-线程的通信" class="headerlink" title="8-5 线程的通信"></a>8-5 线程的通信</h3><p>两个线程之间并行  有交流</p>
<p>例题: 使用两个线程打印1-100。线程1,线程2交替打印</p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_23.png" alt="制造 加sleep 死锁的问题"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_24.png" alt="制造 加sleep 死锁的问题"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_25.png" alt="制造 加sleep 死锁的问题"></p>
<p>一旦执行wait  就会释放锁</p>
<ul>
<li><p>涉及到的三个方法：<br>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。<br>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。<br>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</p>
</li>
<li><p>说明：<br>1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。<br>2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常  外面生成一个object 要是同一把锁 </p>
</li>
<li><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_26.png" alt="制造 加sleep 死锁的问题"></p>
</li>
<li><p>3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</p>
<h2 id="16-sleep-和-wait-的异同"><a href="#16-sleep-和-wait-的异同" class="headerlink" title="16.sleep() 和 wait()的异同"></a>16.sleep() 和 wait()的异同</h2></li>
<li><p>面试题：sleep() 和 wait()的异同？<br>1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。<br>2.不同点：</p>
<ul>
<li>1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li>
<li>2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li>
<li>3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li>
</ul>
</li>
</ul>
<h2 id="17-线程通讯-生产消费者例子"><a href="#17-线程通讯-生产消费者例子" class="headerlink" title="17.线程通讯  生产消费者例子"></a>17.线程通讯  生产消费者例子</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_27.png" alt="制造 加sleep 死锁的问题"></p>
<p>线程通信的应用:经典例题:生产者/消费者问题<br>生产者(Productor)将产品交给店员(Clerk),而消费者(Customer)从店员处取走产品，<br>店员一次只能持有固定数量的产品(比如:20)，如果生产者试图生产更多的产品，店员<br>会叫生产者停-下,如果店中有空位放产品了再通知生产者继续生产;如果店中没有产品<br>了,店员会告诉消费者等一下， 如果店中有产品了再通知消费者来取走产品。<br>分析:<br>1.是否是多线程问题?是，生产者线程，消费者线程<br>2.是否有共享数据?是，店员(或产品)<br>3.如何解决线程的安全问题?同步机制,有三种方法<br>4.是否涉及线程的通信?是</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生产产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produceProduct</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(productCount &lt; <span class="number">20</span>){</span><br><span class="line">            productCount++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":开始生产第"</span> + productCount + <span class="string">"个产品"</span>);</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line"></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumeProduct</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(productCount &gt; <span class="number">0</span>){</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":开始消费第"</span> + productCount + <span class="string">"个产品"</span>);</span><br><span class="line">            productCount--;</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{<span class="comment">//生产者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(getName() + <span class="string">":开始生产产品....."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{<span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(getName() + <span class="string">":开始消费产品....."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>){</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTest</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        Producer p1 = <span class="keyword">new</span> Producer(clerk);</span><br><span class="line">        p1.setName(<span class="string">"生产者1"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer c1 = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        c1.setName(<span class="string">"消费者1"</span>);</span><br><span class="line">        Consumer c2 = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        c2.setName(<span class="string">"消费者2"</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="18-创建多线程的方式三-实现Callable接口"><a href="#18-创建多线程的方式三-实现Callable接口" class="headerlink" title="18.创建多线程的方式三:实现Callable接口"></a>18.创建多线程的方式三:实现Callable接口</h2><h3 id="8-6-JDK5-0新增线程创建方式"><a href="#8-6-JDK5-0新增线程创建方式" class="headerlink" title="8-6 JDK5.0新增线程创建方式"></a>8-6 JDK5.0新增线程创建方式</h3><p>真正开发用线程池<br><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_28.png" alt="制造 加sleep 死锁的问题"><br><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_29.png" alt="制造 加sleep 死锁的问题"></p>
<p> <img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_30.png" alt="制造 加sleep 死锁的问题"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_31.png" alt="制造 加sleep 死锁的问题"></p>
<p>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</p>
<ol>
<li>call()可以有返回值的。</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的</li>
</ol>
<h2 id="19-使用线程池的好处"><a href="#19-使用线程池的好处" class="headerlink" title="19.使用线程池的好处"></a>19.使用线程池的好处</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_32.png" alt="线程池"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_33.png" alt="线程池2"></p>
<h3 id="重复利用"><a href="#重复利用" class="headerlink" title="重复利用"></a>重复利用</h3><p>坐车去北京天安门</p>
<h2 id="20-创建多线程的方式四-使用线程池"><a href="#20-创建多线程的方式四-使用线程池" class="headerlink" title="20.创建多线程的方式四:使用线程池"></a>20.创建多线程的方式四:使用线程池</h2><p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_34.png" alt="线程池2"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_35.png" alt="线程池2"></p>
<p><img src="/2017/07/01/2016-07-01-duo-xian-cheng-bu-1-duo/19_36.png" alt="线程池2"></p>
<p>很多时候用框架就实现了</p>
<p>面试题：创建多线程有几种方式？四种！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA学习与多线程</title>
    <url>/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/</url>
    <content><![CDATA[<h2 id="1-java语言高级概述"><a href="#1-java语言高级概述" class="headerlink" title="1.java语言高级概述"></a>1.java语言高级概述</h2><p>完成具体功能该怎么做</p>
<p>集合替换数组</p>
<p>做 具体的事情 </p>
<p>如何使用API</p>
<h2 id="2-idea卸载"><a href="#2-idea卸载" class="headerlink" title="2. idea卸载"></a>2. idea卸载</h2><p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_01.png" alt="代码"></p>
<p>配置文件</p>
<p>删除又是最新的</p>
<p>system   缓存文件   索引</p>
<p>使用control–&gt;卸载</p>
<p>重装  建议重启电脑</p>
<h2 id="3-idea的介绍"><a href="#3-idea的介绍" class="headerlink" title="3.idea的介绍"></a>3.idea的介绍</h2><p>STS</p>
<p>2018.3.4</p>
<p>学技术  必须先找官网</p>
<h2 id="4-idea的安装"><a href="#4-idea的安装" class="headerlink" title="4.idea的安装"></a>4.idea的安装</h2><h2 id="5-启动IDEA-并实现helloWorld"><a href="#5-启动IDEA-并实现helloWorld" class="headerlink" title="5.启动IDEA 并实现helloWorld"></a>5.启动IDEA 并实现helloWorld</h2><p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_02.png" alt="代码"></p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_03.png" alt="代码"></p>
<p>“hellow”.sout</p>
<h2 id="6-module的理解和创建"><a href="#6-module的理解和创建" class="headerlink" title="6.module的理解和创建"></a>6.module的理解和创建</h2><p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_04.png" alt="代码"></p>
<p>点击工程 new Module</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_05.png" alt="代码"></p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_06.png" alt="代码"></p>
<p>每个功能建立模块</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_07.png" alt="代码"></p>
<h2 id="7-idea-常用配置"><a href="#7-idea-常用配置" class="headerlink" title="7.idea 常用配置"></a>7.idea 常用配置</h2><p>五</p>
<p>悬浮提示</p>
<p>自动导报</p>
<h2 id="8-快捷键的设置"><a href="#8-快捷键的设置" class="headerlink" title="8.快捷键的设置"></a>8.快捷键的设置</h2><h2 id="9-模板的使用和配置"><a href="#9-模板的使用和配置" class="headerlink" title="9.模板的使用和配置"></a>9.模板的使用和配置</h2><p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_08.png" alt="代码"></p>
<p>live tem 是可以做修改和添加的</p>
<p>psvm</p>
<p>sout</p>
<p>for i      iter   itar </p>
<p>list.for    list.fori 普通  list.forr 逆序</p>
<p>ifn   inn   xxx.nn  xxx.null</p>
<p>prsf  单例  psf psfs psfi </p>
<p>soutp形参   m方法名   v变量</p>
<p>thr</p>
<h2 id="10-程序进程线程的概念"><a href="#10-程序进程线程的概念" class="headerlink" title="10.程序进程线程的概念"></a>10.程序进程线程的概念</h2><h3 id="8-1-基本概念程序、进程、线程"><a href="#8-1-基本概念程序、进程、线程" class="headerlink" title="8-1 基本概念程序、进程、线程"></a>8-1 基本概念程序、进程、线程</h3><ul>
<li><p>程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指<code>一段静态的代码</code>， 静态对象。</p>
</li>
<li><p>进程(process)是程序的一次执行过程，或是<code>正在运行的一个程序</code>。是-一个动态的过程:有它自身的产生、存在和消亡的过程.——–生 命周期<br>➢如:运行中的QQ，运行中的MP3播放器<br>➢程序是静态的，进程是动态的<br>➢进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</p>
</li>
<li><p>线程(thread)，进程可进一步细化为线程， 是一个程序内部的一条执行路径。<br>➢若一个进程同一时间<code>并行</code>执行多个线程，就是支持多线程的<br>➢<code>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)</code>，线程切换的开销小<br>➢一个进程中的多个线程共享相同的内存单元/内存地址空间≥它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来<code>安全的隐患</code>。<br>同时在执行，需要解决线程同步的安全问题<br><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_11.png" alt="多线程 "></p>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2></li>
<li><p>单核CPU和多核CPU的理解</p>
<ul>
<li>单核CPU，其实是一种假的多线程，因为在-一个时间单元内，也只能执行一个线程的任务。例如:虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”(晾着他， 等他想通了，准备好了钱，再去收费)。但是因为CPU时间单元特别短，因此感觉不出来。</li>
<li>如果是多核的话，才能更好的发挥多线程的效率。 (现在的服务器都是多核的)</li>
<li>一个Java应用程序java.exe， 其实至少有三个线程: main()主线程， gc()<br>垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li>
</ul>
</li>
<li><p>并行与并发</p>
<ul>
<li><p>并行:多个CPU同时执行多个任务。比如:多个人同时做不同的事。 每个车道开自己的，篮球场</p>
</li>
<li><p>并发:一个CPU(采用时间片)同时执行多个任务。比如:秒杀、多个人做同一件事。    抢火车票</p>
<h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><h4 id="使用-多线程的优点"><a href="#使用-多线程的优点" class="headerlink" title="使用 多线程的优点"></a>使用 多线程的优点</h4><p>背景:以单核CPU为例， 只使用单个线程先后完成多个任务(调用多个方<br>法)，肯定比用多个线程来完成用的时间更短，为何仍需多线程呢?<br>多线程程序的优点:</p>
</li>
</ul>
</li>
</ul>
<p>1.提高应用程序的响应。对图形化界面更有意义，可增强用户体验。<br>2.提高计算机系统CPU的利用率<br>3.改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和<br>修改</p>
<h4 id="何时需要多线程"><a href="#何时需要多线程" class="headerlink" title="何时需要多线程"></a>何时需要多线程</h4><ul>
<li>程序需要同时执行两个或多个任务。</li>
<li>程序需要实现一些需要等待的任务时，如用户输入、文件读写<br>操作、网络操作、搜索等。</li>
<li>需要一些后台运行的程序时。  java gc<br>美团外卖往上划图片<h3 id="8-2-线程的创建和使用-重点"><a href="#8-2-线程的创建和使用-重点" class="headerlink" title="8-2 线程的创建和使用(重点)"></a>8-2 线程的创建和使用(重点)</h3><h2 id="13-创建多线程方式一-继承Thread类"><a href="#13-创建多线程方式一-继承Thread类" class="headerlink" title="13 创建多线程方式一 继承Thread类"></a>13 创建多线程方式一 继承Thread类</h2><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_12.png" alt="多线程 "></li>
</ul>
<p>看能不能那一条线划出来</p>
<ul>
<li>Java语言的JVM允许程序运行多个线程，它通过<code>java.lang.Thread</code><br>类来体现。</li>
<li>Thread类的特性<br>➢ 每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常<br>把run()方法的主体称为线程体<br>➢ 通过该Thread对象的star()方法来启动这个线程，而非直接调用run()<h1 id="重写人家的看人家怎么生成"><a href="#重写人家的看人家怎么生成" class="headerlink" title="重写人家的看人家怎么生成"></a>重写人家的看人家怎么生成</h1>多线程的创建，方式一：继承于Thread类</li>
</ul>
<ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()<br><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_13.png" alt="多线程 "></li>
</ol>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_14.png" alt="多线程 "></p>
<p>3，4 主线程做  怀孕  </p>
<p>run 独立去执行</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_15.png" alt="hello在哪执行不确定 "></p>
<h2 id="14-创建过程中两个问题的说明"><a href="#14-创建过程中两个问题的说明" class="headerlink" title="14.创建过程中两个问题的说明"></a>14.创建过程中两个问题的说明</h2><p>4.通过此对象调用start():@启动当前线程②调用当前线程的run()|</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_16.png" alt="hello在哪执行不确定 "></p>
<p>若只调t1.run()   不会开启线程    Thread.currentThread().getName()   获取当前线程名字</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_17.png" alt="问题 1 和 2 "></p>
<h2 id="15-继承方式的课后练习"><a href="#15-继承方式的课后练习" class="headerlink" title="15.继承方式的课后练习"></a>15.继承方式的课后练习</h2><p>src下建立包</p>
<p>练习:创建两个分线程，其中一一个线程遍历100 以内的偶数，另一个线程遍历100以内的奇数(两个线程做事不一样)</p>
<p>创建2个子类对象，实现就可以了。提供各自的run</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_18.png" alt="第一种方法 "></p>
<p>第二种方法  创建两个匿名子类</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_19.png" alt="方法二"></p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_20.png" alt="方法二"></p>
<p>重写run方法，  new的是子类对象，Thread充当的</p>
<h2 id="16-线程的常用方法"><a href="#16-线程的常用方法" class="headerlink" title="16.线程的常用方法"></a>16.线程的常用方法</h2><ul>
<li>void start():启动线程，并执行对象的run()方法</li>
<li>run():线程在被调度时执行的操作</li>
<li>String getName():返回线程的名称</li>
<li>void setName(String name):设置该线程名称</li>
<li>static Thread currentThread():返回当前线程。在Thread子 类中就<br>是this，通常用于主线程和Runnable实现类<br><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_21.png" alt="有关方法"></li>
</ul>
<p>测试Thread中的常用方法：<br>1.start():启动当前线程；调用当前线程的run()<br>2.run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中<br>3.currentThread():静态方法，返回执行当前代码的线程<br>4.getName():获取当前线程的名字<br>5.setName():设置当前线程的名字<br><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_22.png" alt="有关方法"></p>
<p>第二种 通过构造方法来修改</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_23.png" alt="有关方法"></p>
<p>6.yield():释放当前cpu的执行权</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_24.png" alt="yield方法"></p>
<p>this 可省略或改成  Thread.currentThread().getName()</p>
<p>7.join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。 </p>
<p>下图的线程a就是主线程</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_25.png" alt="join方法"></p>
<p>h1执行完后才会执行主线程</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_26.png" alt="join方法的图解"></p>
<p>应用 场景，一个正在执行线程需要另外一个线程的数据</p>
<p>大比方，领导蹭饭</p>
<p>8.stop():已过时。不推荐使用  当执行此方法时，强制结束当前线程。<br>9.sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_27.png" alt="sleep的图解"></p>
<p>应用场景:倒计时  …. </p>
<p>10.isAlive():判断当前线程是否存活</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_28.png" alt="isAlive的图解"></p>
<h2 id="17-线程优先级的设置"><a href="#17-线程优先级的设置" class="headerlink" title="17.线程优先级的设置"></a>17.线程优先级的设置</h2><p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_29.png" alt="isAlive的图解"></p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_30.png" alt="isAlive的图解"></p>
<p>抢占式 打比方   银行排队</p>
<ul>
<li>线程的优先级：<br>1.<br>MAX_PRIORITY：10<br>MIN _PRIORITY：1<br>NORM_PRIORITY：5  –&gt;默认优先级<br>2.如何获取和设置当前线程的优先级：<br>  getPriority():获取线程的优先级<br>  setPriority(int p):设置线程的优先级<br>  说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。<br><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_31.png" alt="获优先级取"></li>
</ul>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_32.png" alt="设置优先级"></p>
<h2 id="18-继承Thread方式-多窗口卖票"><a href="#18-继承Thread方式-多窗口卖票" class="headerlink" title="18.继承Thread方式,多窗口卖票"></a>18.继承Thread方式,多窗口卖票</h2><p>创建三个窗口卖票，总票数100张</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_33.png" alt="设置优先级"></p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_34.png" alt="设置优先级"></p>
<p>方法一:</p>
<p>private static int ticket=100  ；出现线程安全问题</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_35.png" alt="设置优先级"></p>
<h2 id="19-创建多线程方式二，实现Runnable接口"><a href="#19-创建多线程方式二，实现Runnable接口" class="headerlink" title="19.创建多线程方式二，实现Runnable接口"></a>19.创建多线程方式二，实现Runnable接口</h2><p>创建多线程的方式二：实现Runnable接口</p>
<ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ol>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_36.png" alt="1-2步"></p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_37.png" alt="3-5步   4步实多态 new Thread(多态) "></p>
<p>调用了Runnable类型的target的run()</p>
<p>代理模式</p>
<h4 id="再次创建一个线程"><a href="#再次创建一个线程" class="headerlink" title="再次创建一个线程"></a>再次创建一个线程</h4><p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_38.png" alt="再次创建一个线程"></p>
<p>只能这样写 获取进程名字</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_39.png" alt="再次创建一个线程"></p>
<p>t1.setName(“线程1”)</p>
<h2 id="20-实现Runnable方式-多窗口卖票"><a href="#20-实现Runnable方式-多窗口卖票" class="headerlink" title="20.实现Runnable方式,多窗口卖票"></a>20.实现Runnable方式,多窗口卖票</h2><p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_40.png" alt="实现窗口卖票"></p>
<p>alt+enter</p>
<p><img src="/2017/06/30/2016-06-30-idea-xue-xi-yu-duo-xian-cheng/18_41.png" alt="实现窗口卖票"></p>
<p>也存在线程安全问题，100张票，因为制造了一个对象</p>
<h2 id="21-两种创建方式的对比"><a href="#21-两种创建方式的对比" class="headerlink" title="21.两种创建方式的对比"></a>21.两种创建方式的对比</h2><p>比较创建线程的两种方式。<br>开发中：优先选择：实现Runnable接口的方式<br>原因：1. 实现的方式没有类的单继承性的局限性<br>     2. 实现的方式更适合来处理多个线程有共享数据的情况。<br>联系：public class Thread implements Runnable<br>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2017/06/30/2016-06-30-yi-chang-chu-li/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1.每日一考"></a>1.每日一考</h2><p>抽象和接口是中心</p>
<p>1.abstract 能修饰哪些结构?修饰以后， 有什么特点?<br>类、方法<br>static final abstract<br>类不能实例化，提供子类  extends<br>抽象方法，，只定义了一种功能的标准。具体的执行,需要子类去实现。</p>
<p>2.接口是否能继承接口?抽象类是否能实现(implements)接口?抽象<br>类是否能继承非抽象的类?。<br>能；能；能（object）</p>
<p>3.声明抽象类，并包含抽象方法。测试类中创建 一个继承抽象类的匿名子类的对象<br>匿名子类的对象。<br>abstract AA{<br>public abstract void m();<br>}<br>main(){<br>AAa = new AA(){<br>public void m(){</p>
<p>}<br>};<br>a.m();}<br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_01.png" alt="代码"></p>
<p>4.抽象类和接口有哪些共同点和区别?<br>不能实例化<br>不同类:抽象类  有构造器  ，接口没有<br>多继承VS单继承<br>接口往类方向靠近<br>5.如何创建静态成员内部类和非静态成员内部类的对象?<br>Person static Dog Bird<br>Person.Dog dog = new Person.Dog();<br>Person p = new Person();<br>Person.Bird bird = p.new Bird();<br>理解没用  还是要做些2遍</p>
<h2 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2.抽象类"></a>2.抽象类</h2><p>abstract:抽象的<br>1.可以用来修饰:类、方法<br>2.具体的:<br>abstract修饰类:抽象类</p>
<ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用(涉及:子类对象实例化的全过程)</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作—&gt;抽象的使用前提:继承性</li>
</ul>
<p>abstract修饰方法:抽象方法</p>
<ul>
<li>抽象方法只方法的声明，没方法体</li>
<li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li>
<li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li>
<li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li>
</ul>
<p>3.注意点:<br>1.abstract不能用来修饰:属性、构造器等结构<br>2.abstract不能用来修饰私方法、静态方法、final的方法、final的类<br>今天方法不能被重写</p>
<ol start="4">
<li>abstract的应用举例:<br>public void method(Person p){}<br>交通工具</li>
</ol>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_02.png" alt="抽象复习 "><br>举例二  求面积<br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_03.png" alt="抽象复习 "><br>IO流</p>
<p>想继承必须要重写<br>举例三: I0流中设计到的抽象类: InputStream/outputStream|Reader /Writer<br>在内部定义类抽象的read(）)</p>
<h3 id="模板方法的设计模式"><a href="#模板方法的设计模式" class="headerlink" title="模板方法的设计模式"></a>模板方法的设计模式</h3><p>1.解决的问题<br>在软件开发中实现-一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变<br>部分可以抽象出来，供不同子类实现。这就是一种模板模式。<br>2.举例<br>花费了多长时间<br>原来就是模板<br>3.应用场景</p>
<h2 id="3-复习-接口"><a href="#3-复习-接口" class="headerlink" title="3. 复习 接口"></a>3. 复习 接口</h2><p>interface:接口<br>1.使用说明:<br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_04.png" alt="抽象复习 "><br>比较清楚理解这个事就可以 ，主要是多写代码<br>2.举例:</p>
<p>U盘插电脑</p>
<p>体会:</p>
<ul>
<li>1.接口使用，上也满足多态性</li>
</ul>
<p>2.接口，实际上就是定义了一种规范</p>
<p>3.开发中，体会面向接口编程!</p>
<p>3.体会面向接口编程的思想</p>
<p> JDBC 技术  操作数据库的规范    sun定义规范</p>
<p>面向接口编程:我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个数据库厂商的API。</p>
<p>4.Java8中关于接口的新规范   对大家要求不高</p>
<p>//知识点1:接口中定义的静态方法，只能通过接口来调用。<br>//知识点2:通过实现类的对象，可以调用接口中的默认方法。.<br>//如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法<br>//知识点3:如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重<br>写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则<br>//知识点4:如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，<br>//那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。<br>//这就需要我们必须在实现类中重写此方法</p>
<p>//知识点5:如何在子类(或实现类)的方法中调用父类、接口中被重写的方法<br>public void myMethod(){<br>method3();//调用自己定义的重写的方法.<br>super . method3();//调用的是父类中声明的<br>//调用接口中的默认方法<br>CompareA. super . method3();<br>CompareB . super . method3();<br>}</p>
<p>5.面试题:</p>
<p>抽象类和接口的异同   往新特征靠</p>
<p>java7  定义常量和方法</p>
<p>java8 静态方法</p>
<p>Java 9 私有方法</p>
<p>抽象类和接口的异同?<br>相同点:不能实例化;都可以包含抽象方法的。.<br>不同点:<br>1)把抽象类和接口(java7, java8, java9)的定义、内部结构解释说明<br>2)类:单继承性<br>接口:多继承<br>类与接口:多实现</p>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>1.解决的问题<br>代理模式是Java开发中使用较多的-种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。<br>2.举例</p>
<p>代理上网，明星经纪人</p>
<p>3.应用场景</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/..%5CstudyNote_Pic%5Csgg%5Cday12%5C16_05.png" alt="代理模式"></p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂方法</p>
<p>抽象工厂  </p>
<p>1.解决的问题<br>实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。<br>2.具体模式</p>
<ul>
<li>简单工厂模式:用来生产同一等级结构中的任意产品。(对于增加新的产品， 需要修改已有代码)</li>
<li>厂方法模式:用来生产同一等级结构中的固定产品。(支持增加任意产品</li>
<li>抽象工厂模式:用来生产不同产品族的全部产品。(对于增加新的产品， 无能为力;支持增加产品族<h2 id="4-复习内部类"><a href="#4-复习内部类" class="headerlink" title="4 复习内部类"></a>4 复习内部类</h2><h4 id="内部类-类的第五个成员"><a href="#内部类-类的第五个成员" class="headerlink" title="内部类:类的第五个成员"></a>内部类:类的第五个成员</h4></li>
</ul>
<p>1.定义:Java中允许将-一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.<br>2.内部类的分类:<br>成员内部类(静态、非静态)Vs局部内部类(方法内、代码块内、构造器内)</p>
<p>3.成员内部类的理解:</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/..%5CstudyNote_Pic%5Csgg%5Cday12%5C16_06.png" alt="成员内部类的理解"></p>
<p>4.成员内部类:<br>4.1如何创建成员内部类的对象?(静态的，非静态的)<br>//创建静态的Dog内部类的实例(静态的成员内部类):<br>Person.Dog dog = new Person.Dog();<br>//创建非静态的Bird内部类的实例(非静态的成员内部类):<br>//Person.Bird bird = new Person. Bird();//错误的<br>Person p = new Person() ;<br>Person.Bird bird = p.new Bird();</p>
<p>4.2如何在成员内部类中调用外部类的结构?<br>dlass Bird{<br>String name =<br>“杜鹃”;<br>public void display(String name ){<br>System. out . println(name);//方法的形参<br>System. out. print1n( this. name);//内部类的属性<br>System. out . print1n(Person. this . name);//外部类的属性<br>}</p>
<p>5.局部内部类的使用:<br>/ /返回一个实现了Comparable接口的类的对象<br>public Comparable getComparable(){<br>注意点：<br>前台开发  android</p>
<p>在局部内部类的方法中（比如：show）如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,<br>要求此局部变量声明为final的。<br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_07.png" alt="代码"></p>
<p>副本不能更改，只能用本身</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_08.png" alt="代码"></p>
<p>jdk 7及之前版本：要求此局部变量显式的声明为final的<br>jdk 8及之后的版本：可以省略final的声明</p>
<p>总结:<br>成员内部类和局部内部类，在编译以后，都会生成字节码文件。<br>格式:成员内部类:外部类$内部类名.class<br>局部内部类:外部类$数字内部类名.class</p>
<h2 id="6-异常概述"><a href="#6-异常概述" class="headerlink" title="6.异常概述"></a>6.异常概述</h2><h3 id="7-1异常概述与异常体系结构"><a href="#7-1异常概述与异常体系结构" class="headerlink" title="7-1异常概述与异常体系结构"></a>7-1异常概述与异常体系结构</h3><p>在使用计算机语言进行项目开发的过程中，即序员把代码写得 尽善美 ， 在系统的运行过程中仍然会遇到一些问题，因为很多不是靠代码能够避免的，比如:客户输入数据的格式，读取文件是否存在，网络是否始终保持通畅等等。</p>
<hr>
<ul>
<li>异常:在Java语言中，将程序执行中发生的不正常情况称为“异常’。(开发过程中的语法错误和逻辑错误不是异常)</li>
<li>Java程序在执行过程中所发生的异常事件可分为两类:<br>➢Error: Java虛 拟机无法解决的严重问题。如: JVM系统内部错误、资源.<br>耗尽等严重情况。比如: StackOverflowError和OOM。一般不编写针对性<br>的代码进行处理。<br>➢Exception:其它因编程错误或偶然的外在因素导致的一般性问题，可以使<br>用针对性的代码进行处理。例如:<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
</li>
</ul>
<p>Error:<br>Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。<br>一般不编写针对性的代码进行处理。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//1.栈溢出：java.lang.StackOverflowError</span></span><br><span class="line"><span class="comment">//		main(args);</span></span><br><span class="line">		<span class="comment">//2.堆溢出：java.lang.OutOfMemoryError  OOM</span></span><br><span class="line">		Integer[] arr = <span class="keyword">new</span> Integer[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="7-异常的分类"><a href="#7-异常的分类" class="headerlink" title="7.异常的分类"></a>7.异常的分类</h2><ul>
<li>对于这些错误，一 般有两种<code>解决方法</code>:一是遇到错误就终止程序<br>的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。   （打比方 生病了  ，工作做不了的;提前拿药；过高速路口 </li>
<li>捕获错误最理想的是在<code>编译期间</code>，但有的错误只有在运行时才会发生。<br>比如:<code>除数为0，数组下标越界</code>等<br>  ➢分类:编译时异常和运行时异常<br>Throwable   顶级父类<br>Exception<h3 id="7-2常见异常"><a href="#7-2常见异常" class="headerlink" title="7-2常见异常"></a>7-2常见异常</h3>一、异常体系结构</li>
</ul>
<p>java.lang.Throwable<br>        |—–java.lang.Error:一般不编写针对性的代码进行处理。<br>        |—–java.lang.Exception:可以进行异常的处理<br>            |——编译时异常(checked)<br>                    |—–IOException<br>                        |—–FileNotFoundException<br>                    |—–ClassNotFoundException<br>            |——运行时异常(unchecked,RuntimeException)<br>                    |—–NullPointerException<br>                    |—–ArrayIndexOutOfBoundsException<br>                    |—–ClassCastException<br>                    |—–NumberFormatException<br>                    |—–InputMismatchException<br>                    |—–ArithmeticException</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_09.png" alt="异常分类"><br>面试题：常见的异常都有哪些？举例说明</p>
<h2 id="8-常见异常的举例"><a href="#8-常见异常的举例" class="headerlink" title="8.常见异常的举例"></a>8.常见异常的举例</h2><p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_10.png" alt="异常举例"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_11.png" alt="异常举例"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_12.png" alt="异常举例"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_13.png" alt="异常举例  输入abc  异常"><br>编译时异常举例<br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_14.png" alt="异常举例  编译时异常"></p>
<h2 id="9-异常处理方式概述"><a href="#9-异常处理方式概述" class="headerlink" title="9.异常处理方式概述"></a>9.异常处理方式概述</h2><h3 id="7-3异常处理机制一-try-catch-fially-自己可以搞定"><a href="#7-3异常处理机制一-try-catch-fially-自己可以搞定" class="headerlink" title="7-3异常处理机制一: try- catch-fially(自己可以搞定)"></a>7-3异常处理机制一: try- catch-fially(自己可以搞定)</h3><p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_15.png" alt="异常处理机制一"></p>
<ul>
<li>Java提供的是异常处理的抓拋模型。</li>
<li>Java程序的执行过程中如出现异常，会生成一一个异常类对象，该异常对象将被提交给Java运行时系统，这个过程称为抛出(throw)异常。</li>
<li>异常对象的生成<br>➢由虚拟机自动生成:程序运行过程中，虚拟机检测到程序发生了问题，如果在当前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例对象并抛出————自动抛出<br>➢由开发人员手动创建: Exception exception = new ClassCastException();一创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样</li>
</ul>
<hr>
<p>一、异常的处理：抓抛模型</p>
<p>过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出,一旦抛出对象以后，其后的代码就不再执行<br>关于异常对象的产生：① 系统自动生成的异常对象② 手动的生成一个异常对象，并抛出（throw）<br>过程二：”抓”：可以理解为异常的处理方式：① try-catch-finally  ② throws</p>
<h2 id="10-try-catch-方式"><a href="#10-try-catch-方式" class="headerlink" title="10.try-catch 方式"></a>10.try-catch 方式</h2><p>二、try-catch-finally的使用</p>
<p>try{<br>        //可能出现异常的代码</p>
<p>}catch(异常类型1 变量名1){<br>        //处理异常的方式1<br>}catch(异常类型2 变量名2){<br>        //处理异常的方式2<br>}catch(异常类型3 变量名3){<br>        //处理异常的方式3<br>}<br>….<br>finally{<br>        //一定会执行的代码<br>}</p>
<p>说明：</p>
<ol>
<li>finally是可选的。</li>
<li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的 try-catch结构（在没有写finally的情况）。继续执行其后的代码</li>
<li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。<br>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</li>
<li>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()  详细</li>
<li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li>
<li>try-catch-finally结构可以嵌套</li>
</ol>
<p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。<br>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。 针对于编译时异常，我们说一定要考虑异常的处理。</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_16.png" alt="代码"></p>
<h2 id="11-finally的使用"><a href="#11-finally的使用" class="headerlink" title="11.finally的使用"></a>11.finally的使用</h2><p>try-catch-finally中finally的使用：</p>
<p>1.finally是可选的</p>
<p>2.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p>
<p>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_17.png" alt="代码"></p>
<p>垃圾回收机制只回收JVM堆内存里的对象空间。<br>对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力</p>
<p>需要自己关流</p>
<p>编译器自己surround With try/cath</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_18.png" alt="避免空指针异常"></p>
<h2 id="12-编译时异常和运行时异常订单不同处理"><a href="#12-编译时异常和运行时异常订单不同处理" class="headerlink" title="12.编译时异常和运行时异常订单不同处理"></a>12.编译时异常和运行时异常订单不同处理</h2><p>运行时异常  不考虑try-catch处理</p>
<p>编译时异常  考虑</p>
<h2 id="13-处理异常-throws-方式"><a href="#13-处理异常-throws-方式" class="headerlink" title="13.处理异常:throws 方式"></a>13.处理异常:throws 方式</h2><h3 id="7-4异常处理机制二-throws-搞不定，找别人-往上报"><a href="#7-4异常处理机制二-throws-搞不定，找别人-往上报" class="headerlink" title="7-4异常处理机制二: throws(搞不定，找别人  往上报)"></a>7-4异常处理机制二: throws(搞不定，找别人  往上报)</h3><p>异常处理的方式二：throws + 异常类型</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_19.png" alt="例子"></p>
<ol>
<li><p>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。</p>
<p> 异常代码后续的代码，就不再执行！</p>
</li>
<li><p>体会：try-catch-finally:真正的将异常给处理掉了。</p>
<pre><code>throws的方式只是将异常抛给了方法的调用者。  并没有真正将异常处理掉。  </code></pre></li>
<li><p>开发中如何选择使用try-catch-finally 还是使用throws？<br>  3.1 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。</p>
<pre><code>3.2 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。    二选择一</code></pre></li>
</ol>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_20.png" alt="例子"></p>
<p>往上扑出，往上剖 ，异常并没有解决掉</p>
<h2 id="14-重写方法抛出的规则"><a href="#14-重写方法抛出的规则" class="headerlink" title="14.重写方法抛出的规则"></a>14.重写方法抛出的规则</h2><p>方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<h2 id="15-开发中如何选择那中方式处理异常"><a href="#15-开发中如何选择那中方式处理异常" class="headerlink" title="15.开发中如何选择那中方式处理异常"></a>15.开发中如何选择那中方式处理异常</h2><h2 id="16-手动抛出异常对象"><a href="#16-手动抛出异常对象" class="headerlink" title="16.手动抛出异常对象"></a>16.手动抛出异常对象</h2><p>7-5手动抛出异常: throw</p>
<p>产生手动  throw</p>
<p>抛出异常 throws    异常处理的一种方式</p>
<p> new RuntimeException或Exception</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_21.png" alt="例子"></p>
<h5 id="throw-new-Exception-“ns”-需要做处理-throws一下"><a href="#throw-new-Exception-“ns”-需要做处理-throws一下" class="headerlink" title="throw new Exception(“ns”)  需要做处理   throws一下"></a>throw new Exception(“ns”)  需要做处理   throws一下</h5><p>throws 体现异常处理，在方法声明处</p>
<p>生成一个异常对象，在方法里面</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_22.png" alt="throws"></p>
<h2 id="17-如何自动义异常"><a href="#17-如何自动义异常" class="headerlink" title="17.如何自动义异常"></a>17.如何自动义异常</h2><h3 id="7-6用户自定义异常类"><a href="#7-6用户自定义异常类" class="headerlink" title="7-6用户自定义异常类"></a>7-6用户自定义异常类</h3><p>如何自定义异常类?<br>1.继承于现有的异常结构: RuntimeException、Exception<br>2.提供全局常量: serialVersionUID<br>3.提供重载的构造器<br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_23.png" alt="throws"></p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_24.png" alt="throws"></p>
<p>只有异常体系才能throw</p>
<h2 id="18-基本使用"><a href="#18-基本使用" class="headerlink" title="18.基本使用"></a>18.基本使用</h2><p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_25.png" alt="throws"></p>
<h2 id="19-异常处理的练习"><a href="#19-异常处理的练习" class="headerlink" title="19.异常处理的练习"></a>19.异常处理的练习</h2><p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_26.png" alt="总结"></p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_27.png" alt="throws"></p>
<h2 id="20-异常处理章节总结"><a href="#20-异常处理章节总结" class="headerlink" title="20.异常处理章节总结"></a>20.异常处理章节总结</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>1.异常的体系结构</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_28.png" alt="异常体系结构"></p>
<p>2.从程序执行过程，看编译时异常和运行时异常</p>
<p>编译时异常:执行javac . exe命名时，可能出现的异常</p>
<p>运行时异常:执行java. exe命名时，可能出现的异常I</p>
<p>3.常见的异常类型，请举例说明:</p>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><ol>
<li>java异常处理的抓抛模型<br>过程一:“抛”:程序在正常执行的过程中，一一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。<br>关于异常对象的产生:①系统自动生成的异常对象<br>②手动的生成一个异常对象，并抛出(throw)|<br>过程二:“抓”: 可以理解为异常的处理方式:①try-catch-finally ② throws</li>
</ol>
<p>2.2.异常处理方式一try-cakch-finally|<br>2.1使用说明:</p>
<p>、try-catch-finally的使用</p>
<p>try{<br>        //可能出现异常的代码</p>
<p>}catch(异常类型1 变量名1){<br>        //处理异常的方式1<br>}catch(异常类型2 变量名2){<br>        //处理异常的方式2<br>}catch(异常类型3 变量名3){<br>        //处理异常的方式3<br>}<br>….<br>finally{<br>        //一定会执行的代码<br>}</p>
<p>说明：</p>
<ol>
<li>finally是可选的。</li>
<li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配</li>
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的 try-catch结构（在没有写finally的情况）。继续执行其后的代码</li>
<li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。<br>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</li>
<li>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()  详细</li>
<li>在try结构中声明的变量，再出了try结构以后，就不能再被调用</li>
<li>try-catch-finally结构可以嵌套</li>
</ol>
<p>总结:如何看待代码中的编译时异常和运行时异常?</p>
<p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。 相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。<br>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。<br>     针对于编译时异常，我们说一定要考虑异常的处理。</p>
<p>编译时异常 必须进行处理</p>
<p>2.2: finally的再 说明: </p>
<ul>
<li>1.finally是可省略的</li>
<li>2.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中return语句，catch中return语句等情况。</li>
<li>3.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。I</li>
</ul>
<p>2.3: [面试题]<br>final、finally. finalize三者的区别?</p>
<p>类似:</p>
<p>throw和throws<br>Collection和Collections<br>String、StringBuffer. StringBuilder<br>ArrayList、LinkedList<br>HashMap、LinkedHashMap<br>重写、重载</p>
<p>结构不相似的:<br>抽象类、接口<br>==、equals()<br>sleep()、wait()</p>
<p>3.异常处理方式二:</p>
<p>“throws +异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成-一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行!</p>
<p>4.对比两种处理方式<br>try-catch-finally:   真正的将异常给处理掉了<br>throws的方式只是将异常抛给了方法的调用者。|并没真正将异常处理掉。</p>
<p>5.体会开发中应该如何选择两种处理方式?<br>5.1 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理.<br>5.2 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</p>
<p>补充:<br>方法重写的规则之一:<br>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p>
<h3 id="手动抛出异常对象"><a href="#手动抛出异常对象" class="headerlink" title="手动抛出异常对象"></a>手动抛出异常对象</h3><p>1.使用说明<br>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw-个异常类的对象。</p>
<p>2.[面试题]<br>throw和throws 区别:<br>throw表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。<br>throws属于异常处理的一种方式，声明在方法的声明处。</p>
<p>3.典型例题;</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_30.png" alt="例子"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_31.png" alt="例子"></p>
<h3 id="自定义异常对象"><a href="#自定义异常对象" class="headerlink" title="自定义异常对象"></a>自定义异常对象</h3><p>如何自定义一个异常类?<br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/16_32.png" alt="如何自定义异常类"></p>
<h2 id="项目三"><a href="#项目三" class="headerlink" title="项目三"></a>项目三</h2><p>开发团队人员调度软件</p>
<p>项目三软件架构</p>
<p>处理语言的能力  </p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/17_01.png" alt="代码"></p>
<p>throw new TeamException(“找不到指定的员工”)</p>
<p>各个详情不一样，  多态</p>
<p><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/17_02.png" alt="代码"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/17_03.png" alt="代码"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/17_04.png" alt="代码"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/17_05.png" alt="代码"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/17_06.png" alt="代码"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/17_07.png" alt="代码"><br><img src="/2017/06/30/2016-06-30-yi-chang-chu-li/17_08.png" alt="代码"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(下)补1</title>
    <url>/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1. 每日一考"></a>1. 每日一考</h2><h3 id="1-static修饰的属性，相较于实例变量，有哪些特别之处-gt-3点"><a href="#1-static修饰的属性，相较于实例变量，有哪些特别之处-gt-3点" class="headerlink" title="1.static修饰的属性，相较于实例变量，有哪些特别之处(>=3点)"></a>1.static修饰的属性，相较于实例变量，有哪些特别之处(&gt;=3点)</h3><p>随着类的加载而加载:早于对象的创建;只要权限允许，可以通过”对象.static属性”的方式进行调用:存在于方法区的静态域。</p>
<h3 id="2-final可以用来修饰哪些结构，分别表示什么意思。"><a href="#2-final可以用来修饰哪些结构，分别表示什么意思。" class="headerlink" title="2.final可以用来修饰哪些结构，分别表示什么意思。"></a>2.final可以用来修饰哪些结构，分别表示什么意思。</h3><h3 id="3-代码实现单例模式的饿汉式4"><a href="#3-代码实现单例模式的饿汉式4" class="headerlink" title="3.代码实现单例模式的饿汉式4"></a>3.代码实现单例模式的饿汉式4</h3><h3 id="4-代码实现单例模式的懒汉式"><a href="#4-代码实现单例模式的懒汉式" class="headerlink" title="4.代码实现单例模式的懒汉式"></a>4.代码实现单例模式的懒汉式</h3><h3 id="5-类的属性赋值的位置有哪些-先后顺序为何"><a href="#5-类的属性赋值的位置有哪些-先后顺序为何" class="headerlink" title="5.类的属性赋值的位置有哪些?先后顺序为何?"></a>5.类的属性赋值的位置有哪些?先后顺序为何?</h3><p>默认初始化<br>显式初始化、代码块中初始化<br>构造器中初始化<br>通过”对象.属性”或”对象.方法”的方式赋值</p>
<h2 id="2-复习static"><a href="#2-复习static" class="headerlink" title="2.复习static"></a>2.复习static</h2><p>static:静态的<br>1.可以用来修饰的结构:主要用来修饰类的内部结构<br>属性、方法、代码块、内部类</p>
<p>2.static修饰属性: 静态变量(或类变量)<br>​2.1 属性，按是否使用static修饰，又分为：静态属性vs 非静态属性(实例变量)</p>
<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。<br>2.2 static修饰属性的其他说明：<pre><code>① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用</code></pre>② 静态变量的加载要早于对象的创建。<br>③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。<br>④        类变量    实例变量<br>类        yes        no<br>对象        yes        yes<br>2.3 静态属性举例：System.out; Math.PI;</li>
</ul>
<p>3.静态变量内存解析:<br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_01.png" alt="静态变量内存解析"><br>4.static修饰方法: 静态方法、类方法</p>
<p>① 随着类的加载而加载，可以通过”类.静态方法”的方式进行调用<br>②            静态方法    非静态方法<br>                 类        yes        no<br>                 对象        yes        yes<br>③ 静态方法中，只能调用静态的方法或属性<br> 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
<p>5.static的注意点:</p>
<p>5.1在静态的方法内，不能使用this关键字、super关键字<br>5.2关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</p>
<p>6.如何判定属性和方法应该使用static关键字:</p>
<p>身份证号加final</p>
<p>构造中赋值  static</p>
<p>6.1关于属性</p>
<blockquote>
<p>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。<br>类中的常量也常常声明为static</p>
</blockquote>
<p>6.2关于方法</p>
<blockquote>
<p>操作静态属性的方法，通常设置为static的<br>工具类中的方法，习惯上声明为static的。 比如: Math、 Arrays、 Collections</p>
</blockquote>
<p>7.使用举例:<br>举例一: Arrays、 Math、Collections等工具类<br>举例二:单例模式<br>举例三:<br>class Circle{<br>private double radius ;<br>private int id;//自动赋值<br>public Circle(){<br>id = init++; .<br>total++;<br>}<br>public Circle(double radius){<br>this();<br>//<br>id = init++;<br>//<br>total++;<br>this.radius = radius;<br>}</p>
<h2 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h2><p>1.设计模式的说明<br>1.1 理解<br>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。<br>1.2常用设计模式— 23种经典的设计模式<br>创建型模式，共5种: 工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>结构型模式，共种:适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。<br>行为型模式，共11种:策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br>GOF<br>工作上手了 ，，那数据结构、设计模式 、JVM</p>
<p>2.单例模式<br>2.1要解决的问题:<br>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p>
<p>2.2具体代码的实现:<br>饿汉式<br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_02.png" alt="饿汉式"><br>懒汉式;<br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_03.png" alt="懒汉式"><br>2.3两种方式的对比:<br>饿汉式:<br>坏处:对象加载时间过长。<br>好处:饿汉式是线程安全的<br>懒汉式:好处:延迟对象的创建。<br>目前的写法坏处:线程不安全。—&gt;到多线程内容时，再修改</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_04.png" alt="懒汉式优化  线程安全"></p>
<p>效率差</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_05.png" alt="也算单例"></p>
<h2 id="4-复习main"><a href="#4-复习main" class="headerlink" title="4.复习main()"></a>4.复习main()</h2><p>1.main()方法作为程序的入口<br>2.main()方法也是一个普通的静态方法<br>3.main()方法可以作为我们与控制台交互的方式。 (之.前: 使用Scanner</p>
<p>如何将控制台获取的数据传给形参: String[] args?<br>运行时: java 类名’Tom” “Jerry” “123” “true“<br>sysout(args[0]);//“Tom<br>sysout(args[3]);//“true”<br>– &gt;Boolean. parseBoolean(args[3]);<br>sysout(args[4])//报异常  最好 length-1</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_06.png" alt="小节"></p>
<p>方法体:来体现方法的功能</p>
<p>你哪知道他有多少子类</p>
<p>所以传入父类就可以了</p>
<h2 id="5-代码块和final"><a href="#5-代码块和final" class="headerlink" title="5.代码块和final"></a>5.代码块和final</h2><p>类的成员之四:代码块(初始化块) (重要性较属性、方法、构造器差一些)<br>1.代码块的作用:用来初始化类、对象的信息</p>
<p>2.分类 :代码块要是使用修饰符，只能使用static</p>
<p>分类:静态代码块 VS 非静态代码块</p>
<p>3.</p>
<p>静态代码块:</p>
<blockquote>
<p>内部可以输出语句<br>随着类的加载而执行，而且只执行一次<br>作用:初始化类的信息<br>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>静态代码块的执行要优先于非静态代码块的执行<br>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p>
</blockquote>
<p>非静态代码块:</p>
<blockquote>
<p>内部可以输出语句<br>随着对象的创建而执行<br>每创建一个对象，就执行一-次非静态代码块<br>作用:可以在创建对象时，对对象的属性等进行初始化<br>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、静态的方法</p>
</blockquote>
<p>4.实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序: </p>
<p>对应的练习: LeafTest. java /I Son. java</p>
<p>由父及子，静态先行。</p>
<p>①默认初始化<br>②显式初始化/⑤在代码块中赋值<br>③构造器中初始化<br>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值<br>执行的先后顺序:①-②/⑤-③-④</p>
<h3 id="final-最终的"><a href="#final-最终的" class="headerlink" title="final:最终的"></a>final:最终的</h3><p>1.可以用来修饰:</p>
<p>可以用来修饰:类、方法、变量</p>
<p>2.具体的:</p>
<ol>
<li>final 用来修饰一个类:此类不能被其他类所继承。<pre><code>比如：String类、System类、StringBuffer类</code></pre></li>
<li>final 用来修饰方法：表明此方法不可以被重写<br>比如：Object类中getClass();</li>
<li>final 用来修饰变量：此时的”变量”就称为是一个常量<pre><code>3.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化
3.2 final修饰局部变量：
   尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</code></pre></li>
</ol>
<p> static final 用来修饰属性：全局常量</p>
<h2 id="6-抽象类和抽象方法的使用"><a href="#6-抽象类和抽象方法的使用" class="headerlink" title="6. 抽象类和抽象方法的使用"></a>6. 抽象类和抽象方法的使用</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_07.png" alt="抽象类的引入"></p>
<p>老大不在做事了，交给下面做</p>
<p>abstract关键字的使用<br>1.abstract:抽象的<br>2.abstract可以用来修饰的结构：类、方法</p>
<p>抽象 类不能实例化<br>3.abstract修饰类：抽象类<br>    &gt; 此类不能实例化<br>    &gt; 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）<br>    &gt; 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p>
<ol start="4">
<li><p>abstract修饰方法：抽象方法<br>/ /抽象方法<br>Tpublic abstract void eat();</p>
<blockquote>
<p>抽象方法只有方法的声明，没有方法体<br>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。<br>若子类重写了父类中的所有的抽象方法后，此子类方可实例化<br>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p>
</blockquote>
<h2 id="6-7-抽象的应用场景"><a href="#6-7-抽象的应用场景" class="headerlink" title="6 -7 抽象的应用场景"></a>6 -7 抽象的应用场景</h2><p>提示必须进行方法的重写<br>抽象类是用来模型化那些父类无法确定全部实现，而是由其子类提供具体实现的对象的类。</p>
</li>
</ol>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_08.png" alt="抽象类的解决方案引入"></p>
<h2 id="8-abstract使用中的注意点"><a href="#8-abstract使用中的注意点" class="headerlink" title="8.abstract使用中的注意点"></a>8.abstract使用中的注意点</h2><p>abstract使用上的注意点：<br>1.abstract不能用来修饰：属性、构造器等结构</p>
<p>2.abstract不能用来修饰私有方法、静态方法、final的方法、final的类</p>
<h2 id="9-基本操作—抽象性的练习"><a href="#9-基本操作—抽象性的练习" class="headerlink" title="9. 基本操作—抽象性的练习"></a>9. 基本操作—抽象性的练习</h2><p>大四  过去</p>
<p>努力不一定成功  不努力一定不成功</p>
<p>问题 1：为什么抽象类不可以使用 final 关键字声明？<br>问题 2：一个抽象类中可以定义构造器 吗？  可以<br>问题 3：是否可以这样理解：抽象类就比普通多定义 了抽象方 法，除了不能直接 进行类的 实例化操作之外，并没有任何的不同?</p>
<p>编写一个 Employee Employee Employee 类，声明为抽象类，<br>包含如下三个 属性： name ，id ，salary。<br>提供必要的构造器和抽象方法： work()<br>对于 Manager Manager Manager 类来说，他既是员工还具有奖金 (bonus (bonus )的属性。<br>请使用继承的思想，设计CommonEmployee类和 Manager Manager类 ，要求中提供必要的方法进行属性访问。<br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_09.png" alt="抽象类题"><br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_10.png" alt="抽象类题"><br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/..%5CstudyNote_Pic%5Csgg%5Cday12%5C15_11.png" alt="抽象类题"><br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_13.png" alt="抽象类题"></p>
<h2 id="10-创建抽象类的匿名子类对象"><a href="#10-创建抽象类的匿名子类对象" class="headerlink" title="10.创建抽象类的匿名子类对象"></a>10.创建抽象类的匿名子类对象</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_14.png" alt="抽象类题"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_12.png" alt="匿名抽象的引入"></p>
<h4 id="匿名子类"><a href="#匿名子类" class="headerlink" title="匿名子类"></a>匿名子类</h4><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_15.png" alt="匿名抽象的引入"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_16.png" alt="匿名抽象的引入">   person 子类的重写</p>
<p>method(p)</p>
<p>匿名只用一次，省事，</p>
<p>懒得像这样，用一次new 一次对象</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_17.png" alt="匿名抽象的引入">q</p>
<p>最省事的匿名子类的匿名对象</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_18.png" alt="匿名抽象的引入"></p>
<p>能看懂别人写代码的意图就可以了</p>
<hr>
<h2 id="11-模板方法的设计模式及应用场景"><a href="#11-模板方法的设计模式及应用场景" class="headerlink" title="11. 模板方法的设计模式及应用场景"></a>11. 模板方法的设计模式及应用场景</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_19.png" alt="多态的应用"></p>
<p>多态的应用</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_20.png" alt="模板的使用案例"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 抽象类的应用：模板方法的设计模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		</span><br><span class="line">		SubTemplate t = <span class="keyword">new</span> SubTemplate();</span><br><span class="line">		</span><br><span class="line">		t.spendTime();</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>{</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span></span>{</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//像个钩子，具体执行时，挂哪个子类，就执行哪个子类的实现代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.code();<span class="comment">//不确定的部分、易变的部分 </span></span><br><span class="line">        </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"花费的时间为："</span> + (end - start));</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>{</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++){</span><br><span class="line">			<span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j &lt;= Math.sqrt(i);j++){</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(i % j == <span class="number">0</span>){</span><br><span class="line">					isFlag = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(isFlag){</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>模板方法</p>
<h2 id="12-抽象方法的课后练习"><a href="#12-抽象方法的课后练习" class="headerlink" title="12.抽象方法的课后练习"></a>12.抽象方法的课后练习</h2><h2 id="13-接口的理解"><a href="#13-接口的理解" class="headerlink" title="13.接口的理解"></a>13.接口的理解</h2><ul>
<li><p>一方面，有时必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</p>
</li>
<li><p>另一方面，有时必须从几个类中抽取出一-些共同的行为特征，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如:鼠标、键盘、打印机、扫描仪、摄像头、充电器、MP3机、手机、数码相机、移动硬盘等都支持USB连接。</p>
</li>
<li><p>接口就是规范，定义的是- -组规则，体现了现实世界中“如果你是/要..则必须能..”的思想。<code>继承是一个"是不是"的关系，而接口实现则是"能不能" 的关系。</code></p>
</li>
<li><p><code>接口的本质是契约，标准，规范，</code>就像我们的法律- -样。制定好后大家都要遵守。</p>
<p>if 要飞，必须实现 </p>
</li>
</ul>
<p>举例<br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_21.png" alt="接口的举例"></p>
<p>虚线 类和接口的关系<br>实现 is a的关系<br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_22.png" alt="接口的举例"></p>
<h2 id="14-接口的定义和引用"><a href="#14-接口的定义和引用" class="headerlink" title="14.接口的定义和引用"></a>14.接口的定义和引用</h2><p>接口的使用<br>1.接口使用interface来定义<br>2.Java中，接口和类是并列的两个结构<br>3.如何定义接口：定义接口中的成员<br>    3.1 JDK7及以前：只能定义全局常量和抽象方法<br>            &gt;全局常量：public static final的.但是书写时，可以省略不写<br>            &gt;抽象方法：public abstract的  可省略 publicabstract 的</p>
<pre><code>3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</code></pre><ol start="4">
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.<br>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化<br>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类<br><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_23.png" alt="接口的实现"><br>abstract class A{</p>
</li>
</ol>
<p>}</p>
<ol start="6">
<li><p>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性<br> 格式：class AA extends BB implements CC,DD,EE</p>
</li>
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
</ol>
<hr>
<ol start="8">
<li>接口的具体使用，体现多态性</li>
<li>接口，实际上可以看做是一种规范</li>
</ol>
<p>面试题：抽象类与接口有哪些异同？</p>
<h2 id="15-接口的多实现和接口的继承性（多态性的体现-接口和抽象类）"><a href="#15-接口的多实现和接口的继承性（多态性的体现-接口和抽象类）" class="headerlink" title="15.接口的多实现和接口的继承性（多态性的体现  接口和抽象类）"></a>15.接口的多实现和接口的继承性（多态性的体现  接口和抽象类）</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_24.png" alt="接口继承接口"></p>
<h2 id="16-实例演示接口是一种规范"><a href="#16-实例演示接口是一种规范" class="headerlink" title="16.实例演示接口是一种规范"></a>16.实例演示接口是一种规范</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_25.png" alt="实例演示接口是一种规范">不同的USB接口  传输速率不一样，不知道用途  ，定义了抽象方法</p>
<p>以后任何方法 都要接受规范</p>
<p>实现类的集合  就是驱动</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_26.png" alt="实例演示接口是一种规范"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_27.png" alt="实例演示接口是一种规范"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_28.png" alt="实例演示接口是一种规范"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_29.png" alt="实例演示接口是一种规范"></p>
<p>接口的使用</p>
<p>1.体现了接口的多态性</p>
<p>2.接口实际上定义了一种规范</p>
<p>3.开发中，体会面向接口编程</p>
<p>JDBC  如何操作数据库的规范</p>
<p>MySQL Driver 是接口实现类的集合  </p>
<p>面向接口的编程</p>
<p>项目的具体需求是多变的,我们必须以不变应万变才能从容开发,此处的”不变”就是”规范”。因此,我们开发项目往往都是面向接口编程?</p>
<p>接口的主要用途就是被实现类实现</p>
<h2 id="17-创建接口匿名实体类的对象"><a href="#17-创建接口匿名实体类的对象" class="headerlink" title="17.创建接口匿名实体类的对象"></a>17.创建接口匿名实体类的对象</h2><ol start="3">
<li><p>匿名实现类没有用所以用  new USB代替</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_30.png" alt="实例演示接口是一种规范"></p>
</li>
</ol>
<p>com.transferDate(phone)    phone 可以多次使用</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_31.png" alt="实例演示接口是一种规范"></p>
<p>没有名用父类对象名充当的 —&gt;    上面是匿名实现类</p>
<h2 id="18-接口的应用–-gt-代理模式"><a href="#18-接口的应用–-gt-代理模式" class="headerlink" title="18.接口的应用–>代理模式"></a>18.接口的应用–&gt;代理模式</h2><p>实用性为主</p>
<p>用着用着感觉  ，，还真是？</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_32.png" alt="代理模式">代理类    和  被代理类</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_33.png" alt="代理模式"></p>
<p>​    <img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_34.png" alt="代理模式"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接口的应用：代理模式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Server server = <span class="keyword">new</span> Server();</span><br><span class="line"><span class="comment">//		server.browse();</span></span><br><span class="line">		ProxyServer proxyServer = <span class="keyword">new</span> ProxyServer(server);</span><br><span class="line">		</span><br><span class="line">		proxyServer.browse();</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>{</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>{</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"真实的服务器访问网络"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> NetWork work;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork work)</span></span>{</span><br><span class="line">		<span class="keyword">this</span>.work = work;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"联网之前的检查工作"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>{</span><br><span class="line">		check();</span><br><span class="line">		</span><br><span class="line">		work.browse();</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_35.png" alt="代理模式应用场景"></p>
<p>上面静态代理类</p>
<h2 id="19-接口应用：工厂模式—-一个了解的例子"><a href="#19-接口应用：工厂模式—-一个了解的例子" class="headerlink" title="19.接口应用：工厂模式—  一个了解的例子"></a>19.接口应用：工厂模式—  一个了解的例子</h2><p>工厂模式:实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离<br>起来，达到提高灵活性的目的。小<br>其实设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维<br>护，解决方式就是一个“分工”。。<br>社会的发展也是这样，分工越来越细。小<br>原始社会的人:人什么都要会，自己种，自己打猎，自己织衣服，自己治病<br>现在的人:可以只会一样，其他都不会，只会Java也能活，不会做饭，不会开<br>车，不会…..</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_36.png" alt="无工厂模式"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_37.png" alt="无工厂模式1"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_38.png" alt="简单工厂模式"></p>
<p>只是创建者</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_39.png" alt="简单工厂模式  使用"></p>
<p>上面也叫静态工厂</p>
<hr>
<p>缺点:对于增加新产品，不修改代码的话，是无法扩展的。违反了开闭原则(对<br>扩展开放:对修改封闭)。</p>
<p>需要对现有代码进行修改</p>
<p>工厂方法模式</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_40.png" alt="工厂方法模式  使用"></p>
<p>抽象工厂     了解下就可以了  ，，主要是对接口的使用</p>
<p>接口和抽象类的对比</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_41.png" alt="工厂方法模式  使用"></p>
<h2 id="20-接口课后两道笔试题"><a href="#20-接口课后两道笔试题" class="headerlink" title="20. 接口课后两道笔试题"></a>20. 接口课后两道笔试题</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_42.png" alt="面试题"></p>
<p>pX()   有误   编译有误，由于X是不确定的</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_44.png" alt="面试题"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_45.png" alt="面试题"></p>
<p>没毛病的</p>
<hr>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_43.png" alt="面试题 使用"></p>
<p>football   常量是final 静态的</p>
<h2 id="21-接口练习—-比较对象的大小"><a href="#21-接口练习—-比较对象的大小" class="headerlink" title="21.接口练习—-  比较对象的大小"></a>21.接口练习—-  比较对象的大小</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_46.png" alt="练习题"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_47.png" alt="练习题"></p>
<p>这个对象按照什么顺序排；对象是可排序的</p>
<h2 id="22-Java8中接口的新特性"><a href="#22-Java8中接口的新特性" class="headerlink" title="22.Java8中接口的新特性"></a>22.Java8中接口的新特性</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_48.png" alt="java8 的新特性"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_49.png" alt="java8 的新特性"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_50.png" alt="java8 的新特性的实现"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_51.png" alt="java8 的新特性的实现"></p>
<p>父类中重写 method3(sup)</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_52.png" alt="java8 的新特性的实现"></p>
<hr>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_53.png" alt="java8 的新特性的实现"></p>
<p>要是都没有方法体  或抽象的  确定有问题</p>
<p>public inteface CompareB{</p>
<p>default void method3(){</p>
<p>sout(“compre:上肢”)</p>
<p>}</p>
<p>}</p>
<p>解决办法:必须在实现类中重写此方法</p>
<hr>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_54.png" alt="java8 的新特性的实现"></p>
<p>目前静态方法非常少</p>
<h2 id="23-Java8-接口新特性的应用"><a href="#23-Java8-接口新特性的应用" class="headerlink" title="23.Java8 接口新特性的应用"></a>23.Java8 接口新特性的应用</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_55.png" alt="Java8 接口新特性的应用"></p>
<p>而第二种</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_56.png" alt="Java8 接口新特性的应用"></p>
<p>第三种   谁都没听    –&gt;第五个知识点</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_57.png" alt="Java8 接口新特性的应用"></p>
<p>关于接口的改进</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_58.png" alt="Java8 接口新特性的应用"></p>
<h2 id="24-内部类的分类-实际开发很少写-应用型差"><a href="#24-内部类的分类-实际开发很少写-应用型差" class="headerlink" title="24.内部类的分类(实际开发很少写  应用型差)"></a>24.内部类的分类(实际开发很少写  应用型差)</h2><ul>
<li>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部的完整的结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类。</li>
<li>在Java中，允许-一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</li>
<li>Innerclass–般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。<br>➢Innerclass的名字不能与包含它的外部类类名相同;</li>
<li>分类:成员内部类(static成员内部类和非static成员内部类)<br>局部内部类(不谈修饰符)、匿名内部类<br>person 与大脑  </li>
</ul>
<hr>
<p>1.Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类<br>2.内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)<br>3.成员内部类：<br>        一方面，作为外部类的成员：<br>        调用外部类的结构<br>        可以被static修饰<br>        可以被4种不同的权限修饰<br>        另一方面，作为一个类：<br>         类内可以定义属性、方法、构造器等<br>        可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承<br>        可以被abstract修饰</p>
<p>4.关注如下的3个问题<br>  4.1 如何实例化成员内部类的对象<br>  4.2 如何在成员内部类中区分调用外部类的结构<br>  4.3 开发中局部内部类的使用  见《InnerClassTest1.java》</p>
<p>局部内部类</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_59.png" alt="局部内部类"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_60.png" alt="成员内部类"></p>
<h2 id="25-成员内部类的特点"><a href="#25-成员内部类的特点" class="headerlink" title="25.成员内部类的特点"></a>25.成员内部类的特点</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_59.png" alt="局部内部类"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_61.png" alt="成员内部类"></p>
<h2 id="26-如何实例化成员内部类"><a href="#26-如何实例化成员内部类" class="headerlink" title="26. 如何实例化成员内部类"></a>26. 如何实例化成员内部类</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_62.png" alt=" 如何实例化成员内部类"></p>
<h2 id="27-成员内部类中调用外部类的结构"><a href="#27-成员内部类中调用外部类的结构" class="headerlink" title="27. 成员内部类中调用外部类的结构"></a>27. 成员内部类中调用外部类的结构</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_63.png" alt=" 如何实例化成员内部类"></p>
<h2 id="28-开发中局部内部类的使用"><a href="#28-开发中局部内部类的使用" class="headerlink" title="28.开发中局部内部类的使用"></a>28.开发中局部内部类的使用</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_64.png" alt=" 开发中局部内部类的使用"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia-bu-1/15_65.png" alt=" 开发中局部内部类的使用"></p>
<p>能看懂就可以  自己定义内部类不多</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(下)</title>
    <url>/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1. 每日一考"></a>1. 每日一考</h2><p>向上转型就是多态<br>1.如何实现向下转型?需要注意什么问题?如何解决此问题?<br>Person p = new Man();<br>使用强转符: ()<br>Man m = (Man)p;<br>可能ClassCastException异常。<br>使用instanceof在进行向下转型前判断。<br>if(p instanceof Man){<br>Man m = (Man)p;<br>}</p>
<ol start="2">
<li>==和equals()有何区别?</li>
</ol>
<p>目前我要是过来咱们做什么项目，需要我参与做什么，项目架构  什么技术<br>先描述，开发中怎么用</p>
<ol start="3">
<li>class User{4<br>String name;<br>int age;e<br>//重写其equals()方法。<br>if(obj == this){<br>return true;<br>}<br>if(obj instanceof User){<br>User u = (User)obj;<br>return this . age== u.age &amp;&amp; this . name . equals(u. name);<br>}<br>return false;<br>}</li>
</ol>
<p>}</p>
<p>4.写出8种基本数据类型及其对应的包装类。</p>
<p>integer<br>character<br>  IF<br>5.基本数据类型、包装类与String三者之间如何转换。<br>基本数据类型、包装类  自动装箱<br>基本数据类型、包装类–》 String: valueOf()<br>String–》 基本数据类型 、包装类 parseInt(String s)</p>
<h2 id="2-复习-多态性"><a href="#2-复习-多态性" class="headerlink" title="2. 复习  多态性"></a>2. 复习  多态性</h2><p>7.关于向.上转型与向下转型:<br>7.1向上转型: 多态<br>7.2向下转型:<br>7.2.1为什么使用向下转型:<br>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法?使用向下转型。<br>7.2.2如何实现向下转型:<br>使用强制类型转换符。()<br>7.2.3使用时的注意点:<br>①使用强转时，可能出现ClassCastException的异常。<br>②为了避免在向下转型时出现ClassCastException的异常， 我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false,不进行向下转型。</p>
<p>7.2.4 instanceof的使用:<br>①a instanceof A:判断对象a是否是类A的实例。如果是，返回true; 如果不是，返回false.<br>②如果a instanceof  A返回true,则a instanceof B也返回true.其中， 类B是类A的父类。<br>③要求a所属的类与类A必须是子类和父类的关系，否则编译错误。<br>8.面试题:<br>8.1谈谈你对多态性的理解?  想实例  怎么用<br>代码的通用性<br>①实现代码的通用性。<br>②object类中定义的public boolean equals(Object obj){}<br>JDBC:使用java程序操作(获取数据库连接、CRUD数据库(sql db2 oracle )<br>③抽象类、接口的使用肯定体现了多态性。 (抽象类、接口不能实例化)</p>
<p>8.2多态是编译时行为还是运行时行为?<br>运行时行为</p>
<h2 id="3-object-类及其内部方法"><a href="#3-object-类及其内部方法" class="headerlink" title="3. object 类及其内部方法"></a>3. object 类及其内部方法</h2><ol>
<li>java.lang.Object类的说明</li>
</ol>
<p>java. lang . object类</p>
<ol>
<li>object类是所有Java类的根父类<br>2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java . lang. object类</li>
<li>object类中的功能(属性、方法)就具有通用性。<br>属性:无<br>方法: equals() / toString() / getClass() /hashCode() / clone() / finalize( )<br>wait()、notify()、 notifyA1l( )</li>
<li>Object类只声明了一个空参的构造器</li>
</ol>
<p>2.equals()方法<br>2.1 equals()的使用:</p>
<p>1.是一个方法，而非运算符<br>2.只能适用于引用数据类型<br>3.object类中equals()的定义:<br>public boolean equals (object obi)<br>{<br>return (this == obi);<br>}<br>说明:object类中定义的equals()和==的作用是相同的:比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体<br>4.像String、 Date、 File、 包装类等都重写了object类中的equals()方法。 重写以后，比较的不是<br>两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。<br>5.通常情况下，我们自定义的类如果使用equals()的话， 也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对object类中的equals()进行重写.<br>重写的原则:比较两个对象的实体内容是否相同.</p>
<p>2.2如何重写equals()<br>2.2.1手动重写举例:<br>int age;<br>//重写其equals()方法<br>public boolean equals(Object obj){<br>if(obj == this){<br>return true;<br>}<br>if(obj instancec User){<br>User u = (User )obj;<br>return this.age == u.age &amp;&amp; this .name. equals(u. name) ;<br>return false;<br>}<br>}</p>
<p>2.2.2开发中如何实现:<br>2.3回顾==运算符的使用:<br>==:运算符<br>1.可以使用在基本数据类型变量和引用数据类型变量中<br>2.如果比较的是基本数据类型变量:比较两个变量保存的数据是否相等。(不一 定类型要相同)<br>如果比较的是引用数据类型变量:比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实<br>体  补充: == 符号使用时，必须保证符号左右两边的变量类型一致。</p>
<ol start="3">
<li>toString()方法<br>3.1 toString()的使用:<br>1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString() I</li>
</ol>
<p>/ /关于toString()<br>@Test<br>public void test3(){<br>String s = “abc”;<br>s = nu11;<br>System. out . println(s);//null   有保护机制<br>System. out. println(“<strong>*****</strong>);<br>System. out . println(s. toString( ));/ /出现NullPointerException<br>}</p>
<ol start="2">
<li>object类 中toString()的定义:<br>public String toString() {<br>return getClass(). getName() + “@” + Integer . toHexString(hashCode());<br>}<br>3.像String、 Date、 File、 包装类等都重写了object类中的toString()方法，使得在调用对象的toString()时，返回”实体内容”信息<br>4.自定义类也可以重写toString()方法， 当调用此方法时，返回对象的”实体内容”<br>3.2如何重写toString()<br>V/自动实现<br>@Override<br>public String toString() {<br>return “Customer[ name=” + name +”，age=” + age +<br>“]”;</li>
</ol>
<p>4.面试题:<br>①final、 finally、 finalize的区别?<br>②==和equals()区别</p>
<h2 id="4-单元测试方法与包装类"><a href="#4-单元测试方法与包装类" class="headerlink" title="4. 单元测试方法与包装类"></a>4. 单元测试方法与包装类</h2><p> Java中的JUnit单元测试<br>步骤:<br>1.中当前工程-右键择: build path - add libraries - JUnit 4一下一步<br>2.创建Java类，进行单元测试。<br>此时的Java类要求:<code>①此类是public的@此类提 供公共的无参的构造器</code><br>3.此类中声明单元测试方法。<br>此时的单元测试方法:<code>方法的权限是public,没返回值，没形参</code><br>4.此单元测试方法.上需要声明注解: @Test,并在单 元测试类中导入: import org. junit. Test;<br>5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。<br>6.写完代码以后，左键双击单元测试方法名，右键: run<br>as一JUnit Test<br>说明:<br>1.如果执行结果没任何异常:绿条<br>2.如果执行结果出现异常:红条</p>
<p>###包装类<br>1.为什么要有包装类(或封装类)<br>为了使基本数据类型的变量具有类的特征，引入包装类。</p>
<p>2.基本数据类型与对应的包装类:<br>表格<br>3.需要掌握的类型间的转换: (基本数据类型、包装类、String)   看图<br>基本数据类型&lt;—&gt;包装类: JDK 5.0新特性:自动装箱与自动拆箱<br>基本数据类型、包装类—&gt;String:调用String重载的value0f(Xxx xxx)<br>String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)<br>注意:转换时，可能会报NumberFormatException| I</p>
<p>简易版:<br>应用场景举例:<br>①Vector类中关于添加元素，只定义了形参为0bject类型的方法:<br>v.addElement(Object obj); //基 本数据类型–&gt;包装类–&gt;使用多态</p>
<h2 id="5-static-关键字的引入"><a href="#5-static-关键字的引入" class="headerlink" title="5.static 关键字的引入"></a>5.static 关键字的引入</h2><p>当我们编写一个类时，其实就是在描述对象的属性和行为而并没有产生质上 的对象，只有通过 new new关键字才会产生出对象， 这时系统分配内存空间给关键字才会产生出对象， 这时系统分配内存空间给其方法才可以供外部调用。我们有时候希望无论是否产生了对象或多少对象的情况下， <code>某些特定的数据在内存空间里只有一份</code> ，例如所有的中国人都个 国家名称，每一个中人都共享这不必在的实例对象都单独分配一个用于代表国家名称的 变量 。<br>由于每造一个有个chinese—&gt;大家共享的</p>
<h2 id="6-静态变量和实例变量的对比"><a href="#6-静态变量和实例变量的对比" class="headerlink" title="6.静态变量和实例变量的对比"></a>6.静态变量和实例变量的对比</h2><p>1.static:静态的<br>2.static可以用来修饰：属性、方法、代码块、内部类<br>3.使用static修饰属性：静态变量（或类变量）<br>    3.1 属性，按是否使用static修饰，又分为：静态属性vs 非静态属性(实例变量)</p>
<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。<br>3.2 static修饰属性的其他说明：<pre><code>① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用</code></pre>② 静态变量的加载要早于对象的创建。<br>③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。<br>④        类变量    实例变量<br>类        yes        no<br>对象        yes        yes<br>3.3 静态属性举例：System.out; Math.PI;<br>4.使用static修饰方法：静态方法<pre><code>① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用
②            静态方法    非静态方法</code></pre> 类        yes        no<br> 对象        yes        yes<pre><code>③ 静态方法中，只能调用静态的方法或属性</code></pre> 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li>
</ul>
<ol start="5">
<li><p>static注意点：<br>5.1 在静态的方法内，不能使用this关键字、super关键字<br> 5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</p>
</li>
<li><p>开发中，如何确定一个属性是否要声明为static的？</p>
<blockquote>
<p>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。<br>类中的常量也常常声明为static<br> 开发中，如何确定一个方法是否要声明为static的  Math.PI</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>操作静态属性的方法，通常设置为static的<br>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</p>
</blockquote>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_01.png" alt="static 讲解"></p>
<h2 id="7-static修饰属性的其他说明"><a href="#7-static修饰属性的其他说明" class="headerlink" title="7.static修饰属性的其他说明"></a>7.static修饰属性的其他说明</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_02.png" alt="static 讲解"></p>
<h2 id="8-类变量和实例变量的内存解析"><a href="#8-类变量和实例变量的内存解析" class="headerlink" title="8.类变量和实例变量的内存解析"></a>8.类变量和实例变量的内存解析</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_03.png" alt="static 讲解"></p>
<h2 id="9-static-修饰方法"><a href="#9-static-修饰方法" class="headerlink" title="9.static 修饰方法"></a>9.static 修饰方法</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_04.png" alt="static 讲解"></p>
<p>静态方法只能调用静态属性和方法</p>
<p>生命的周期不够</p>
<p>类的加载 —– 类的结束</p>
<p>非静态和对象是同步的‘</p>
<p>静态和类是同步的</p>
<p>打比方，你可以给你爸借钱，当时不能给你儿子借钱</p>
<h2 id="10-判断属性或方法是否应该static"><a href="#10-判断属性或方法是否应该static" class="headerlink" title="10.判断属性或方法是否应该static"></a>10.判断属性或方法是否应该static</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_05.png" alt="static 讲解"></p>
<p>公共的部分  ，此例子中 利率和最小余额是static，大家公用的</p>
<p>工具类适当加static</p>
<h2 id="11-自定义ArrayUtil-工具类的优化"><a href="#11-自定义ArrayUtil-工具类的优化" class="headerlink" title="11.自定义ArrayUtil 工具类的优化"></a>11.自定义ArrayUtil 工具类的优化</h2><h2 id="12-static-应用举例"><a href="#12-static-应用举例" class="headerlink" title="12.static 应用举例"></a>12.static 应用举例</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_06.png" alt="static 练习"></p>
<p>共享  下一次 1002</p>
<p>把static 去掉  以后每次都一样</p>
<p>static 声明的属性被所有对象共享</p>
<p>total  创建圆的个数</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_07.png" alt="static 题"></p>
<h2 id="14-设计模式与单例设计模式-static-应用"><a href="#14-设计模式与单例设计模式-static-应用" class="headerlink" title="14.设计模式与单例设计模式(static 应用)"></a>14.设计模式与单例设计模式(static 应用)</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_08.png" alt="单例设计模式"></p>
<p>单例 —单独的一个实例–只想让类造一个对象</p>
<p>独立于语言</p>
<p>创建型模式,共5种:I方法模式、抽象工厂 模式、单例模式、 建造者模式、原型模式。<br>结构型模式，共7种:适配器模式、装饰器模式、代理模式、外观模式桥接模式、组合模式、享元模式。<br>行为型模式，共11种:策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>工作的时候看</p>
<p>大话设计模式—&gt;23种设计模式-&gt;深入浅出设计模式</p>
<h2 id="15-单例的恶汉式实现"><a href="#15-单例的恶汉式实现" class="headerlink" title="15.单例的恶汉式实现"></a>15.单例的恶汉式实现</h2><p>单例设计模式：</p>
<ol>
<li><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p>
</li>
<li><p>如何实现？<br>饿汉式  vs 懒汉式</p>
</li>
<li><p>区分饿汉式 和 懒汉式<br>饿汉式：    </p>
<pre><code>坏处：对象加载时间过长。
好处：饿汉式是线程安全的</code></pre><p>懒汉式：好处：延迟对象的创建。</p>
<pre><code>目前的写法坏处：线程不安全。---&gt;到多线程内容时，再修改</code></pre></li>
</ol>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_09.png" alt="4步单例设计模式"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_10.png" alt="4步单例设计模式"></p>
<h2 id="16-单例的懒汉式实现"><a href="#16-单例的懒汉式实现" class="headerlink" title="16.单例的懒汉式实现"></a>16.单例的懒汉式实现</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_11.png" alt="4步单例设计模式"></p>
<p>啥时候用啥时候造 懒——-不知道不给你造</p>
<p>饿一上来  就造好——-比较饿  上来就new </p>
<h2 id="17-懒汉式和恶汉式的区分"><a href="#17-懒汉式和恶汉式的区分" class="headerlink" title="17.懒汉式和恶汉式的区分"></a>17.懒汉式和恶汉式的区分</h2><p>有可能不用  ，占用内存空间 ，加载时间过长</p>
<p>恶汉式:加载时间过长</p>
<p>恶汉式    线程安全，买火车票  </p>
<p>笔试 线程安全。选择恶汉式</p>
<h2 id="18-单例模式的应用场景"><a href="#18-单例模式的应用场景" class="headerlink" title="18.单例模式的应用场景"></a>18.单例模式的应用场景</h2><ul>
<li><p>单例模式的优点:<br>由于单例模式只生成一个实例，<code>减少了系统性能开销</code>，当-一个对象的<br>产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可<br>以通过在应用启动时直接产生-一个单例对象，然后永久驻留内存的方<br>式来解决。</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_12.png" alt="单例设计模式举例"></p>
</li>
<li><p>应用场景</p>
</li>
</ul>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_13.png" alt="单例设计模式举例"></p>
<p>数据库  一个池子里面有10个  不够再扩充</p>
<h2 id="19-理解main-方法的语法"><a href="#19-理解main-方法的语法" class="headerlink" title="19.理解main()方法的语法"></a>19.理解main()方法的语法</h2><p>main()方法的使用说明：</p>
<ol>
<li>main()方法作为程序的入口</li>
<li>main()方法也是一个普通的静态方法</li>
<li>main()方法可以作为我们与控制台交互的方式。（之前：使用Scanner）</li>
<li>每个类可以写各自的main方法</li>
<li>静态里面调用静态</li>
</ol>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_14.png" alt="main入口 举例"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_15.png" alt="main 3 举例"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_16.png" alt="main  3 执行"></p>
<p>空格隔开</p>
<p>int num = Integer . parseInt(args[i]);<br>System. out . println(“ #####”+ num) ;|</p>
<p>加不加引号都可以，输入变量的时候</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_17.png" alt="main  3 执行"></p>
<p>运行的时候</p>
<h2 id="20-类中代码块结构的使用"><a href="#20-类中代码块结构的使用" class="headerlink" title="20.类中代码块结构的使用"></a>20.类中代码块结构的使用</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块.."></a>代码块..</h3><ol>
<li><p>代码块的作用：用来初始化类、对象</p>
</li>
<li><p>代码块如果有修饰的话，只能使用static.</p>
</li>
<li><p>分类：静态代码块  vs 非静态代码块</p>
<p>静态方法随着类的加载而加载，但是没有使用，没有通过 类.方法使用</p>
</li>
<li><p>静态代码块</p>
<blockquote>
<p>内部可以有输出语句<br>随着类的加载而执行,而且<code>只执行一次</code><br>作用：初始化类的信息<br>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br>静态代码块的执行要优先于非静态代码块的执行<br>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p>
</blockquote>
</li>
<li><p>非静态代码块</p>
<blockquote>
<p>内部可以有输出语句<br>随着对象的创建而执行<br><code>每创建一个对象，就执行一次非静态代码块</code><br>作用：可以在创建对象时，对对象的属性等进行初始化<br>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p>
</blockquote>
</li>
</ol>
<p>没有必要写多个代码块</p>
<h2 id="21-开发中代码块的使用举例"><a href="#21-开发中代码块的使用举例" class="headerlink" title="21.开发中代码块的使用举例"></a>21.开发中代码块的使用举例</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_18.png" alt="开发中代码块的使用举例"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_19.png" alt="开发中代码块的使用举例"></p>
<h2 id="22-代码块的课后练习"><a href="#22-代码块的课后练习" class="headerlink" title="22.代码块的课后练习"></a>22.代码块的课后练习</h2><p>构造模式  super()</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_20.png" alt="开发中代码块的使用举例"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_21.png" alt="开发中代码块的使用举例"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//总结：由父及子，静态先行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>{</span><br><span class="line">	<span class="keyword">static</span>{</span><br><span class="line">		System.out.println(<span class="string">"Root的静态初始化块"</span>);</span><br><span class="line">	}</span><br><span class="line">	{</span><br><span class="line">		System.out.println(<span class="string">"Root的普通初始化块"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">"Root的无参数的构造器"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>{</span><br><span class="line">	<span class="keyword">static</span>{</span><br><span class="line">		System.out.println(<span class="string">"Mid的静态初始化块"</span>);</span><br><span class="line">	}</span><br><span class="line">	{</span><br><span class="line">		System.out.println(<span class="string">"Mid的普通初始化块"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">"Mid的无参数的构造器"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>{</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		System.out.println(<span class="string">"Mid的带参数构造器，其参数值："</span></span><br><span class="line">			+ msg);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>{</span><br><span class="line">	<span class="keyword">static</span>{</span><br><span class="line">		System.out.println(<span class="string">"Leaf的静态初始化块"</span>);</span><br><span class="line">	}</span><br><span class="line">	{</span><br><span class="line">		System.out.println(<span class="string">"Leaf的普通初始化块"</span>);</span><br><span class="line">	}	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="string">"尚硅谷"</span>);</span><br><span class="line">		System.out.println(<span class="string">"Leaf的构造器"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">		<span class="keyword">new</span> Leaf(); </span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">new</span> Leaf();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>{</span><br><span class="line">	<span class="keyword">static</span> {</span><br><span class="line">		System.out.println(<span class="string">"11111111111"</span>);</span><br><span class="line">	}</span><br><span class="line">	{</span><br><span class="line">		System.out.println(<span class="string">"22222222222"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"33333333333"</span>);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>{</span><br><span class="line">	<span class="keyword">static</span> {</span><br><span class="line">		System.out.println(<span class="string">"44444444444"</span>);</span><br><span class="line">	}</span><br><span class="line">	{</span><br><span class="line">		System.out.println(<span class="string">"55555555555"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"66666666666"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{ <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">		System.out.println(<span class="string">"77777777777"</span>);</span><br><span class="line">		System.out.println(<span class="string">"************************"</span>);</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">"************************"</span>);</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">"************************"</span>);</span><br><span class="line">		<span class="keyword">new</span> Father();</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>111</p>
<p>444</p>
<p>777</p>
<p>***</p>
<p>22</p>
<p>33</p>
<p>55</p>
<p>66</p>
<h2 id="23-属性赋值的先后顺序"><a href="#23-属性赋值的先后顺序" class="headerlink" title="23.属性赋值的先后顺序"></a>23.属性赋值的先后顺序</h2><p>对属性可以赋值的位置：<br>①默认初始化<br>②显式初始化/⑤在代码块中赋值<br>③构造器中初始化<br>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p>
<p>执行的先后顺序：① - ② / ⑤ - ③ - ④</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Order order = <span class="keyword">new</span> Order();</span><br><span class="line">		System.out.println(order.orderId);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>{</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> orderId = <span class="number">3</span>;</span><br><span class="line">	{</span><br><span class="line">		orderId = <span class="number">4</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line">orderId=<span class="number">4</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">	{</span><br><span class="line">		orderId = <span class="number">4</span>;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> orderId = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">orderId=<span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="24-final修饰类和方法"><a href="#24-final修饰类和方法" class="headerlink" title="24.final修饰类和方法"></a>24.final修饰类和方法</h2><h3 id="6-4-final-关键字"><a href="#6-4-final-关键字" class="headerlink" title="6-4 final  关键字"></a>6-4 final  关键字</h3><p>final:最终的</p>
<ol>
<li>final可以用来修饰的结构：类、方法、变量</li>
<li>final 用来修饰一个类:此类不能被其他类所继承。<pre><code>比如：String类、System类、StringBuffer类</code></pre></li>
<li>final 用来修饰方法：表明此方法不可以被重写<br>比如：Object类中getClass();</li>
<li>final 用来修饰变量：此时的”变量”就称为是一个常量<pre><code>4.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化
4.2 final修饰局部变量：
   尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值
   以后，就只能在方法体内使用此形参，但不能进行重新赋值。</code></pre></li>
</ol>
<p> static final 用来修饰属性：全局常量</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_22.png" alt="final 修饰类"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_23.png" alt="final 修饰方法"></p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_24.png" alt="final 修饰常亮"></p>
<p>native  调用底层c语言和c++语言代码</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_25.png" alt="final 修饰常亮"></p>
<p>加载创建对象  核心?</p>
<p>每个人的常量不一样   用构造器赋值常量</p>
<p>赋值 可能还需要处理，放在代码块中就可以</p>
<h2 id="26-final-修饰局部变量"><a href="#26-final-修饰局部变量" class="headerlink" title="26. final 修饰局部变量"></a>26. final 修饰局部变量</h2><p>方法内修饰形参  或者构造器</p>
<p>形参调用的时候才会赋值</p>
<p>final修饰局部变量</p>
<p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_26.png" alt="final 修饰常亮"></p>
<p>接口属性都是 static final</p>
<p>平时用很少  final修饰方法</p>
<h2 id="27-final-课后练习"><a href="#27-final-课后练习" class="headerlink" title="27.final 课后练习"></a>27.final 课后练习</h2><p><img src="/2017/06/29/2016-06-29-mian-xiang-dui-xiang-xia/14_27.png" alt="final 修饰常亮">题目一 注释的对</p>
<p>题目二 第6行  对的   打比方    最后的妻子，但是她的属性是可以变得   //错误</p>
<p>重建了对象</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(中)补2</title>
    <url>/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/</url>
    <content><![CDATA[<h2 id="1-每日一问"><a href="#1-每日一问" class="headerlink" title="1.每日一问"></a>1.每日一问</h2><p>1.什么是多态性?什么是虚拟方法调用?<br>对象的多态性:父类的引用指向子类的对象。<br>Person p = new Man();<br>p.eat();<br>调用方法时，编译时看左边，运行时看右边。<br>先会写代码，后面慢慢来</p>
<p>2.一个类可以有几个直接父类?(一个 )一个父类可有多少个子类?子类能获取直接父类的父类中的结构吗?(可以)子类能否获取父类中private 权限的属性或方法?。(可以   getset 方法) 封装解决的能不能调的问题，继承性是能不能获取的问题<br>Ais B 是不是true  可继承</p>
<p>3.方法的重写(override/overwrite)的具体规则有哪些。(非static方法)<br>方法名，形参列表相同。<br>权限修饰符。<br>返回值w<br>抛出的异常</p>
<p>4.super调用构造器，有哪些具体的注意点<br>this(形参列表):本类重载的其它的构造器。<br>super(形参列表):调用父类中指定的构造器。<br>n n-11</p>
<p>5.在下面的代码结构中:使用关键字: this,super;方法的重 写;继承;<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_01.png" alt="题"></p>
<h2 id="2-重写与super"><a href="#2-重写与super" class="headerlink" title="2.重写与super"></a>2.重写与super</h2><h3 id="debug-调试"><a href="#debug-调试" class="headerlink" title="debug 调试"></a>debug 调试</h3><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_02.png" alt="debug 调试"></p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>1.什么是方法的重写(override或overwrite)?  (父类的方法不适合子类)<br>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。<br>2.应用:</p>
<p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际<br>执行的是子类重写父类的方法。</p>
<p>3.举例:<br>cylinder</p>
<p>4.重写的规则:<br>方法的声明:权限修饰符 返回值类型 方法名 (形参列表) throws 异常的类型{<br>//方法体<br>约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法<br>②子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同<br>2子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符<br>事</p>
<blockquote>
<p>特殊情况:子类不能重写父类中声明为private权限的方法<br>③返回值类型:<br>父类被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void<br>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类<br>父类被重写的方法的返回值类型是基本数据类型(比如: double)， 则子类重写的方法的返回值类型必须是相<br>同的基本数据类型(必须也是double)<br>日子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型(具体放到异常处理时候讲)<br>子类和父类中的同名同参数的方法要么都声明为非static的(考虑重写，要么都声明为static的(不是重写).</p>
</blockquote>
<p>5.面试题:<br>区分方法的重写和重载?<br>重载  ，可以在同一个类中可以使用相同方法名和形参列表不同相同相同方法，彼此之间构成重载，<br>构造器可以重载<br>动态绑定</p>
<p>答:<br>①二者的概念:<br>②重载和重写的具体规则<br>③重载:不表现为多 态性。<br>重写:表现为多态性。<br>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它石的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同參数的方法。<br>所以:对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为早绑定或静态绑定”;而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定或动态绑定”。引用一句Bruce Eckel的话:“不要犯傻，如果它不是晚绑定，它就不是多态。”</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>1.super关键字可以理解为: 父类的<br>2.可以用来调用的结构:<br>属性、方法、构造器</p>
<p>3.super调用属性、方法:<br>3.1我们可以在子类的方法或构造器中。通过使用”super展性”或“super .方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”superA”<br>3.2特殊情况:当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。<br>3.3特殊情况:当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</p>
<p>4.super调用构造器:</p>
<p>4.1我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器<br>4.2 “super(形参 列表)”的使用，必须声明在子类构造器的首行!<br>4.3我们在类的构造器中，针对于”this(形参列表)”或” super(形参列表)”只能二一，不能同时出现<br>4.4在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的<br>in构造器: super()<br>4.5在类的多个构造器中，至少-一个类的构造器中使用了”super(形参列表)”， 调用父类中的构造器</p>
<p>渐渐领悟</p>
<h2 id="3-子类对象实例化过程及多态性"><a href="#3-子类对象实例化过程及多态性" class="headerlink" title="3.子类对象实例化过程及多态性"></a>3.子类对象实例化过程及多态性</h2><p>1.从结果上看:继承性</p>
<blockquote>
<p>子类继承父类以后，就获取了父类中声明的属性或方法。<br>创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</p>
</blockquote>
<p>2.从过程上看:<br>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，<br>进而调用父类的父类的构造器，… 直到调用了java. lang . object类中空参的构造器为止。<br>正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑<br>进行调用。<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_03.png" alt="从过程上看"></p>
<p>3.强调说明<br>为什么super(… )或this(..)调用语句只能作为构造器中的第- - -句出现?</p>
<p>无论通过哪个构造器创建子类对象，需要保证先初始化父类。<br>目的:当子类继承父类后，“继承”父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化。</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_04.png" alt="强调说明"></p>
<h3 id="多调性的理解"><a href="#多调性的理解" class="headerlink" title="多调性的理解"></a>多调性的理解</h3><p>1.多态性的理解:<br>可以理解为一个事物的多种形态。</p>
<p>2.何为多态性:<br>对象的多态性:父类的引用指向子类的对象(或子类的对象赋给父类的引用)<br>举例:<br>Person p = new Man();<br>objlect obj = new Date();<br>3.多态性的使用: 虚拟方法调用<br>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际<br>执行的是子类重写父类的方法。<br>总结:编译，看左边;运行，看右边。<br>4.多态性的使用前提:<br>①类的继承关系②方法的重写<br>5.多态性的应用举例:<br>猫<br>狗<br>6.多态性使用的注意点:<br>对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边</p>
<h2 id="4-向下转型的使用"><a href="#4-向下转型的使用" class="headerlink" title="4. 向下转型的使用"></a>4. 向下转型的使用</h2><p>/ /不能调用子类所特有的方法、属性:编译时，p2是Person类型。<br>p2. earnMoney();<br>//有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致<br>/ /编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p>
<p>/ /如何才能调用子类特有的属性和方法?<br>/ /向下转型:使用强制类型转换符。<br>Man m1 = (Man)p2;<br>m1. earnMoney(); |<br>m1. isSmoking = true;</p>
<p>有可能转不成功<br>Woman w1=(Woman)p2;<br>w1. goShopping();<br>p2是男的  你把他误以为女的</p>
<p>/ /使用强转时，可能出现ClassCast Exception的异常。<br>Woman W1 = (Woman)p2;<br>w1. goShopping();</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_05.png" alt="向下转型图解"><br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_06.png" alt="向下转型图解"></p>
<h2 id="5-instanceof-关键字的使用"><a href="#5-instanceof-关键字的使用" class="headerlink" title="5.instanceof 关键字的使用"></a>5.instanceof 关键字的使用</h2><h3 id="instanceof关键字的使用"><a href="#instanceof关键字的使用" class="headerlink" title="instanceof关键字的使用"></a>instanceof关键字的使用</h3><ul>
<li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false</li>
<li>使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先 进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</li>
<li>如果 a instanceof A返回true,则 a instanceof B也返回true.   父类放着也对<br>其中，类B是类A的父类。</li>
</ul>
<p>Person p2=new Man();</p>
<ul>
<li><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_07.png" alt="instanceof 使用"></li>
</ul>
<h2 id="6-向下转型的几个常用问题"><a href="#6-向下转型的几个常用问题" class="headerlink" title="6.向下转型的几个常用问题"></a>6.向下转型的几个常用问题</h2><p>//练习:<br>, /问题一:编译时通过，运行时不通过<br>//举例一:<br>Person p3 = new Woman( ) ;<br>Man m3 = (Man)p3;<br>/ /举例二:<br>Person p4 = new Person( ) ;<br>Man m4<br>= (Man)p4;<br>/ /问题二:编译通过，运行时也通过<br>object obj = new Woman( );<br>Person p = (Person)obj;<br>/ /问题三:编译不通过<br>Man m5 = new Woman();<br>String str = new Date();<br>开发中向下转型用的比较少</p>
<h2 id="7-多态练习—调用属性和方法"><a href="#7-多态练习—调用属性和方法" class="headerlink" title="7.多态练习—调用属性和方法"></a>7.多态练习—调用属性和方法</h2><p>引用类型是地址值</p>
<ul>
<li><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_08.png" alt="instanceof 使用"></li>
</ul>
<p>开发中不要定义同名的</p>
<p>1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，<br>系统将不可能把父类里的方法转移到子类中。编译看左边 运行看右边<br>2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，<br>这个实例变量依然不可能覆盖父类中定义的实例变量，编译运行都看左边</p>
<h2 id="8-9-基本操作–多态性"><a href="#8-9-基本操作–多态性" class="headerlink" title="8-9.基本操作–多态性"></a>8-9.基本操作–多态性</h2><p>各种图形的面积  可以利用多态来实现   求面积</p>
<p>重写父类中的面积公式</p>
<p>sub-1</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_09.png" alt="instanceof 使用"></p>
<p>认为是重写   sub_1</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_10.png" alt="instanceof 使用"></p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_11.png" alt="instanceof 使用"></p>
<p>确定的优先调用</p>
<h2 id="11-object-类的使用"><a href="#11-object-类的使用" class="headerlink" title="11 object 类的使用"></a>11 object 类的使用</h2><p>5.7 object 类的使用</p>
<ul>
<li><p>Object类是所有Java类的根父类</p>
<p>Order order = new Order( ) ;<br>System. out . println(order .getClass() . getSuperclass());</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类<br>为java.lang.Object类<br>public class Person {<br>}<br>等价于:<br>public class Person extends Object {<br>}</p>
</li>
<li><p>例: method(Object obj){.. } /可以接收任何类作为其参数<br>Person o=new Person();<br>method(0);</p>
</li>
</ul>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_12.png" alt="object的方法"></p>
<p>java.lang.Object类<br>  1.Object类是所有Java类的根父类<br>  2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类<br>  3.Object类中的功能(属性、方法)就具有通用性。<br>      属性：无<br>   方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()<br>      wait() 、 notify()、notifyAll()</p>
<ol start="4">
<li>Object类只声明了一个空参的构造器</li>
</ol>
<p>clone 复制对象   </p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_13.png" alt="clone的使用"></p>
<p>finalize()  垃圾回收期</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_14.png" alt="垃圾回收器的使用"></p>
<p>  面试题：<br>  final、finally、finalize的区别？</p>
<p>关键字前面2个</p>
<p>finalize 方法名</p>
<h2 id="12-运算符的回顾"><a href="#12-运算符的回顾" class="headerlink" title="12. ==运算符的回顾"></a>12. ==运算符的回顾</h2><h2 id="面试题-和equals-的区别"><a href="#面试题-和equals-的区别" class="headerlink" title="面试题:==和equals()的区别"></a>面试题:==和equals()的区别</h2><p>一、回顾 == 的使用：<br>  == ：运算符</p>
<ol>
<li>可以使用在基本数据类型变量和引用数据类型变量中    10=10.0   char c=10 10=10</li>
<li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 自动类型提升<br>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">补充： == 符号使用时，必须保证符号左右两边的变量类型一致。</span><br></pre></td></tr></tbody></table></figure>

<p>  二、equals()方法的使用：</p>
<ol>
<li>是一个方法，而非运算符</li>
<li>只能适用于引用数据类型</li>
<li>Object类中equals()的定义：<br>public boolean equals(Object obj) {<pre><code>return (this == obj);</code></pre>  }<br>说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
<li>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是<br>两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</li>
<li>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们<br>就需要对Object类中的equals()进行重写.<br>重写的原则：比较两个对象的实体内容是否相同.</li>
</ol>
<p>—-ppt</p>
<ul>
<li>==:<ul>
<li>基本类型比较值:只要两个变量的值相等，即为true。<br>int a=5; if(a==6)..}</li>
<li>引用类型比较引用(是否指向同一个对象):只有指向同一个对象时，==才<br>返回true。<br>Person p1 =new Person();<br>Person p2=new Person();<br>if (p1==p2)…}<ul>
<li>用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本<br>数据类型除外)，否则编译出错</li>
</ul>
</li>
</ul>
</li>
<li>equals();所有类都继承了Object,也就获得了equals()方法。还可以重写。<br>➢只能比较引用类型，其作用与“卜=”相同,比较是否指向同一个对象。<br>➢格式:obj1.equals(obj2)</li>
<li>特例:当用equals()方法进行比较时，对类File、String、 Date 及包装类.<br>(Wrapper Class)来说，是比较类型及内容而不考虑引用的是否是同一个对<br>象;<br>➢原因:在这些类中重写了Object类的equals()方法。</li>
<li>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都<br>相等</li>
</ul>
<h3 id="重写equals-方法的原则"><a href="#重写equals-方法的原则" class="headerlink" title="重写equals()方法的原则."></a>重写equals()方法的原则.</h3><ul>
<li>对称性:如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是“true”</li>
<li>自反性: x.equals(x)必须返回是“true</li>
<li>传递性:如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”<br>那么z.equals(x)也应该返回是“true”。</li>
<li>一 致性:如果x.equals(y)返回是“true” ，只要x和y内容一直不变， 不管你<br>重复x.equals(y)多少次，返回都是“true” 。</li>
<li>任何情况下，x.equal(null)， 永远返回是“false<br>x.equals(和x不同类型的对象)永远返回是“false<br>”</li>
<li>从我面试的反馈，85%的求职者“理直气壮”的回答错误…<br>1.==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型<br>就是比较内存地址<br>2.equals的话， 它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也<br>是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中<br>用的比较多，久而久之，形成了equals是比较值的错误观点。<br>3.具体要看自定义类里有没有重写Object的equals方法来判断。<br>4通常情况下，重写equals方法， 会比较类中的相应属性是否都相等。</li>
</ul>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_15.png" alt="字符串比较地址值"></p>
<h2 id="13-equals-的使用"><a href="#13-equals-的使用" class="headerlink" title="13.equals()的使用"></a>13.equals()的使用</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_16.png" alt="string 进行过重写"><br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_17.png" alt="date进行过重写"></p>
<h2 id="14-重写equals-方法"><a href="#14-重写equals-方法" class="headerlink" title="14.重写equals() 方法"></a>14.重写equals() 方法</h2><p>找例子   String 重写equals  源代码</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_18.png" alt="自定义equals()"></p>
<p>字符串等引用类型   equals()</p>
<p>方法2</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_19.png" alt="自定义equals()"></p>
<h3 id="自动生成-General-代码自动生成"><a href="#自动生成-General-代码自动生成" class="headerlink" title="自动生成   General  代码自动生成"></a>自动生成   General  代码自动生成</h3><p>逻辑性更强</p>
<h2 id="15-总结-与equals"><a href="#15-总结-与equals" class="headerlink" title="15. 总结==与equals()"></a>15. 总结==与equals()</h2><h2 id="16-equals-方法的练习"><a href="#16-equals-方法的练习" class="headerlink" title="16.equals 方法的练习"></a>16.equals 方法的练习</h2><p>对象之间不能用 ==  因为new的会改变地址  ，==比较的是地址</p>
<blockquote>
<p>自定义的类也要重写equals ，当在子类中需要的时候</p>
</blockquote>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_20.png" alt="重写equals()注意"></p>
<h2 id="17-toString-的使用"><a href="#17-toString-的使用" class="headerlink" title="17.toString()的使用"></a>17.toString()的使用</h2><p>  Object类中toString()的使用：<br>  1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString()<br>  2.Object类中toString()的定义：<br>    public String toString() {<br>        return getClass().getName() + “@” + Integer.toHexString(hashCode());<br>     }<br>  3.像String、Date、File、包装类等都重写了Object类中的toString()方法。<br>     使得在调用对象的toString()时，返回”实体内容”信息</p>
<p>  4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
<p>自定义 手动<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_21.png" alt="重写equals()注意"></p>
<p>系统生成</p>
<h2 id="19-objetc类的练习"><a href="#19-objetc类的练习" class="headerlink" title="19 objetc类的练习"></a>19 objetc类的练习</h2><p>if(obj instanceof Circcle){</p>
<p>Circle c=(Circle)obj;</p>
<p>return this.radius==c.radius;</p>
<p>}</p>
<h2 id="20-单元测试方法的使用"><a href="#20-单元测试方法的使用" class="headerlink" title="20.单元测试方法的使用"></a>20.单元测试方法的使用</h2><p>新建类 JUnitTest.java</p>
<p>选中当前工程-&gt;右键build Path-&gt;add libraries-&gt;JUnit-&gt;finish</p>
<p> Java中的JUnit单元测试</p>
<p>  步骤：<br>  1.选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步<br>  2.创建Java类，进行单元测试。<br>    此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器<br>  3.此类中声明单元测试方法。<br>    此时的单元测试方法：方法的权限是public,没有返回值，没有形参</p>
<p>  4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p>
<p>  5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。<br>  6.写完代码以后，左键双击单元测试方法名，右键：run as -&gt; JUnit Test</p>
<p>  说明：<br>  1.如果执行结果没有任何异常：绿条<br>  2.如果执行结果出现异常：红条</p>
<p>把测试方法当成静态的了</p>
<p>真正开发</p>
<p>@test 导包就可以</p>
<h2 id="21-包装类的理解"><a href="#21-包装类的理解" class="headerlink" title="21.包装类的理解"></a>21.包装类的理解</h2><p>5.8 包装类的使用</p>
<ul>
<li>针对八种基本数据类型定义相应的引用类型一包装类(封装类)</li>
<li>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_22.png" alt="包装类"></li>
<li>基本数据类型包装成包装类的实例__装箱<ul>
<li>通过包装类的构造器实现:<br>int i= 500; Integer t = new Integer();</li>
<li>还可以通过字符串参数构造包装类对象:<br>Float f= new Float(“4. 56”);<br>Long I = new Long(“asdf” ); //NumberFormatException</li>
</ul>
</li>
<li>获得包装类对象中包装的基本类型变量–拆箱<br>-调用包装类的.xxxValue()方法:<br>boolean b = bObj .booleanValue();</li>
<li>JDK1.5之后，支持自动裝箱，自动拆箱。但类型必须匹配。</li>
<li>字符串转换成基本数据类型<ul>
<li>通过包装类的构造器实现:<br>int i = new Integer(“12”);</li>
<li>通过包装类的parseXxx(String s)静态方法:<br>Float f= Float.parseFloat(“12.1”);</li>
</ul>
</li>
<li>基本数据类型转换成字符串<ul>
<li>调用字符串重载的valueOf()方法: .<br>String fstr = String.valueOf(2.34f);</li>
<li>更直接的方式:<br>String intStr= 5 +“”</li>
</ul>
</li>
</ul>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_23.png" alt="包装类"></p>
<h2 id="22-基本数据类型转化为包装类"><a href="#22-基本数据类型转化为包装类" class="headerlink" title="22.基本数据类型转化为包装类"></a>22.基本数据类型转化为包装类</h2><p>包装类的使用<br>  1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征<br>  2.掌握的：基本数据类型、包装类、String三者之间的相互转换</p>
<p>//基本数据类型 —&gt;包装类：调用包装类的构造器</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_24.png" alt="包装类"></p>
<p>boolean isMale;</p>
<p>Boolean isFemale;  是个类</p>
<h2 id="23-包装类转化基本数据类型"><a href="#23-包装类转化基本数据类型" class="headerlink" title="23.包装类转化基本数据类型"></a>23.包装类转化基本数据类型</h2><p>​    //包装类—&gt;基本数据类型:调用包装类Xxx的xxxValue()</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void test2(){</span><br><span class="line">		Integer in1 = new Integer(12);</span><br><span class="line">		</span><br><span class="line">		int i1 = in1.intValue();</span><br><span class="line">		System.out.println(i1 + 1);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Float f1 = new Float(12.3);</span><br><span class="line">		float f2 = f1.floatValue();</span><br><span class="line">		System.out.println(f2 + 1);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="24-自动装箱和拆箱"><a href="#24-自动装箱和拆箱" class="headerlink" title="24.自动装箱和拆箱"></a>24.自动装箱和拆箱</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="comment">//  JDK 5.0 新特性：自动装箱 与自动拆箱</span></span><br><span class="line">	 /</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">//		int num1 = 10;</span></span><br><span class="line"><span class="comment">//		//基本数据类型--&gt;包装类的对象</span></span><br><span class="line"><span class="comment">//		method(num1);</span></span><br><span class="line"><span class="comment">//上面独立	</span></span><br><span class="line">		<span class="comment">//自动装箱：基本数据类型 ---&gt;包装类</span></span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">		Integer in1 = num2;<span class="comment">//自动装箱</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">		Boolean b2 = b1;<span class="comment">//自动装箱</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//自动拆箱：包装类---&gt;基本数据类型</span></span><br><span class="line">		System.out.println(in1.toString());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> num3 = in1;<span class="comment">//自动拆箱</span></span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>{</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="25-基本数据类型、包装类与String间的相互转化"><a href="#25-基本数据类型、包装类与String间的相互转化" class="headerlink" title="25.基本数据类型、包装类与String间的相互转化"></a>25.基本数据类型、包装类与String间的相互转化</h2><p>//基本数据类型、包装类—&gt;String类型：调用String重载的valueOf(Xxx xxx)<br>    @Test</p>
<p>​        </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//方式1：连接运算</span></span><br><span class="line">	String str1 = num1 + <span class="string">""</span>;</span><br><span class="line">	<span class="comment">//方式2：调用String的valueOf(Xxx xxx)</span></span><br><span class="line">	<span class="keyword">float</span> f1 = <span class="number">12.3f</span>;</span><br><span class="line">	String str2 = String.valueOf(f1);<span class="comment">//"12.3"</span></span><br><span class="line">	</span><br><span class="line">	Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);</span><br><span class="line">	String str3 = String.valueOf(d1);</span><br><span class="line">	System.out.println(str2);</span><br><span class="line">	System.out.println(str3);<span class="comment">//"12.4"</span></span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>// //String类型 —&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>{</span><br><span class="line">		String str1 = <span class="string">"123"</span>;</span><br><span class="line">		<span class="comment">//错误的情况：</span></span><br><span class="line"><span class="comment">//		int num1 = (int)str1;</span></span><br><span class="line"><span class="comment">//		Integer in1 = (Integer)str1;</span></span><br><span class="line">		<span class="comment">//可能会报NumberFormatException</span></span><br><span class="line">		<span class="keyword">int</span> num2 = Integer.parseInt(str1);</span><br><span class="line">		System.out.println(num2 + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		String str2 = <span class="string">"true1"</span>;  不是标准的<span class="keyword">true</span>  都是<span class="keyword">false</span></span><br><span class="line">		<span class="keyword">boolean</span> b1 = Boolean.parseBoolean(str2);</span><br><span class="line">		System.out.println(b1);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="26-包装类常见面试题"><a href="#26-包装类常见面试题" class="headerlink" title="26.包装类常见面试题"></a>26.包装类常见面试题</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_26.png" alt="包装类1-2"></p>
<p>第一题  1.0  由于类型提升，要求统一类型</p>
<p>第二题:  1   没有要求统一类型</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_25.png" alt="包装类面试题3"></p>
<p> false   地址</p>
<p>true</p>
<p>false  有个缓存数组 1-127   new 的</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_27.png" alt="包装类面试3 解答"></p>
<h2 id="27-包装类的练习"><a href="#27-包装类的练习" class="headerlink" title="27 包装类的练习"></a>27 包装类的练习</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_28.png" alt="包装类面试3 解答"></p>
<p>想放多少放多少</p>
<p>先写思路</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"> 练习</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级。</span></span><br><span class="line"><span class="comment">	提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。</span></span><br><span class="line"><span class="comment">	而向量类java.util.Vector可以根据需要动态伸缩。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	创建Vector对象：Vector v=new Vector();</span></span><br><span class="line"><span class="comment">	给向量添加元素：v.addElement(Object obj);   //obj必须是对象</span></span><br><span class="line"><span class="comment">	取出向量中的元素：Object  obj=v.elementAt(0);</span></span><br><span class="line"><span class="comment">	注意第一个元素的下标是0，返回值是Object类型的。</span></span><br><span class="line"><span class="comment">	计算向量的长度：v.size();</span></span><br><span class="line"><span class="comment">	若与最高分相差10分内：A等；20分内：B等；</span></span><br><span class="line"><span class="comment">	      30分内：C等；其它：D等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//1.实例化Scanner，用于从键盘获取学生成绩</span></span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.创建Vector对象：Vector v=new Vector();相当于原来的数组</span></span><br><span class="line">		Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.通过for(;;)或while(true)方式，给Vector中添加数组</span></span><br><span class="line">		<span class="keyword">int</span> maxScore = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;;){</span><br><span class="line">			System.out.println(<span class="string">"请输入学生成绩（以负数代表输入结束）"</span>);</span><br><span class="line">			<span class="keyword">int</span> score = scan.nextInt();</span><br><span class="line">			<span class="comment">//3.2 当输入是负数时，跳出循环</span></span><br><span class="line">			<span class="keyword">if</span>(score &lt; <span class="number">0</span>){</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(score &gt; <span class="number">100</span>){</span><br><span class="line">				System.out.println(<span class="string">"输入的数据非法，请重新输入"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">//3.1 添加操作：：v.addElement(Object obj)</span></span><br><span class="line">			<span class="comment">//jdk5.0之前：</span></span><br><span class="line"><span class="comment">//			Integer inScore = new Integer(score);</span></span><br><span class="line"><span class="comment">//			v.addElement(inScore);//多态</span></span><br><span class="line">			<span class="comment">//jdk5.0之后：</span></span><br><span class="line">			v.addElement(score);<span class="comment">//自动装箱</span></span><br><span class="line">			<span class="comment">//4.获取学生成绩的最大值</span></span><br><span class="line">			<span class="keyword">if</span>(maxScore &lt; score){</span><br><span class="line">				maxScore = score;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5.遍历Vector，得到每个学生的成绩，并与最大成绩比较，得到每个学生的等级。</span></span><br><span class="line">		<span class="keyword">char</span> level;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size();i++){</span><br><span class="line">			Object obj = v.elementAt(i);</span><br><span class="line">			<span class="comment">//jdk 5.0之前：</span></span><br><span class="line"><span class="comment">//			Integer inScore = (Integer)obj;</span></span><br><span class="line"><span class="comment">//			int score = inScore.intValue();</span></span><br><span class="line">			<span class="comment">//jdk 5.0之后：</span></span><br><span class="line">			<span class="keyword">int</span> score = (<span class="keyword">int</span>)obj;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(maxScore - score &lt;= <span class="number">10</span>){</span><br><span class="line">				level = <span class="string">'A'</span>;</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">20</span>){</span><br><span class="line">				level = <span class="string">'B'</span>;</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">30</span>){</span><br><span class="line">				level = <span class="string">'C'</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				level = <span class="string">'D'</span>;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"student-"</span> + i + <span class="string">" score is "</span> + score + <span class="string">",level is "</span> + level);</span><br><span class="line">			</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(中)补1</title>
    <url>/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1. 每日一考"></a>1. 每日一考</h2><p>Arraylist 替换数组   可扩展长度—</p>
<h2 id="2-复习"><a href="#2-复习" class="headerlink" title="2.复习"></a>2.复习</h2><p>项目要求<br>1.看着一边写  一边理解，<br>2.自己去写  试着自己去完成，写不动看文档修饰  看源码  试着独立完成<br>全屏看，看完这个类以后 ，收起来，自己去写，写的时候写不动  看文档提示，再去写，<br>在写不动， 看源码  ，指导咋写 在手些   手写来，在接着写<br>3.</p>
<ol>
<li>至少独立完成一遍以 上的项目代码</li>
<li>积累完成项目的过程中常见的bug的调试<br>方式一‘<br>“硬”看，必要时，添加输出语句。<br>方式二：<br>Debug       逻辑  业务 </li>
<li>捋顺思路,强化逻辑</li>
<li>对象、数组等内存结构的解析</li>
<li>遵守编码的规范,标识符的命名规范等</li>
<li>在类前，方法前，方法内具体逻辑的实现步骤等添加必要的注释.<br>文档注释<br>逻辑步骤： 单行和多行注释</li>
</ol>
<h2 id="3-继承性"><a href="#3-继承性" class="headerlink" title="3.继承性"></a>3.继承性</h2><ol>
<li>为什么要有类的继承性? (继承性的好处)<br>①减少了代码的冗余，提高代码复用性<br>②便于功能的扩展<br>③为之后多态性的使用，提供了前提<br>图示:<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_01.png" alt="继承性复习"></li>
<li>继承性的格式:</li>
</ol>
<p>class A extends B{ }<br>A:子类、派生类、subclass .<br>B:父类、超类、基类、superclass</p>
<ol start="3">
<li>子类继承父类以后有哪些不同?</li>
</ol>
<p>3.1体现: 一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。<br>*特别的， 父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。<br>3.2子类继承父类以后，还可以声明自己特有的属性或方法:实现功能的拓展。<br>子类和父类的关系，不同于子集和集合的关系。<br>extends:延展、扩展</p>
<ol start="4">
<li>Java中继承性的说明</li>
</ol>
<p>1.一个类可以被多个子类继承。<br>2.Java中类的单继承性:一个类只能有一个父类<br>3.子父类是相对的概念。<br>4.子类直接继承的父类，称为:直接父类。间接继承的父类称为:间接父类<br>5.子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</p>
<p>图示:<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_02.png" alt="继承性的说明"></p>
<ol start="5">
<li>java. lang . object类的理解<br>1.如果我们没显式的声明一个类的父类的话，则此类继承于java.1ang . object类<br>2.所的java类(除java.1ang. object类之外都直接或间接的继承于java. lang. object类<br>3.意味着，所的java类具有java. lang. object类声明的功能。</li>
</ol>
<h2 id="4-5-继承性的练习，基本操作（练习）"><a href="#4-5-继承性的练习，基本操作（练习）" class="headerlink" title="4-5. 继承性的练习，基本操作（练习）"></a>4-5. 继承性的练习，基本操作（练习）</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_03.png" alt="练习"><br>紫色的箭头表示继承</p>
<h2 id="6-7Eclipse-Debug的使用"><a href="#6-7Eclipse-Debug的使用" class="headerlink" title="6-7Eclipse Debug的使用"></a>6-7Eclipse Debug的使用</h2><ol>
<li><h3 id="System-out-println-适合小项目"><a href="#System-out-println-适合小项目" class="headerlink" title="System.out.println(). 适合小项目"></a>System.out.println(). 适合小项目</h3></li>
</ol>
<h3 id="Eclipse-Debug调试"><a href="#Eclipse-Debug调试" class="headerlink" title="Eclipse - Debug调试"></a>Eclipse - Debug调试</h3><p> 1.设置断点   关卡<br> 2.debug as–》 java application<br> 3.操 做   –》进入透视图</p>
<p>f6   一行代i码 一行代码走—&gt;执行<br> f5  函数方法里面    到方法实现哪一行用<br>F7 跳出方法<br>resume  到下一个断点<br>进入t<br>drop into  方法的初始部分<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_04.png" alt="F5的说明"></p>
<h2 id="8-解决Debug中step-into功能失灵问题"><a href="#8-解决Debug中step-into功能失灵问题" class="headerlink" title="8.解决Debug中step into功能失灵问题"></a>8.解决Debug中step into功能失灵问题</h2><p>配置debug Configuration<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_05.png" alt="配置debug Configuration"><br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_06.png" alt="配置debug Configuration2"></p>
<h2 id="9-方法重写的理解"><a href="#9-方法重写的理解" class="headerlink" title="9.方法重写的理解"></a>9.方法重写的理解</h2><h3 id="override-overwrite"><a href="#override-overwrite" class="headerlink" title="override/overwrite"></a>override/overwrite</h3><ul>
<li>定义：在子类中可以根据需要对从父继承来的方法进行改造， 在程序执行时，子类的方法将覆盖父。 在程序执行时，子类的方法将覆盖父。</li>
<li>要求:<ul>
<li>子类重写的方法 必须 和父类被重写的方法 具有相同的 方法名称、 参数 列表</li>
<li>子类重写的方法返回值型 不能大于 父类被重写的方法返回值型</li>
<li>子类重写的方法使用访问权限 不能小于 父类被重写的方法访问权限<br>子类不能重写父中声明为 private 权限的方法</li>
<li>子类方法抛出的异常不能大于父被重写方法的异常</li>
</ul>
</li>
<li>注意<br>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为<br>static的(不是重写)。因为static方法是属于类的，子类无法覆盖父类的方法。</li>
</ul>
<hr>
<h3 id="1-重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作"><a href="#1-重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作" class="headerlink" title="1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作"></a>1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</h3><h3 id="2-应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。"><a href="#2-应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。" class="headerlink" title="2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。"></a>2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</h3><h2 id="10-方法重写的细节"><a href="#10-方法重写的细节" class="headerlink" title="10. 方法重写的细节"></a>10. 方法重写的细节</h2><h3 id="3-重写的规定："><a href="#3-重写的规定：" class="headerlink" title="3.重写的规定："></a>3.重写的规定：</h3><p>方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{<br>                //方法体<br>                      }<br>  约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法<br>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同<br>② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符   —-摊煎饼</p>
<h4 id="特殊情况：子类不能重写父类中声明为private权限的方法"><a href="#特殊情况：子类不能重写父类中声明为private权限的方法" class="headerlink" title="特殊情况：子类不能重写父类中声明为private权限的方法"></a>特殊情况：子类不能重写父类中声明为private权限的方法</h4><p>权限修饰  除了 private 都是重写<br>③ 返回值类型：<br>     &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void<br>       &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</p>
<blockquote>
<p>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)<br>④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）<br>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）  静态方法不能被重写，随着类的加载而加载<br>— 开发中直接粘贴就可以了—重写<br>wal+ alt+/</p>
</blockquote>
<h2 id="11-f方法重写的练习"><a href="#11-f方法重写的练习" class="headerlink" title="11 f方法重写的练习"></a>11 f方法重写的练习</h2><h2 id="12-测试4种不同的权限修饰"><a href="#12-测试4种不同的权限修饰" class="headerlink" title="12. 测试4种不同的权限修饰"></a>12. 测试4种不同的权限修饰</h2><p>/ /同一个包中的其他类，不可以调用Order类中私有的属性、方法<br>order.orderPrivate = 4;<br>order . methodPrivate( ) ;</p>
<p>//在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法<br>orderDefault = 3;<br>orderPrivate = 4;</p>
<p>//不同包下的普通类(非子类)要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法<br>order. orderPrivate = 2;<br>order. orderDefault = 3;<br>order. orderProtected = 4;</p>
<p>对于class的权限修饰只可以用public利和Idefault(缺省)。<br>public类可以在任意地方被访问。<br>default类只可以被同一个包内部的类访问。<br>用的最多是public   private</p>
<h2 id="13-super调用属性和方法"><a href="#13-super调用属性和方法" class="headerlink" title="13.super调用属性和方法"></a>13.super调用属性和方法</h2><h3 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h3><p>用父类被重写的属性和方法</p>
<p> 1.super理解为：父类的<br> 2.super可以用来调用：属性、方法、构造器<br> 3.super的使用：调用属性和方法<br>3.1 我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用 父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”   –子类没有<br>3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的 使用”super.属性”的方式，表明调用的是父类中声明的属性。   往上找<br>3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的 使用”super.方法”的方式，表明调用的是父类中被重写的方法。<br>4.super调用构造器<br> 4.1  我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器<br> 4.2 “super(形参列表)”的使用，必须声明在子类构造器的首行！<br> 4.3 我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现<br> 4.4 在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()<br> 4.5 在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p>
<p>输出结果是一样的<br>由于子类中没有age ，只有父类有<br>System. out . println(“name = “ + this.name + “，age = “ + super.age);</p>
<h2 id="14-super调用构造器"><a href="#14-super调用构造器" class="headerlink" title="14. super调用构造器"></a>14. super调用构造器</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_07.png" alt="super 生成构造器"><br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_08.png" alt="super 调用构造器"></p>
<h2 id="15-子类对象实例化的全过程"><a href="#15-子类对象实例化的全过程" class="headerlink" title="15.子类对象实例化的全过程"></a>15.子类对象实例化的全过程</h2><h4 id="5-5子类对象实例化的过程-为什么能用？"><a href="#5-5子类对象实例化的过程-为什么能用？" class="headerlink" title="5.5子类对象实例化的过程   为什么能用？"></a>5.5子类对象实例化的过程   为什么能用？</h4><ol>
<li>从结果上来看：（继承性）<br>子类继承父类以后，就获取了父类中声明的属性或方法。<br> 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。</li>
<li>从过程上来看：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">		当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...</span><br><span class="line"> 直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。</span><br><span class="line">明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_09.png" alt="子类对象实例化的过程"><br>子类 间接或直接调用父类构造器</p>
<h2 id="16-继承和super练习"><a href="#16-继承和super练习" class="headerlink" title="16 继承和super练习"></a>16 继承和super练习</h2><p>银行</p>
<h2 id="17-多态性的使用"><a href="#17-多态性的使用" class="headerlink" title="17.多态性的使用"></a>17.多态性的使用</h2><ul>
<li>多态性，是面向对象中最重要的概念 ，在Java 中的体现:<br>对象 的多态性：父类的引用指向子对象 <ul>
<li>可以 直接应用在抽象类和接口上</li>
</ul>
</li>
<li>Java引用变量有两个类型:<code>编译时类型和运行时类型</code>。编译时类型由声明<br>该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简<br>称: <code>编译时，看左边;运行时，看右边</code>。<ul>
<li>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphi sm)</li>
<li>多态情况下，“看左边”:看的是父类的引用(父类中不具备子类特有的方法)<br>“看右边”:看的是子类的对象(实际运行的是子类重写父类的方法)</li>
</ul>
</li>
<li>对象的多态一 - —-在Java中,子类的对象可以替代父类的对象使用<ul>
<li>一个变量只能有一种确定的数据类型</li>
<li>一个引用类型变量可能指向(引用)侈种不同类型的对象<br>Person p = new Student();<br>Object 0 = new Person();//Object类型的变量o，指向Person类型的对象<br>o = new Student(); //Object类型的变量o，指向Student类型的对象</li>
<li>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象:向上转型(upcasting)。</li>
</ul>
</li>
</ul>
<p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法:<br>Student m = new Student();<br>m.school =“pku”;  //合法,Student类有school成员变量<br>Person e = new Student();<br>e.school =“pku”; //非法,Person类没 有school成员变量<br>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编<br>译错误。</p>
<hr>
<p>1.理解多态性：可以理解为一个事物的多种形态。<br>2.何为多态性：<br>    对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p>
<ol start="3">
<li>多态的使用：虚拟方法调用<br>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。<br>总结：编译，看左边；运行，看右边。</li>
</ol>
<p>4.多态性的使用前提：  ① 类的继承关系  ② 方法的重写</p>
<p>5.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_10.png" alt="父类"><br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_11.png" alt="Man子类"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_12.png" alt="WoMan子类"></h2><p> 多态性的使用<br>  <img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_13.png" alt="test"></p>
<p>秘书给我找个人，他能吃东西，结果她找的是男人，</p>
<p>p2.earnMony();  不能使用 ，父类没有什么这个方法</p>
<p>编译生成什么类型就能点出什么类型，p2只调用person里面有的方法 </p>
<p>执行的时候是子类重写的  </p>
<p>p2.eat()  点到父类了</p>
<p>p2 是个person</p>
<h2 id="18-多态性的使用举例"><a href="#18-多态性的使用举例" class="headerlink" title="18.多态性的使用举例"></a>18.多态性的使用举例</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_14.png" alt="没有多态性的缺点"></p>
<p>有了多态性</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_15.png" alt="没有多态性的缺点"></p>
<p>没有多态性   会造成很多重载的方法</p>
<p>equals （子类类型）</p>
<p>举例</p>
<p>Driver  先建立连接 </p>
<p>三种数据库的连接</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_16.png" alt="重写的举例"></p>
<h2 id="19-多态性不适合于属性"><a href="#19-多态性不适合于属性" class="headerlink" title="19.多态性不适合于属性"></a>19.多态性不适合于属性</h2><h2 id="20-虚拟方法调用的再理解"><a href="#20-虚拟方法调用的再理解" class="headerlink" title="20 虚拟方法调用的再理解"></a>20 虚拟方法调用的再理解</h2><h3 id="虚拟方法调用-Virtual-Method-Invocation"><a href="#虚拟方法调用-Virtual-Method-Invocation" class="headerlink" title="虚拟方法调用(Virtual Method Invocation)"></a>虚拟方法调用(Virtual Method Invocation)</h3><ul>
<li><p>正常的方法调用<br>Person e = new Person();<br>e.getInfo();<br>Student e = new Student();<br>e.getlInfo();</p>
<ul>
<li>虚拟方法调用(多态情况下)<br>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父<br>类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法<br>确定的。<br>Person e = new Student();<br>e.getInfo();调 用Student类的getInfo()方法</li>
</ul>
</li>
<li><p>编译时类型和运行时类型<br>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类<br>的getlnfo()方法。一-动态绑定</p>
</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题:"></a>面试题:</h2><p>多态是编译时行为还是<code>运行时行为</code> 若随机呢?</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题：多态是编译时行为还是运行时行为？</span></span><br><span class="line"><span class="comment">//证明如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>  </span>{</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"animal eat food"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>{</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"cat eat fish"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>{</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"Dog eat bone"</span>);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>{</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"Sheep eat grass"</span>);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal  <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">		<span class="keyword">switch</span> (key) {</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Cat ();</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Dog ();</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Sheep ();</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> key = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(key);</span><br><span class="line"></span><br><span class="line">		Animal  animal = getInstance(key);</span><br><span class="line">		</span><br><span class="line">		animal.eat();</span><br><span class="line">		 </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_17.png" alt="虚拟方法调用的理解"></p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_18.png" alt="重载和重写的区别"></p>
<h3 id="多态小结"><a href="#多态小结" class="headerlink" title="多态小结"></a>多态小结</h3><ul>
<li>多态作用:<br>提高了代码的通用性，常称作接口重用</li>
<li>前提:<br>需要存在继承或者实现关系<br>有方法的重写</li>
<li>成员方法:<br>编译时:要查看引用变量所声明的类中是否有所调用的方法。<br>运行时:调用实际new的对象所属的类中的重写方法。</li>
<li>成员变量:<br>不具备多态性，只看引用变量所声明的类。</li>
</ul>
<hr>
<p>代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">animal</span></span>{</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">//4.吃骨头</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"吃骨头"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">animal</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"吃老鼠"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">duotai</span> </span>{</span><br><span class="line">	<span class="comment">//3.调用子类的相应方法 ,如传入new dog()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(animal d)</span> </span>{</span><br><span class="line">	d.eat();</span><br><span class="line">}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//1.类的实体化</span></span><br><span class="line">		duotai dt=<span class="keyword">new</span> duotai();</span><br><span class="line">		<span class="comment">//2.调dt里面的方法，传入子类 new 对象，调谁用谁</span></span><br><span class="line">		dt.func(<span class="keyword">new</span> dog());</span><br><span class="line">		dt.func(<span class="keyword">new</span> cat());</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="可以实现不同子类间的相同方法"><a href="#可以实现不同子类间的相同方法" class="headerlink" title="可以实现不同子类间的相同方法"></a>可以实现不同子类间的相同方法</h3><p>图解<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_19" alt=""></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(中)</title>
    <url>/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1. 每日一考"></a>1. 每日一考</h2><h3 id="1-构造器的作用是什么-使用中有哪些注意点-gt-3条"><a href="#1-构造器的作用是什么-使用中有哪些注意点-gt-3条" class="headerlink" title="1.构造器的作用是什么?使用中有哪些注意点(>=3条)"></a>1.构造器的作用是什么?使用中有哪些注意点(&gt;=3条)</h3><p>①创建对象②初始化对象结构</p>
<h3 id="2-关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，"><a href="#2-关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，" class="headerlink" title="2.关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，"></a>2.关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，</h3><p>默认初始化显式初始化构造器中初始化-对象方法或对象属性给属性赋值+</p>
<h3 id="3-this-关键字可以用来调用哪些结构，简单说明一下其使用。"><a href="#3-this-关键字可以用来调用哪些结构，简单说明一下其使用。" class="headerlink" title="3. this 关键字可以用来调用哪些结构，简单说明一下其使用。"></a>3. this 关键字可以用来调用哪些结构，简单说明一下其使用。</h3><p>this:属性、方法、构造器。<br>this:理解为当前对象，当前正在创建的对象。</p>
<h3 id="4-Java中目前学习涉及到的四种权限修饰符都有什么-并说明各自的权限范围。"><a href="#4-Java中目前学习涉及到的四种权限修饰符都有什么-并说明各自的权限范围。" class="headerlink" title="4. Java中目前学习涉及到的四种权限修饰符都有什么?并说明各自的权限范围。"></a>4. Java中目前学习涉及到的四种权限修饰符都有什么?并说明各自的权限范围。</h3><p>public protect 缺省 private</p>
<h3 id="5-创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。"><a href="#5-创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。" class="headerlink" title="5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。"></a>5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。</h3><h2 id="2-复习-封装性和构造器"><a href="#2-复习-封装性和构造器" class="headerlink" title="2.复习:封装性和构造器"></a>2.复习:封装性和构造器</h2><h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><ol>
<li>为什么要引入封装性?<br>我们程序设计追求“高内聚，低耦合”</li>
</ol>
<ul>
<li>高内聚:类的内部数据操作细节自己完成，不允许外部干涉;</li>
<li>低耦合:仅对外暴露少量的方法用于使用。</li>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</li>
</ul>
<ol start="2">
<li>问题引入:<br>当我们创建一一个类的对 象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。 (比如: setLegs()同时， 我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).<br>–&gt;此时，针对于属性就体现了封装性。|</li>
<li>封装性思想具体的代码体现:<br>体现一-:<br>体现一:将类的属性xxx私化(private),同时，提供公共的(public)方法来获取<br>(getXxx)和设置(setXxx)此属性的值<br>体现二:不对外暴露的私有的方法<br>体现三:单例模式(将构造器私有化)<br>体现四:如果不希望类在包外被调用，可以将类设置为缺省的。</li>
<li>Java规定的四种权限修饰符<br>4.1权限从小到大顺序为:<br>4.2具体的修饰范围:</li>
</ol>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>构造器(或构造方法) : Constructor<br>构造器的作用:1.创建对象 2.初始化对象的信息</li>
<li>使用说明:<br>1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器<br>2.定义构造器的格式:权限修饰符类名(形参 列表){}]|<br>3.一个类中定义的多个构造器，彼此构成重载<br>4.-旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器<br>5.一个类中，至少会有一个构造器。</li>
</ol>
<p>3.举例: </p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_01.png" alt="应用场景"></p>
<h3 id="属性赋值顺序"><a href="#属性赋值顺序" class="headerlink" title="属性赋值顺序"></a>属性赋值顺序</h3><p>默认初始化 赋值初始化 显性赋值初始化 |||| 构造器赋值  对象.方法</p>
<h3 id="JAVABean"><a href="#JAVABean" class="headerlink" title="JAVABean"></a>JAVABean</h3><p>所谓JavaBean，是指符合如下标准的Java类:</p>
<p>类是公共的</p>
<p>一个无参的公共的构造器</p>
<p>属性，且对应的get、set方法</p>
<h2 id="3-复习-关键字-this-package-import"><a href="#3-复习-关键字-this-package-import" class="headerlink" title="3.复习  关键字 this package import"></a>3.复习  关键字 this package import</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>1.可以调用的结构:<br>属性、方法:构造器</p>
<ol start="2">
<li>this调用属性、方法:<br>this理解为:前对象<br>或当前正在创建的对象<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_02.png" alt="说明"></li>
<li>this调用构造器:</li>
</ol>
<p>①我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器<br>②构造器中不能通过”this(形参列表)”方式调用自己<br>③如果一个类中有n个构造器，则最多有n - 1构造器中使用了”this(形参列表)”<br>④规定: “this(形参列表)”必须声明在当前构造器的首行<br>⑤构造器内部，最多只能声明一一个”this(形参列表)”， 用来调用其他的构造器</p>
<h3 id="package的使用"><a href="#package的使用" class="headerlink" title="package的使用"></a>package的使用</h3><p>1使用说明:<br>*1.为了更好的实现项目中类的管理，提供包的概念.<br>*2.使用package声 明类或接口所属的包，声明在源文件的首行<br>*3.包，属于标识符，遵循标识符的命名规则、规范(xxyyyzzz)、 “见名知意”<br>*<br>4.每”.”一次，就代表一层文件目录。<br>1.2 举例:<br>航运系统<br>MVC<br>1.3JDK中的主要包介绍:.</p>
<p>java都是写网页   写客户端很少用</p>
<h3 id="import-关键紫的使用"><a href="#import-关键紫的使用" class="headerlink" title="import 关键紫的使用"></a>import 关键紫的使用</h3><p>import:导入<br> 1.在源文件中显式的使用import结构导入指定包下的类、接口<br> 2.声明在包的声明和类的声明之间<br>3.如果需要导入多个结构，则并列写出即可<br> 4.可以使用”xxx. *”的方式，表示可以导入xxx包下的所结构<br>5.如果使用的类或接口是java.lang包下定义的，则可以省略import结构<br> 6.如果使用的类或接口是本包下定义的，则可以省略import结构<br> 7.如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。<br> 8.使用”xxx.*”方式表明可以调用Xxxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p>
<ol start="9">
<li>import static:导入指定类或接口中的静态结构:属性或方法。</li>
</ol>
<h2 id="4-6-Eclispe-常用快捷键"><a href="#4-6-Eclispe-常用快捷键" class="headerlink" title="4-6 Eclispe 常用快捷键"></a>4-6 Eclispe 常用快捷键</h2><p>Eclipse中的快捷键：<br>  1.补全代码的声明：alt + /<br>  <img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_02.png" alt="修改为都是提示的"><br>  abcdefg-z*<br>  2.快速修复: ctrl + 1<br>  3.批量导包：ctrl + shift + o<br>  4.使用单行注释：ctrl + /<br>  5.使用多行注释： ctrl + shift + /<br>  6.取消多行注释：ctrl + shift + <br>  修改快捷键    Prefer –keys<br>  7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up<br>  8.删除指定行的代码：ctrl + d<br>  9.上下移动代码：alt + up  或 alt + down<br>  10.切换到下一行代码空位：shift + enter<br>  11.切换到上一行代码空位：ctrl + shift + enter<br>  12.如何查看源码：ctrl + 选中指定的结构   或  ctrl + shift + t<br>  13.退回到前一个编辑的页面：alt + left<br>  14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right<br>  15.光标选中指定的类，查看继承树结构：ctrl + t    —–<br>  16.复制代码： ctrl + c<br>  17.撤销： ctrl + z<br>  18.反撤销： ctrl + y<br>  19.剪切：ctrl + x<br>  20.粘贴：ctrl + v<br>  21.保存： ctrl + s<br>  22.全选：ctrl + a<br>  23.格式化代码： ctrl + shift + f<br>  24.选中数行，整体往后移动：tab<br>  25.选中数行，整体往前移动：shift + tab<br>  26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o<br>  27.批量修改指定的变量名、方法名、类名等：alt + shift + r<br>  28.选中的结构的大小写的切换：变成大写： ctrl + shift + x<br>  29.选中的结构的大小写的切换：变成小写：ctrl + shift + y<br>  30.调出生成getter/setter/构造器等结构： alt + shift + s<br>  31.显示当前选择资源(工程 or 文件)的属性：alt + enter<br>  32.快速查找：参照选中的Word快速定位到下一个 ：ctrl + k</p>
<hr>
<p>用的少<br>  33.关闭当前窗口：ctrl + w<br>  34.关闭所有的窗口：ctrl + shift + w<br>  35.查看指定的结构使用过的地方：ctrl + alt + g<br>  36.查找与替换：ctrl + f<br>  37.最大化当前的View：ctrl + m<br>  38.直接定位到当前行的首位：home<br>  39.直接定位到当前行的末位：end</p>
<h2 id="7-bank-练习的难点"><a href="#7-bank-练习的难点" class="headerlink" title="7. bank 练习的难点"></a>7. bank 练习的难点</h2><p>  Accout</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_04.png" alt="属性声明自定义类型">  </p>
<p>关联关系<br>类型数组<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_05.png" alt="类型数组"><br>链式结构</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">private Customer[] customers;// 存放多个客户的数组</span><br><span class="line">private int numberOfCustomers;// 记录客户的个数</span><br><span class="line"></span><br><span class="line">public Bank() {</span><br><span class="line">	customers = new Customer[10];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 添加客户</span><br><span class="line">public void addCustomer(String f, String l) {</span><br><span class="line">	Customer cust = new Customer(f, l);</span><br><span class="line">	// customers[numberOfCustomers] = cust;</span><br><span class="line">	// numberOfCustomers++;</span><br><span class="line">	// 或</span><br><span class="line">	customers[numberOfCustomers++] = cust;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取客户的个数</span><br><span class="line">public int getNumOfCustomers() {</span><br><span class="line">	return numberOfCustomers;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取指定位置上的客户</span><br><span class="line">public Customer getCustomer(int index) {</span><br><span class="line">	// return customers[index];//可能报异常</span><br><span class="line">	if (index &gt;= 0 &amp;&amp; index &lt; numberOfCustomers) {</span><br><span class="line">		return customers[index];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	return null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-项目二-客户信息管理软件-功能演示"><a href="#8-项目二-客户信息管理软件-功能演示" class="headerlink" title="8..项目二 客户信息管理软件  功能演示"></a>8..项目二 客户信息管理软件  功能演示</h2><p>●模拟实现一个基于文本界面的《客户信息管理软件》<br>●进一步掌握编程技巧和调试技巧，熟悉面向对象编程;<br>●主要涉及以下知识点:<br>➢类结构的使用:属性、方法及构造器<br>➢对象的创建与使用<br>➢类的封装性<br>➢声明和使用数组<br>➢数组的插入、删除和替换<br>➢关键字的使用: this<br>结构.<br>com.ccut.p2<br>CMUtilityjava<br>Customerjava<br>CustomerLstjava<br>CustomerViewjava</p>
<h2 id="9-软件架构设计"><a href="#9-软件架构设计" class="headerlink" title="9. 软件架构设计"></a>9. 软件架构设计</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_06.png" alt="软件架构设计">  </p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_07.png" alt="软件架构设计"></p>
<h2 id="10-CMUtility工具类的介绍"><a href="#10-CMUtility工具类的介绍" class="headerlink" title="10.CMUtility工具类的介绍"></a>10.CMUtility工具类的介绍</h2><p>可用来方便地实现键盘访问</p>
<ul>
<li>public static char readMenuSelection()<br>用途：该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。</li>
<li>public static char readChar() 和 public static char readChar(char defaultValue)<br>用途：这两个方法功能相同，均从键盘读取一个字符，并将其作为方法的返回值。<br>参数： defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。（提示：此方法可在修改客户时调用）</li>
<li>public static int readInt() 和public static int readInt(int defaultValue)<br>用途：这两个方法功能相同，均从键盘读取一个长度不超过2位的   整数，并将其作为方法的返回值。<br>参数： defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</li>
<li>public static String readString(int limit)  和<br>public static String readString(int limit, String defaultValue)<br>用途：这两个方法功能相同，均从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。<br>参数：limit — 指定字符串的最大长度 <pre><code>defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</code></pre></li>
<li>public static char readConfirmSelection()<br>用途：从键盘读取‘Y’或’N’，并将其作为方法的返回值</li>
</ul>
<h2 id="11-Customer类的设计"><a href="#11-Customer类的设计" class="headerlink" title="11.Customer类的设计"></a>11.Customer类的设计</h2><p>2 .3 w行</p>
<h2 id="12-CustomerList类的设计"><a href="#12-CustomerList类的设计" class="headerlink" title="12.CustomerList类的设计"></a>12.CustomerList类的设计</h2><p>操作数组之前一定要初始化   在结构体里面<br>代码要有注释<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_08.png" alt="addCustomer"><br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_09.png" alt="注释"></p>
<h2 id="13-CustomerView的整体设计的构建"><a href="#13-CustomerView的整体设计的构建" class="headerlink" title="13.CustomerView的整体设计的构建"></a>13.CustomerView的整体设计的构建</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_10.png" alt="输入逻辑"></p>
<p>char a=‘1’；</p>
<h2 id="14-CustomerView-退出功能的实现"><a href="#14-CustomerView-退出功能的实现" class="headerlink" title="14.CustomerView 退出功能的实现"></a>14.CustomerView 退出功能的实现</h2><h2 id="15-CustomerView-客户列表的实现"><a href="#15-CustomerView-客户列表的实现" class="headerlink" title="15.CustomerView 客户列表的实现"></a>15.CustomerView 客户列表的实现</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_11.png" alt=" 客户列表的实现"></p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_12.png" alt="客户列表的实现"></p>
<h2 id="16-CustomerView-添加客户的实现"><a href="#16-CustomerView-添加客户的实现" class="headerlink" title="16.CustomerView 添加客户的实现"></a>16.CustomerView 添加客户的实现</h2><p>控制读取字符的长度  </p>
<h2 id="17-CustomerView-修改客户的实现"><a href="#17-CustomerView-修改客户的实现" class="headerlink" title="17.CustomerView 修改客户的实现"></a>17.CustomerView 修改客户的实现</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_13.png" alt=" 客户列表的实现"></p>
<p>找不到返回主页面</p>
<p>局部变量</p>
<h2 id="18-CustomerView-删除客户的实现"><a href="#18-CustomerView-删除客户的实现" class="headerlink" title="18.CustomerView 删除客户的实现"></a>18.CustomerView 删除客户的实现</h2><h2 id="19-独立写一下-收获很大-总结"><a href="#19-独立写一下-收获很大-总结" class="headerlink" title="19.独立写一下  收获很大   总结"></a>19.独立写一下  收获很大   总结</h2><p>认知能力</p>
<p>别停   听了一个月就死了   去写 去熟悉</p>
<p>写多就会了</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h2 id="20-继承性的理解"><a href="#20-继承性的理解" class="headerlink" title="20.继承性的理解"></a>20.继承性的理解</h2><h3 id="一、继承性的好处-why"><a href="#一、继承性的好处-why" class="headerlink" title="一、继承性的好处  why"></a>一、继承性的好处  why</h3><p>①减少了代码的冗余，提高代码的复用性<br>②便于功能的扩展<br>③为之后多态性的使用，提供了前提</p>
<h2 id="21-继承性的使用"><a href="#21-继承性的使用" class="headerlink" title="21.继承性的使用"></a>21.继承性的使用</h2><h3 id="二、继承性的格式："><a href="#二、继承性的格式：" class="headerlink" title="二、继承性的格式："></a>二、继承性的格式：</h3><p> class A extends B{}<br>  A:子类、派生类、subclass<br>  B:父类、超类、基类、superclass</p>
<p> 2.1体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。<br>       特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。不可以直接调<br>   只有因为封装性的影响，使得子类不能直接调用父类的结构而已。<br>2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。  —-自类更强大<br>  子类和父类的关系，不同于子集和集合的关系。<br>  extends：延展、扩展</p>
<h2 id="21-继承性的再说明"><a href="#21-继承性的再说明" class="headerlink" title="21.继承性的再说明"></a>21.继承性的再说明</h2><h3 id="三、Java中关于继承性的规定："><a href="#三、Java中关于继承性的规定：" class="headerlink" title="三、Java中关于继承性的规定："></a>三、Java中关于继承性的规定：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.一个类可以被多个子类继承。</span><br></pre></td></tr></tbody></table></figure>

<p>  2.Java中类的单继承性：一个类只能有一个父类<br>  3.子父类是相对的概念。<br>  4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类<br>  5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p>
<h2 id="23-Object类的理解"><a href="#23-Object类的理解" class="headerlink" title="23 Object类的理解"></a>23 Object类的理解</h2><h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><ol>
<li>如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li>
</ol>
<ul>
<li><ol start="2">
<li>所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</li>
</ol>
</li>
<li><ol start="3">
<li>意味着，所有的java类具有java.lang.Object类声明的功能。</li>
</ol>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(上)补2</title>
    <url>/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/</url>
    <content><![CDATA[<h2 id="1-每天一问"><a href="#1-每天一问" class="headerlink" title="1. 每天一问"></a>1. 每天一问</h2><ol>
<li>什么是方法的重载?<br>两同一不同”:同一个类、相同方法名;参数列表不同<br>如何调用确定的方法:方法名→参数列表。</li>
<li>说明Java方法中的参数传递机制的具体体现?<br>基本数据类型:数据值+<br>引用数据类型:地址值(含变量的数据类型)。<br>Person p1 = new Person( );<br>eat();age+<br>User u1 = p1;//编译错误<br>(逆向思维、反证法)<br>u1. eat()<br>u1.age</li>
<li>成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同?</li>
<li>谈谈return关键字的使用。<br>①结束方法<br>②针对于有返回值的方法，return +返回数据。</li>
<li>提供如下代码的内存解析。<ol>
<li>内存结构:栈(局部变量)、堆(new出来的结构:对象(非static成员变量)、数组)<br>2.变量:成员变量vs局部变量(方法内、方法形参、构造器内、构造器形参、代码块内) </li>
</ol>
</li>
</ol>
<hr>
<h2 id="1-2-复习-重载"><a href="#1-2-复习-重载" class="headerlink" title="1-2. 复习 重载"></a>1-2. 复习 重载</h2><ol>
<li>匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象<br>特点:匿名对象只能调用一次。<br>举例:<br>new Phone() . sendEmail();<br>new Phone( ) . playGame();<br>new Phone() .price = 1999;<br>new Phone() . showPrice();//0.0<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_01.png" alt="应用场景"></li>
<li>万事万物皆对象<br>3.方法的重载概念<br>定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参<br>数类型不同即可。<br>总结: “两同一不同”:同一个类、相同方法名；参数列表不同:参数个数不同，参数类型不同</li>
<li>构成重载的举例:<br>举例一: Arrays类中 重载的sort() / binarySearch(); PrintStream中 的println()<br>举例<br>/ /如下的4个方法构成了重载<br>public void getSum(int i,int j){<br>System. out. println(“1”);<br>public void getSum( double d1, double d2){<br>System . out . print1n(“2”);<br>}<br>public void getSum(String s， int i){<br>System. out . println(“3”);<br>}<br>public void getSum(int i,String s){<br>System. out . println(“4”);<br>}</li>
</ol>
<p>不构成重载的举例:<br>//如下的3个方法不能与上述4个方法构成重载<br>// public int getSum(int i,int j){<br>//<br>return 0;<br>// }<br>// public void getSum(int m,int n){<br>//<br>// }<br>I<br>// private void getSum(int i,int j){<br>//<br>// }<br>5.如何判断是否构成方法的重载?<br>严格按照定义判断:两同一不同。<br>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系!<br>6.如何确定类中某-一个方法的调用:<br>方法名—&gt;参数列表<br>面试题:方法的重载与重写的区别<br>throws \throw<br>String\StringBuffer\StringBuilder<br>Collection\Collections<br>final \finally\finalize</p>
<p>抽象类、接口<br>sleep()/wait( )</p>
<p>7.可变个数形参的方法</p>
<ul>
<li><p>使用说明</p>
<ul>
<li>1.jdk 5.0新增的内容</li>
<li>2.具体使用:<ul>
<li>2.1 可变个数形参的格式:数据类型… 变量名</li>
<li>2.2当调用可变个数形参的方法时，传入的参数个数可以是: 0个，1个,2个，</li>
<li>2.3可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</li>
<li>2.5可变个数形参在方法的形参中，必须声明在末尾</li>
<li>2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参。</li>
</ul>
</li>
</ul>
</li>
<li><p>举例说明</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_02.png" alt="举例说明"></p>
</li>
</ul>
<p>调用时</p>
<p>test. show( “he1lo”);<br>test. show( “hello”, “world”);<br>test. show();<br>test. show(new String[ ]{“AA”, “BB”, “CC”});</p>
<h2 id="3-值传递和递归方法"><a href="#3-值传递和递归方法" class="headerlink" title="3.值传递和递归方法"></a>3.值传递和递归方法</h2><ul>
<li>针对于方法内变量的赋值举例<br>规则 :<br>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。<br>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
<li>针对于方法的参数概念<ul>
<li>形参:方法定义时，声明的小括号内的参数<ul>
<li>实参:方法调用时，实际传递给形参的数据|</li>
</ul>
</li>
</ul>
</li>
<li>java中参数传递机制:   值传递<br>规则:<br>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。<br>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。<br>推广:<br>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。<br>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
</ul>
<p>String 只想常量方法区<br>  <img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_03.png" alt="关于string说明"><br>引用数据类型<br> <img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_04.png" alt="参数类型为引用数据类型"></p>
<ul>
<li>递归方法</li>
<li>定义<br>递归方法:一个方法体内调用它自身。</li>
<li>如何理解递归方法</li>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须<br>循环控制。<pre><code>- 递归一定要向己知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</code></pre></li>
<li>举例<br>//例1: 计算1-n之间所有自然数的和<br>public int getSum(int n) {//<br>if (n==1) {<br>return 1;<br>}else{<br>return n + getSum(n - 1);<br>}<br>}<br>面试题 <img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_05.png" alt="面试题"><br>面试题 <img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_06.png" alt="图解"></li>
</ul>
<hr>
<h2 id="4-封装性的引入"><a href="#4-封装性的引入" class="headerlink" title="4.封装性的引入"></a>4.封装性的引入</h2><p>IO  验证 和使用面向对象的过程，后面加深理解</p>
<p>面向对象特征之一: 封装与隐藏</p>
<ul>
<li>为什么需要封装？封装的作用和含义？<ul>
<li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内<br>部的结构吗？有必要碰电动机吗？</li>
<li>我要开车， …</li>
</ul>
</li>
<li>我们程序设计追求“高内聚，低耦合”。<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合 ： 仅对外暴露少量的方法用于使用。</li>
</ul>
</li>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说， <code>把该隐藏的隐藏起来，该暴露的暴露出来。 这就是封装性的设计思想。</code> </li>
</ul>
<p>代码<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_07.png" alt="封装性介绍"></p>
<p>若a.legs=-4  不符合常理</p>
<p>加入条件如下:<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_08.png" alt="封装性介绍加入条件"></p>
<p>让a.leg 不能被调用  private int leg；</p>
<h3 id="一、问题的引入："><a href="#一、问题的引入：" class="headerlink" title="一、问题的引入："></a>一、问题的引入：</h3><p>当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值,加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()）<br>同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private). –&gt;此时，针对于属性就体现了封装性。</p>
<h3 id="二、封装性的体现："><a href="#二、封装性的体现：" class="headerlink" title="二、封装性的体现："></a>二、封装性的体现：</h3><p> 我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p>
<p> 拓展：封装性的体现：① 如上  ② 不对外暴露的私有的方法  ③ 单例模式（构造器私有）   …</p>
<h3 id="三、封装性的体现，需要权限修饰符来配合。"><a href="#三、封装性的体现，需要权限修饰符来配合。" class="headerlink" title="三、封装性的体现，需要权限修饰符来配合。"></a>三、封装性的体现，需要权限修饰符来配合。</h3><p>1.Java规定的4种权限（从小到大排列）：private、缺省、protected 、public<br>2.4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类<br>3.具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类<br>修饰类的话，只能使用：缺省、public<br>总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。<br> 封装性的提现<br> public int getAge(){<br>        return age;<br>    }</p>
<h2 id="5-封装性的提现"><a href="#5-封装性的提现" class="headerlink" title="5.封装性的提现"></a>5.封装性的提现</h2><h2 id="6-四种权限修饰的理解"><a href="#6-四种权限修饰的理解" class="headerlink" title="6.四种权限修饰的理解"></a>6.四种权限修饰的理解</h2><ul>
<li>Java权限修饰符public、 protected、 (缺省)、 private置于类的成员定义前，<br>用来限定对象对该类成员的访问权限。<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_09.png" alt="4种权限修饰符"></li>
<li>对于class的权限修饰只可以用public和default(缺省)。<ul>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。</li>
</ul>
</li>
</ul>
<h2 id="7-四种权限修饰符的测试"><a href="#7-四种权限修饰符的测试" class="headerlink" title="7.四种权限修饰符的测试"></a>7.四种权限修饰符的测试</h2><p>权限的大小 打比方公司的秘密</p>
<h2 id="8-封装类的练习"><a href="#8-封装类的练习" class="headerlink" title="8.封装类的练习"></a>8.封装类的练习</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_10.png" alt="类图"></p>
<p>- 表示私有 </p>
<p>+ 表示public</p>
<h2 id="9-类的成员"><a href="#9-类的成员" class="headerlink" title="9.类的成员"></a>9.类的成员</h2><h3 id="类的成员之三：构造器-或构造方法"><a href="#类的成员之三：构造器-或构造方法" class="headerlink" title="类的成员之三：构造器(或构造方法)"></a>类的成员之三：构造器(或构造方法)</h3><ul>
<li>构造器的特征 <ul>
<li>它具有与类相同的名称</li>
<li>它不声明返回值类型。（与声明为void不同）</li>
<li>不能被static、 final、 synchronized、 abstract、 native修饰，不能有<br>return语句返回值 </li>
</ul>
</li>
<li>构造器的作用： <code>创建对象；给对象进行初始化</code><ul>
<li>如： Order o = new Order(); Person p = new Person(“Peter”,15);</li>
<li>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人” 的<br>构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自<br>动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们<br>要“洗澡”了</li>
</ul>
</li>
<li>语法格式：<br>修饰符 类名 (参数列表) {<br>初始化语句；<br>}</li>
<li>举例说明:<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_11.png" alt="构造器举例说明"></li>
<li>根据参数不同，构造器可以分为如下两类：<ul>
<li>隐式无参构造器（系统默认提供）</li>
<li>显式定义一个或多个构造器（无参、有参）</li>
</ul>
</li>
<li>注 意：<br>Java语言中，每个类都至少有一个构造器<br>默认构造器的修饰符与所属类的修饰符一致<br>一旦显式定义了构造器， 则系统不再提供默认构造器<br>一个类可以创建多个重载的构造器<br>父类的构造器不可被子类继承</li>
</ul>
<hr>
<p>构造器</p>
<p> construct：建设、建造。  construction:CCB    constructor:建设者</p>
<p>一、构造器的作用：<br> 1.创建对象   / /创建类的对象:new +构造器      构造器是一种独立的结构<br> 2.初始化对象的信息  —————</p>
<p>二、说明：<br> 1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器<br> 2.定义构造器的格式：权限修饰符  类名(形参列表){}<br> 3.一个类中定义的多个构造器，彼此构成重载<br> 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器(一旦结婚了，就不给饭吃了 )<br> 5.一个类中，至少会有一个构造器。</p>
<h2 id="10-构造器使用的细节说明"><a href="#10-构造器使用的细节说明" class="headerlink" title="10.构造器使用的细节说明"></a>10.构造器使用的细节说明</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_12.png" alt="构造器重载说明"></p>
<h2 id="11-12-构造器的练习-三角形的练习"><a href="#11-12-构造器的练习-三角形的练习" class="headerlink" title="11-12 .构造器的练习   三角形的练习"></a>11-12 .构造器的练习   三角形的练习</h2><h2 id="13-总结属性赋值的过程"><a href="#13-总结属性赋值的过程" class="headerlink" title="13 总结属性赋值的过程"></a>13 总结属性赋值的过程</h2><p>截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位<br>置，并指明赋值的先后顺序。</p>
<ul>
<li>赋值的位置:<br>①默认初始化 0.0<br>②显式初始化 1.0<br>③构造器中初始化       123 是一次性的<br>④通过“对象.属性“或“对象.方法”的方式赋值</li>
<li>赋值的先后顺序:<br>①.②-③-④</li>
</ul>
<h2 id="14-JavaBean的使用"><a href="#14-JavaBean的使用" class="headerlink" title="14. JavaBean的使用"></a>14. JavaBean的使用</h2><ul>
<li>JavaBean是一种Java语言写成的可重用组件。</li>
<li>所谓javaBean，是指符合如下标准的Java类：<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、 set方法</li>
<li>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以<br>用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP<br>页面、 Servlet、其他JavaBean、 applet程序或者应用来使用这些对象。用<br>户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关<br>心任何改变。    一个类就是一个jAVABean<br>—&gt;反射造对象</li>
</ul>
</li>
</ul>
<h2 id="15-UML类图"><a href="#15-UML类图" class="headerlink" title="15. UML类图"></a>15. UML类图</h2><p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_13.png" alt="UML说明"></p>
<h2 id="16-this调用属性和方法"><a href="#16-this调用属性和方法" class="headerlink" title="16. this调用属性和方法"></a>16. this调用属性和方法</h2><h3 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h3><ul>
<li>在Java中， this关键字比较难理解，它的作用和其词义很接近。<ul>
<li>它在方法内部使用，即这个方法所属对象的引用；</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
</li>
<li>this 可以调用类的属性、方法和构造器</li>
<li>什么时候使用this关键字呢？<ul>
<li>当在方法内需要用到调用该方法的对象时，就用this。<br>具体的：我们可以用this来区分<code>属性</code>和<code>局部变量</code>。<br>比如： this.name = name;</li>
</ul>
</li>
<li>使用this，调用属性、方法<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_14.png" alt="this 举例说明1"></li>
<li>说明<ul>
<li><ol>
<li>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添this，增强程序的阅读性。不过，通常我们都习惯省略this。</li>
</ol>
</li>
<li><ol start="2">
<li>当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量</li>
</ol>
</li>
<li>3.使用this访问属性和方法时，如果在本类中未找到，会从父类中查找</li>
<li>4.this可以作为一个类中构造器相互调用的特殊格式<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_15.png" alt="this 举例说明2"></li>
</ul>
</li>
<li>使用this调用本类的构造器<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_16.png" alt="this 举例说明3 this可以作为一个类中构造器相互调用的特殊格式 "></li>
<li>注意</li>
</ul>
<ol>
<li>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！</li>
<li>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</li>
<li>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”</li>
<li>“this(形参列表)”必须声明在类的构造器的首行！</li>
<li>在类的一个构造器中，最多只能声明一个”this(形参列表)</li>
</ol>
<hr>
<p>www    what(是什么) why(为什么要用) how.</p>
<p>代码中</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_17" alt="1587564642445"></p>
<h3 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h3><ol>
<li>this可以用来修饰、调用：属性、方法、构造器</li>
<li>this修饰属性和方法：<br>this理解为：当前对象  或 当前正在创建的对象 （构造器）<ul>
<li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
<li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
<li>this调用构造器<br>① 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器<br>② 构造器中不能通过”this(形参列表)”方式调用自己<br> ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”<br>④ 规定：”this(形参列表)”必须声明在当前构造器的首行<br>  ⑤ 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器</li>
</ol>
<h2 id="17-this调用构造器–减少冗余了"><a href="#17-this调用构造器–减少冗余了" class="headerlink" title="17.this调用构造器–减少冗余了"></a>17.this调用构造器–减少冗余了</h2><p>构造器里面调用构造器</p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_17.png" alt="this调用构造器"></p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_18.png" alt="1587564642445"></p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_19.png" alt="比较两个对象的大小"></p>
<h2 id="18-练习boyand-girl"><a href="#18-练习boyand-girl" class="headerlink" title="18 练习boyand girl"></a>18 练习boyand girl</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">()</span> </span>{</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(String name)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Girl girl)</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"我想娶"</span> + girl.getName());</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age &gt;= <span class="number">22</span>){</span><br><span class="line">			System.out.println(<span class="string">"你可以去合法登记结婚了！"</span>);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			System.out.println(<span class="string">"先多谈谈恋爱~~"</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">*-*-----------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Boy boy)</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"我想嫁给"</span> + boy.getName());</span><br><span class="line">		boy.marry(<span class="keyword">this</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span> 比较两个对象的大小</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> girl</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>  正数：当前对象大；  负数：当前对象小  ； 0：当前对象与形参对象相等</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Girl girl)</span></span>{</span><br><span class="line"><span class="comment">//		if(this.age &gt; girl.age){</span></span><br><span class="line"><span class="comment">//			return 1;</span></span><br><span class="line"><span class="comment">//		}else if(this.age &lt; girl.age){</span></span><br><span class="line"><span class="comment">//			return -1;</span></span><br><span class="line"><span class="comment">//		}else{</span></span><br><span class="line"><span class="comment">//			return 0;</span></span><br><span class="line"><span class="comment">//		}</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age - girl.age;</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line">-------------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyGirlTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		</span><br><span class="line">		Boy boy = <span class="keyword">new</span> Boy(<span class="string">"罗密欧"</span>, <span class="number">21</span>);</span><br><span class="line">		boy.shout();</span><br><span class="line">		</span><br><span class="line">		Girl girl = <span class="keyword">new</span> Girl(<span class="string">"朱丽叶"</span>, <span class="number">18</span>);</span><br><span class="line">		girl.marry(boy);</span><br><span class="line">		</span><br><span class="line">		Girl girl1 = <span class="keyword">new</span> Girl(<span class="string">"祝英台"</span>,<span class="number">19</span>);</span><br><span class="line">		<span class="keyword">int</span> compare = girl.compare(girl1);</span><br><span class="line">		<span class="keyword">if</span>(compare &gt; <span class="number">0</span>){</span><br><span class="line">			System.out.println(girl.getName() + <span class="string">"大"</span>);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(compare &lt; <span class="number">0</span>){</span><br><span class="line">			System.out.println(girl1.getName() + <span class="string">"大"</span>);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			System.out.println(<span class="string">"一样大"</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="19-练习Account"><a href="#19-练习Account" class="headerlink" title="19. 练习Account"></a>19. 练习Account</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//账号</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;<span class="comment">//余额</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> annualInterestRate;<span class="comment">//年利率</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> balance, <span class="keyword">double</span> annualInterestRate )</span></span>{</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">		<span class="keyword">this</span>.annualInterestRate = annualInterestRate;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> balance;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAnnualInterestRate</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> annualInterestRate;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnnualInterestRate</span><span class="params">(<span class="keyword">double</span> annualInterestRate)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.annualInterestRate = annualInterestRate;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span> <span class="params">(<span class="keyword">double</span> amount)</span></span>{<span class="comment">//取钱</span></span><br><span class="line">		<span class="keyword">if</span>(balance &lt; amount){</span><br><span class="line">			System.out.println(<span class="string">"余额不足，取款失败"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		balance -= amount;</span><br><span class="line">		System.out.println(<span class="string">"成功取出："</span> + amount);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span> <span class="params">(<span class="keyword">double</span> amount)</span></span>{<span class="comment">//存钱</span></span><br><span class="line">		<span class="keyword">if</span>(amount &gt; <span class="number">0</span>){</span><br><span class="line">			balance += amount;</span><br><span class="line">			System.out.println(<span class="string">"成功存入："</span> + amount);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String firstName;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> Account account;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String f,String l)</span></span>{</span><br><span class="line">		<span class="keyword">this</span>.firstName = f;</span><br><span class="line">		<span class="keyword">this</span>.lastName = l;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Account <span class="title">getAccount</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> account;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(Account account)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.account = account;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> firstName;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> lastName;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">----------</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 写一个测试程序。</span></span><br><span class="line"><span class="comment">（1）	创建一个Customer ，名字叫 Jane Smith, </span></span><br><span class="line"><span class="comment">他有一个账号为1000，余额为2000元，年利率为 1.23％ 的账户。</span></span><br><span class="line"><span class="comment">（2）	对Jane Smith操作。</span></span><br><span class="line"><span class="comment">存入 100 元，再取出960元。再取出2000元。</span></span><br><span class="line"><span class="comment">打印出Jane Smith 的基本信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成功存入 ：100.0</span></span><br><span class="line"><span class="comment">成功取出：960.0</span></span><br><span class="line"><span class="comment">余额不足，取款失败</span></span><br><span class="line"><span class="comment">Customer [Smith, Jane] has a account: id is 1000, </span></span><br><span class="line"><span class="comment">annualInterestRate is 1.23％, balance is 1140.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Customer cust = <span class="keyword">new</span> Customer(<span class="string">"Jane"</span>, <span class="string">"Smith"</span>);</span><br><span class="line">		</span><br><span class="line">		Account acct = <span class="keyword">new</span> Account(<span class="number">1000</span>, <span class="number">2000</span>, <span class="number">0.0123</span>);</span><br><span class="line">		</span><br><span class="line">		cust.setAccount(acct);</span><br><span class="line">		</span><br><span class="line">		cust.getAccount().deposit(<span class="number">100</span>);</span><br><span class="line">		cust.getAccount().withdraw(<span class="number">960</span>);</span><br><span class="line">		cust.getAccount().withdraw(<span class="number">2000</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Customer["</span> + cust.getLastName() + <span class="string">","</span> + cust.getFirstName() + </span><br><span class="line">				<span class="string">"] has a account: id is "</span> + cust.getAccount().getId() + <span class="string">",annualInterestRate is "</span>+</span><br><span class="line">		cust.getAccount().getAnnualInterestRate() * <span class="number">100</span> + <span class="string">"% ,balance is "</span> + cust.getAccount().getBalance());</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="20-练习对象数组"><a href="#20-练习对象数组" class="headerlink" title="20. 练习对象数组"></a>20. 练习对象数组</h2><p>每加顾客+1<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_20.png" alt="每加顾客+1"><br>或customers [ numberOfCustomers++] = cust;<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_21.png" alt="别忘记初始化"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> init_balance)</span></span>{</span><br><span class="line">		<span class="keyword">this</span>.balance = init_balance;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> balance;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amt)</span></span>{</span><br><span class="line">		<span class="keyword">if</span>(amt &gt; <span class="number">0</span>){</span><br><span class="line">			balance += amt;</span><br><span class="line">			System.out.println(<span class="string">"存钱成功"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>{</span><br><span class="line">		<span class="keyword">if</span>(balance &gt;= amt){</span><br><span class="line">			balance -= amt;</span><br><span class="line">			System.out.println(<span class="string">"取钱成功"</span>);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String firstName;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> Account account;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String f, String l)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.firstName = f;</span><br><span class="line">		<span class="keyword">this</span>.lastName = l;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Account <span class="title">getAccount</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> account;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(Account account)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.account = account;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> firstName;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> lastName;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Customer[] customers;<span class="comment">// 存放多个客户的数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> numberOfCustomers;<span class="comment">// 记录客户的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">()</span> </span>{</span><br><span class="line">		customers = <span class="keyword">new</span> Customer[<span class="number">10</span>];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加客户</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCustomer</span><span class="params">(String f, String l)</span> </span>{</span><br><span class="line">		Customer cust = <span class="keyword">new</span> Customer(f, l);</span><br><span class="line">		<span class="comment">// customers[numberOfCustomers] = cust;</span></span><br><span class="line">		<span class="comment">// numberOfCustomers++;</span></span><br><span class="line">		<span class="comment">// 或</span></span><br><span class="line">		customers[numberOfCustomers++] = cust;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取客户的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfCustomers</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> numberOfCustomers;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取指定位置上的客户</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">		<span class="comment">// return customers[index];//可能报异常</span></span><br><span class="line">		<span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; numberOfCustomers) {</span><br><span class="line">			<span class="keyword">return</span> customers[index];</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">/// -----</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank();		</span><br><span class="line">		bank.addCustomer(<span class="string">"Jane"</span>, <span class="string">"Smith"</span>);</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//连续操作</span></span><br><span class="line">		bank.getCustomer(<span class="number">0</span>).setAccount(<span class="keyword">new</span> Account(<span class="number">2000</span>));</span><br><span class="line">		</span><br><span class="line">		bank.getCustomer(<span class="number">0</span>).getAccount().withdraw(<span class="number">500</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> balance = bank.getCustomer(<span class="number">0</span>).getAccount().getBalance();</span><br><span class="line">		System.out.println(<span class="string">"客户："</span> + bank.getCustomer(<span class="number">0</span>).getFirstName() + <span class="string">"的账户余额为："</span> + balance);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"***********************"</span>);</span><br><span class="line">		bank.addCustomer(<span class="string">"万里"</span>, <span class="string">"杨"</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"银行客户的个数为："</span> + bank.getNumOfCustomers());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">-------</span><br></pre></td></tr></tbody></table></figure>

<h2 id="21-package关键字的使用"><a href="#21-package关键字的使用" class="headerlink" title="21.package关键字的使用"></a>21.package关键字的使用</h2><ul>
<li><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在<br>的包。 (若缺省该语句，则指定为无名包)。它的格式为：<br>package 顶层包名.子包名</p>
</li>
<li><p>包对应于文件系统的目录， package语句中，用 “.” 来指明包(目录)的层次；</p>
</li>
<li><p>包通常用小写单词标识。通常使用所在公司域名的倒置： com.ccut.xxx</p>
</li>
<li><p>包的作用：</p>
<ul>
<li>包帮助管理大型软件系统： 将功能相近的类划分到同一个包中。 比如： MVC的设计模式</li>
<li>包可以包含类和子包， 划分项目层次， 便于管理</li>
<li>解决类命名冲突的问题</li>
<li>控制访问权限</li>
</ul>
<hr>
</li>
</ul>
<h4 id="一、package关键字的使用"><a href="#一、package关键字的使用" class="headerlink" title="一、package关键字的使用"></a>一、package关键字的使用</h4><p>1.为了更好的实现项目中类的管理，提供包的概念<br>2.使用package声明类或接口所属的包，声明在源文件的首行<br>3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”<br>4.每”.”一次，就代表一层文件目录。<br> 补充：同一个包下，不能命名同名的接口、类。<br>     不同的包下，可以命名同名的接口、类。<br>JDK中主要的包介绍<br><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_22.png" alt="JDK中主要的包介绍"></p>
<h2 id="22-MVC设计模式的理解"><a href="#22-MVC设计模式的理解" class="headerlink" title="22.MVC设计模式的理解"></a>22.MVC设计模式的理解</h2><p>​      MVC是常用的设计模式之一，将整个程序分为三个层次： <code>视图模型层，控制器层，与数据模型层</code>。 这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性 </p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_23.png" alt="MVC 设计模式"></p>
<p><img src="/2017/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_24.png" alt="MVC 设计模式图解"></p>
<h2 id="23-import-关键字的使用"><a href="#23-import-关键字的使用" class="headerlink" title="23 import 关键字的使用"></a>23 import 关键字的使用</h2><h4 id="二、import关键字的使用"><a href="#二、import关键字的使用" class="headerlink" title="二、import关键字的使用"></a>二、import关键字的使用</h4><p>import:导入</p>
<ol>
<li><p>在源文件中显式的使用import结构导入指定包下的类、接口</p>
</li>
<li><p>声明在包的声明和类的声明之间</p>
</li>
<li><p>如果需要导入多个结构，则并列写出即可</p>
</li>
<li><p>可以使用”xxx.*”的方式，表示可以导入xxx包下的所有结构</p>
</li>
<li><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p>
</li>
<li><p>如果使用的类或接口是本包下定义的，则可以省略import结构</p>
</li>
<li><p>如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。————<strong><strong><strong><strong>*****</strong></strong></strong></strong></p>
</li>
<li><p>使用”xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入    * 不代表子包</p>
</li>
<li><p>import static:导入指定类或接口中的静态结构:属性或方法。 </p>
<p>eg import static java.lang.System.*；</p>
<p>out.print(“121”)</p>
</li>
</ol>
<hr>
<ul>
<li>为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类<br>或全部类(.*)。 import语句告诉编译器到哪里去寻找类。</li>
<li>语法格式：<br>import 包名. 类名;</li>
<li>应用举例：<br>import pack1.pack2.Test; //import pack1.pack2.*;表示引入pack1.pack2包中的所有结构</li>
<li>注意：</li>
</ul>
<ol>
<li><p>在源文件中使用import显式的导入指定包下的类或接口</p>
</li>
<li><p>声明在包的声明和类的声明之间。</p>
</li>
<li><p>如果需要导入多个类或接口，那么就并列显式多个import语句即可</p>
</li>
<li><p>举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</p>
</li>
<li><p>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</p>
</li>
<li><p>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的<br>是哪个类。</p>
</li>
<li><p>如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。</p>
</li>
<li><p>import static组合的使用：调用指定类或接口下的静态的属性或方法</p>
<p>两个date</p>
<p>#</p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(上)补1</title>
    <url>/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/</url>
    <content><![CDATA[<h2 id="1-2-每天一问"><a href="#1-2-每天一问" class="headerlink" title="1-2. 每天一问"></a>1-2. 每天一问</h2><p>不是获取文件，而是过程，抄别人没有意义</p>
<p>1.面向对象思想编程内容的三条主线分别是什么</p>
<p>①类及类的成员:属性、方法、构造器;代码块、内部类<br>②面向对象的三大特征:封装、继承、多态。</p>
<p>③其它关键字: this,super,abstract,interface,static,final,package,import</p>
<p>面向对象的编程思想?<br>(类、对象;面向对象的三大特征…) </p>
<p>2.谈谈你对面向对象中类和对象的理解，并指出二者的关系</p>
<p>类:抽象的、概念上的内容。<br>对象:实实在在存在的一个个体。<br>对象是由类派生出来的。</p>
<p>3.面向对象思想的体现一:类和对象的创建和执行操作有哪三步?</p>
<p>①创建类<br>②类的实例化。<br>③调用对象的结构: “对象，属性” “对象.方法’</p>
<p>4.类的方法内是否可以定义变量?是否可以调用属性?是否可以定<br>义方法?是否可以调用方法? </p>
<p>是;是;否;是</p>
<h2 id="3-4-复习"><a href="#3-4-复习" class="headerlink" title="3-4 复习"></a>3-4 复习</h2><p>学习 1个月 就可以工作了</p>
<h3 id="1-面向对象学习的三条主线"><a href="#1-面向对象学习的三条主线" class="headerlink" title="1.面向对象学习的三条主线:"></a>1.面向对象学习的三条主线:</h3><p>①类及类的成员:属性、方法、构造器;代码块、内部类<br>②面向对象的三大特征:封装、继承、多态。<br>③其它关键字: this,super,abstract,interface,static,final,package,import</p>
<h2 id="“大处着眼，小处着手”"><a href="#“大处着眼，小处着手”" class="headerlink" title="“大处着眼，小处着手”"></a>“大处着眼，小处着手”</h2><h3 id="2-面向对象与面向过程-理解"><a href="#2-面向对象与面向过程-理解" class="headerlink" title="2.面向对象与面向过程(理解)"></a>2.面向对象与面向过程(理解)</h3><p>1.面向过程: 强调的是功能行为，以函数为最小单位，考虑怎么做。<br>2.面向对象: 强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</p>
<h2 id="举例-把大象装进冰箱"><a href="#举例-把大象装进冰箱" class="headerlink" title="举例: 把大象装进冰箱"></a>举例: 把大象装进冰箱</h2><h3 id="3-完成一一个项目-或功能-的思路"><a href="#3-完成一一个项目-或功能-的思路" class="headerlink" title="3.完成一一个项目(或功能)的思路:"></a>3.完成一一个项目(或功能)的思路:</h3><ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体。</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序<br>语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。</li>
</ul>
<h3 id="4-面向对象中两个重要的概念"><a href="#4-面向对象中两个重要的概念" class="headerlink" title="4.面向对象中两个重要的概念:"></a>4.面向对象中两个重要的概念:</h3><ul>
<li>类:对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象:是实际存在的该类事物的每个个体，因而也称为实例(instance)<br>面向对象程字设计的重点是类的设计<br>设计类，就是设计类的成员。</li>
<li>二者的关系:<br>对象，是由类new出来的，派生出来的。</li>
</ul>
<h3 id="5-面向对象思想落地实现的规则一"><a href="#5-面向对象思想落地实现的规则一" class="headerlink" title="5.面向对象思想落地实现的规则一"></a>5.面向对象思想落地实现的规则一</h3><ul>
<li>1.创建类，设计类的成员</li>
<li>2.创建类的对象</li>
<li>3.通过“对象.属性”或“对象.方法”调用对象的结构</li>
<li>补充:几个概念的使用说明<br>属性=成员变量=fie]d=域、字段<br>方法=成员方法=函数= method<br>创建类的对象=类的实例化=实例化类</li>
</ul>
<h3 id="6-对象的创建与对象的内存解析"><a href="#6-对象的创建与对象的内存解析" class="headerlink" title="6.对象的创建与对象的内存解析"></a>6.对象的创建与对象的内存解析</h3><ul>
<li>典型代码:<br>Person p1 = new Person();<br>Person p2 = new Person();<br>Person p3 = p1;//没有新创建-一个对象，共用一个堆空间中的对象实体。</li>
<li>说明:<br>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非<br>static的)<br>意味着:如果我们修改一-个对象的属性a，则不影响另外–个对象属性a的值。</li>
</ul>
<h3 id="7-JVM-内存结果"><a href="#7-JVM-内存结果" class="headerlink" title="7. JVM 内存结果"></a>7. JVM 内存结果</h3><p>《JVI规范》</p>
<ul>
<li>虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中</li>
<li>堆，我们将nev出来的结构(比如:数组、对象)加载在对空间中。补充:对象的属性(非static的)加载在堆空间中。</li>
<li>方法区:类的加载信息、常量池、静态域</li>
</ul>
<h2 id="5-属性和方法"><a href="#5-属性和方法" class="headerlink" title="5. 属性和方法"></a>5. 属性和方法</h2><h3 id="局部变量和属性-相同点和不同点"><a href="#局部变量和属性-相同点和不同点" class="headerlink" title="局部变量和属性 相同点和不同点"></a>局部变量和属性 相同点和不同点</h3><p> 补充: 回顾变量的分类<br> 1.按照数据类型分<br>  <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_1.png" alt="按照数据类型分"></p>
<p>2.按照类中声明的位置</p>
<p><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_2.png" alt="按照类中声明的位置"></p>
<h3 id="方法复习"><a href="#方法复习" class="headerlink" title="方法复习"></a>方法复习</h3><h3 id="关键字return"><a href="#关键字return" class="headerlink" title="关键字return"></a>关键字return</h3><h3 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h3><h2 id="6-万物皆对象"><a href="#6-万物皆对象" class="headerlink" title="6. 万物皆对象"></a>6. 万物皆对象</h2><h3 id="一、理解“万事万物皆对象”"><a href="#一、理解“万事万物皆对象”" class="headerlink" title="一、理解“万事万物皆对象”"></a>一、理解“万事万物皆对象”</h3><p>1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构<br>Scanner,String等<br>文件：File<br>网络资源：URL<br>2.涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</p>
<h2 id="7-对象数组的内存解析"><a href="#7-对象数组的内存解析" class="headerlink" title="7. 对象数组的内存解析"></a>7. 对象数组的内存解析</h2><p><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_3.png" alt="对象数组的内存解析"><br>内存解析的说明<br>1.引用类型的变量，只可能存储两类值：null  或  地址值（含变量的类型）</p>
<hr>
<h2 id="8-匿名对象的使用-（可以看到这个）"><a href="#8-匿名对象的使用-（可以看到这个）" class="headerlink" title="8. 匿名对象的使用 （可以看到这个）"></a>8. 匿名对象的使用 （可以看到这个）</h2><h3 id="有名的对象"><a href="#有名的对象" class="headerlink" title="有名的对象"></a>有名的对象</h3><p>eg<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_4.png" alt="有名的对象"></p>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_5.png" alt="匿名的对象"><br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_6.png" alt="匿名的对象2"></p>
<h4 id="1-理解"><a href="#1-理解" class="headerlink" title="1.理解"></a>1.理解</h4><p>我们创建的对象，没有显式的赋给一个变量名。即为匿名对象</p>
<h4 id="2-特征"><a href="#2-特征" class="headerlink" title="2.特征"></a>2.特征</h4><p>匿名对象只能调用一次。</p>
<h4 id="3-实现代码-PhoneMall-p104"><a href="#3-实现代码-PhoneMall-p104" class="headerlink" title="3.实现代码  PhoneMall p104"></a>3.实现代码  PhoneMall p104</h4><p>类比，你给别人的匿名信，他写上名字了<br>mall.show(new Phone());</p>
<p>class PhoneMall{<br>    public void show(Phone phone){<br>        phone.sendEmail();<br>        phone.playGame();<br>    }</p>
<p>}</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="comment">//		p = null;</span></span><br><span class="line">		System.out.println(p);</span><br><span class="line">		</span><br><span class="line">		p.sendEmail();</span><br><span class="line">		p.playGame();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//匿名对象</span></span><br><span class="line"><span class="comment">//		new Phone().sendEmail();</span></span><br><span class="line"><span class="comment">//		new Phone().playGame();</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line">		<span class="keyword">new</span> Phone().showPrice();<span class="comment">//0.0</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//**********************************</span></span><br><span class="line">		PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line"><span class="comment">//		mall.show(p);</span></span><br><span class="line">		<span class="comment">//匿名对象的使用</span></span><br><span class="line">		mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>{</span><br><span class="line">		phone.sendEmail();</span><br><span class="line">		phone.playGame();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>{</span><br><span class="line">	<span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"发送邮件"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"玩游戏"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"手机价格为："</span> + price);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="9-自定义数据工具类"><a href="#9-自定义数据工具类" class="headerlink" title="9.自定义数据工具类"></a>9.自定义数据工具类</h2><p>合理 整洁  复用性   –工具类的封装</p>
<h2 id="10-理解方法的重载"><a href="#10-理解方法的重载" class="headerlink" title="10.理解方法的重载"></a>10.理解方法的重载</h2><h3 id="10-1方法的重载"><a href="#10-1方法的重载" class="headerlink" title="10.1方法的重载"></a>10.1方法的重载</h3><ul>
<li>重载的概念overload 参数列表<br>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。<br> “两同一不同”:同一个类、相同方法名<br> 参数列表不同：参数个数不同，参数类型不同</li>
<li>重载的特点:<br>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</li>
<li>重载示例:<br>//返回两个整数的和<br>int add(int x,int y){return x+y;}<br>//返回三个整数的和<br>int add(int x,int y,int z){return x+y+Z;}<br>1返回两个小数的和<br>double add(double x,double y){return x+y;}<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_7.png" alt="重载举例"></li>
</ul>
<h2 id="11-方法的重载细节介绍"><a href="#11-方法的重载细节介绍" class="headerlink" title="11.方法的重载细节介绍"></a>11.方法的重载细节介绍</h2><p><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_8.png" alt="不能构成重载"></p>
<ul>
<li>重载的判断<br>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_9.png" alt="方法没有调用int类型 会自动提升double"></li>
<li>在通过对象调用方法时，如何确定某一个指定的方法：<br>方法名 —&gt; 参数列表(还要看)</li>
</ul>
<h2 id="12-重载的举例与判断"><a href="#12-重载的举例与判断" class="headerlink" title="12.重载的举例与判断"></a>12.重载的举例与判断</h2><p>使用重载，可以为编程带来便捷<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_10.png" alt="重载练习"><br>a n<br>b y  不要看返回值类型<br>c y<br>d ye<br>e y<br>f n<br>g n</p>
<h2 id="13-编程实现"><a href="#13-编程实现" class="headerlink" title="13.编程实现"></a>13.编程实现</h2><p>duplicate 重复的 多重的</p>
<h2 id="14-可变个数的形参的方法"><a href="#14-可变个数的形参的方法" class="headerlink" title="14.可变个数的形参的方法"></a>14.可变个数的形参的方法</h2><h3 id="可变形参的方法"><a href="#可变形参的方法" class="headerlink" title="可变形参的方法"></a>可变形参的方法</h3><p>JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定<br>义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可<br>变的实参。<br>//JDK 5.0以前:采用数组形参来定义方法，传入多个同一类型变量<br>public static void test(int a ,String[] books);<br>//JDK5.0:采用可变个数形参来定义方法，传入多个同一类型变量<br>public static void test(int a ,String…books);</p>
<ul>
<li>具体使用<ul>
<li>1.可变个数形参的格式：数据类型 … 变量名</li>
<li>2.当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</li>
<li>3.可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载  9-11</li>
<li>4.可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。图9-12</li>
<li>5.可变个数形参在方法的形参中，必须声明在末尾<br>String .. .strs必须声明在末尾<br> public void show(int i,String .. .strs)；</li>
<li>6.可变个数形参在方法的形参中,最多只能声明一个可变形参。   一山不容二虎<br>打比方:万能备胎王  ；任何找不到  都不可以找到他；<br>解说都要是String类型 才可以<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_11.png" alt="实现"></li>
</ul>
</li>
</ul>
<p><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_12.png" alt="认为两个一样"></p>
<p>原来的时候</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">test.show(<span class="keyword">new</span> String[]{<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"CC"</span>});</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String[] strs)</span></span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">不用new</span><br><span class="line">test.show("AA",“BB”)；</span><br><span class="line">这样做也对</span><br><span class="line">test.show(new String[]{"AA","BB","CC"});</span><br><span class="line"></span><br><span class="line">	public void show(String ... strs){</span><br><span class="line">		System.out.println("show(String ... strs)");</span><br><span class="line">		</span><br><span class="line">		for(int i = 0;i &lt; strs.length;i++){</span><br><span class="line">			System.out.println(strs[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<p>应用: SQL 查条件   where 之后条件不知道要写几个</p>
<h2 id="15-理解变量的赋值-难点"><a href="#15-理解变量的赋值-难点" class="headerlink" title="15.理解变量的赋值** 难点"></a>15.理解变量的赋值<strong>**</strong> 难点</h2><h3 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h3><ul>
<li>方法，必须由其所在类或对象调用才有意义。若方法含有参数:<ul>
<li>形参:方法声明时的参数</li>
<li>实参:方法调用时实际传给形参的参数值</li>
</ul>
</li>
<li>Java的实参值如何传入方法呢?<br>Java里方法的参数传递方式只有一种:值传递。<br>即将实际参数值的副本(复制品)传入方法内，而参数本身不受影响。<ul>
<li>形参是基本数据类型:将实参基本数据类型变量的“数据值”传递给形参</li>
<li>形参是引用数据类型:将实参引用数据类型变量的“地址值”传递给形参<br>每天坚持 不停去写<br>真是存的数字给它了，自己没有动<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_13.png" alt="基本类型的变量"></li>
</ul>
</li>
</ul>
<p>order o1=o2；<br>一个对象的值修改了会影响到另一个对象<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_14.png" alt="引用类型的变量"><br>Order o2 = o1;//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</p>
<ul>
<li>关于变量赋值<br>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。<br>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
</ul>
<h2 id="16-方法的形参的传递机制：值传递"><a href="#16-方法的形参的传递机制：值传递" class="headerlink" title="16.方法的形参的传递机制：值传递"></a>16.方法的形参的传递机制：值传递</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">形参：方法定义时，声明的小括号内的参数</span><br><span class="line">实参：方法调用时，实际传递给形参的数据</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>值传递机制：<br>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。<br> 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</li>
</ul>
<h2 id="17-方法的形参的传递机制：引用数据类型传递"><a href="#17-方法的形参的传递机制：引用数据类型传递" class="headerlink" title="17.方法的形参的传递机制：引用数据类型传递"></a>17.方法的形参的传递机制：引用数据类型传递</h2><p> ###引用数据类型 赋值了地址<br> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_15.png" alt="引用类型的变量"><br> 交换两个数组元素的值<br> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_16.png" alt="交换两个数组元素的值"></p>
<h2 id="18-画图"><a href="#18-画图" class="headerlink" title="18.画图"></a>18.画图</h2><h2 id="19-探讨网红题目"><a href="#19-探讨网红题目" class="headerlink" title="19.探讨网红题目"></a>19.探讨网红题目</h2><p> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_17.png" alt="题1"><br> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_18.png" alt="题1的答案1"><br> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_19.png" alt="题1的答案2"></p>
<p> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_20.png" alt="题2"><br> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_21.png" alt="题3"></p>
<h2 id="20-参数传递的联系"><a href="#20-参数传递的联系" class="headerlink" title="20 参数传递的联系"></a>20 参数传递的联系</h2><h2 id="21-递归方法的使用"><a href="#21-递归方法的使用" class="headerlink" title="21 递归方法的使用"></a>21 递归方法的使用</h2><h3 id="递归方法-–理解"><a href="#递归方法-–理解" class="headerlink" title="递归方法 –理解"></a>递归方法 –理解</h3><ul>
<li>递归方法：一个方法体内调用它自身。</li>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li>
<li>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。<br>eg<br>//计算1-100之间所有自然数的和<br>public int sum(int num){<br>if(num == 1){<br>return 1;<br>}else{<br>return num + sum(num - 1);<br>}<br>}</li>
</ul>
<h2 id="22-递归方法的使用递归的练习"><a href="#22-递归方法的使用递归的练习" class="headerlink" title="22 递归方法的使用递归的练习"></a>22 递归方法的使用递归的练习</h2><p> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_22.png" alt="练习"><br>  <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_23.png" alt="题3解答"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(上)</title>
    <url>/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/</url>
    <content><![CDATA[<h4 id="Java语言的基本元素-类与对象"><a href="#Java语言的基本元素-类与对象" class="headerlink" title="Java语言的基本元素 类与对象"></a>Java语言的基本元素 类与对象</h4><h3 id="5-面向对象的思想概述"><a href="#5-面向对象的思想概述" class="headerlink" title="5. 面向对象的思想概述"></a>5. 面向对象的思想概述</h3><ul>
<li>类(Class)和对象(Object)是面向对象的核心概念。<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
</li>
<li>万事万物皆对象<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_1.png" alt="例子"></li>
</ul>
<ul>
<li><p>可以理解为:<code>类=抽象概念的人</code>;<code>对象=实实在在的某个人</code></p>
</li>
<li><p>面向对象程序设计的重点是<code>类的设计</code>（图纸）</p>
</li>
<li><p>类的设计，其实就是类的成员的设计</p>
</li>
</ul>
<hr>
<h3 id="6-类的结构-属性和方法"><a href="#6-类的结构-属性和方法" class="headerlink" title="6.类的结构: 属性和方法"></a>6.类的结构: 属性和方法</h3><h4 id="Java类及类的成员"><a href="#Java类及类的成员" class="headerlink" title="Java类及类的成员"></a>Java类及类的成员</h4><ul>
<li>现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的<code>细胞</code>构成的。同理，Java代码世界是由诸多个不同功能的<code>类</code>构成的。</li>
<li>现实生物世界中的细胞又是由什么构成的呢?细胞核、细胞质、..那么,<br>Java中用<code>类class</code>来描述事物也是如此。常见的类的成员有:<ul>
<li>属性:对应类中的成员变量</li>
<li>行为:对应类中的成员方法</li>
</ul>
</li>
<li>Field=属性=成员变量=域，字段，Method= (成员)方法=函数<br>eg： 生活中描述事物无非就是描述事物的属性和行为。如:人有身高，体重等属性，有说话,打球等行为。<br>类的成员构成version 1.0<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_2.png" alt="简单版"></li>
</ul>
<p>类的成员构成version 2.0 </p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_3.png" alt="完整版"></h2><h3 id="7-类和对象的创建"><a href="#7-类和对象的创建" class="headerlink" title="7.类和对象的创建"></a>7.类和对象的创建</h3><p><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_4.png" alt="引入"></p>
<ul>
<li><p>创建类的对象=类的实例化=实例化类</p>
</li>
<li><p>创建对象语法： 类名 对象名 = new 类名();</p>
</li>
<li><p>使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）</p>
</li>
<li><p>二、类和对象的使用(面向对象思想落地的实现)</p>
<ol>
<li>创建类，设计类的成员（多）</li>
<li>创建类的对象</li>
<li>通过““对象.属性或“对象.方法”调用对象的结构<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">boolean</span> isMale;</span><br><span class="line">	<span class="comment">//方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">	System.out.println(<span class="string">"人可以吃饭"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">	System.out.println(<span class="string">"人可以睡觉"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">	System.out.println(<span class="string">"人可以说话,使用的是: "</span> + language);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//创建Person类的对象</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person( ) ;</span><br><span class="line"><span class="comment">//Scanner scanner = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//调用对象的结构:属性、方法</span></span><br><span class="line"><span class="comment">//调用属性:“对象.属性”</span></span><br><span class="line">p1.name = <span class="string">"Tom"</span>;</span><br><span class="line">p1. isMale = <span class="keyword">true</span>;</span><br><span class="line">System. out . println(p1. name);</span><br><span class="line"><span class="comment">//调用方法:“对象。方法”</span></span><br><span class="line">p1.eat();</span><br><span class="line">p1.sleep();</span><br><span class="line">p1. talk(<span class="string">"Chinese"</span>);</span><br><span class="line">										}</span><br><span class="line">						}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-对类和对象创建的再理解"><a href="#8-对类和对象创建的再理解" class="headerlink" title="8.对类和对象创建的再理解"></a>8.对类和对象创建的再理解</h3>有了对象反推出类—&gt;反射<h3 id="9-类多个对象的关系"><a href="#9-类多个对象的关系" class="headerlink" title="9.类多个对象的关系"></a>9.类多个对象的关系</h3>==   打比方   简历的模板 ，谁填是谁的信息</li>
</ol>
</li>
<li><p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非static的)</p>
</li>
<li><p>意味着:如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//将p1变量保存的对象地址值赋给p3 ,导致p1和p3指向了堆空间中的同一个对象实体。</span></span><br><span class="line">Person p3=p1;</span><br><span class="line">System. out. println(p3.name);/ /Tom</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-对象的内存解析"><a href="#10-对象的内存解析" class="headerlink" title="10.对象的内存解析"></a>10.对象的内存解析</h3><p><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_5.png" alt="内存解析"></p>
</li>
</ul>
<p>方法中定义的变量都是局部变量</p>
<p><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_6.png" alt="完整版"></p>
<h3 id="11-属性与局部变量的对比11-12"><a href="#11-属性与局部变量的对比11-12" class="headerlink" title="11.属性与局部变量的对比11-12"></a>11.属性与局部变量的对比11-12</h3><p>属性(成员变量)  VS 局部变量 （打比方 放的位置不同 蜂王和工蜂）</p>
<p>1.相同点</p>
<ul>
<li>定义变量的格式:数据类型变量名=变量值</li>
<li>先声明，后作用</li>
<li>变量都有其对应的作用域、</li>
</ul>
<p>2.不同点</p>
<ul>
<li><p>在类中声明的位置的不同</p>
<ul>
<li>属性：直接定义在类的一对{}内<ul>
<li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量<br> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_7.png" alt="局部变量的位置举例子"></li>
<li>关于权限修饰符的不同</li>
</ul>
</li>
<li>属性：可以在声明属性时，指明其权限，使用权限修饰符。<pre><code>常用的权限修饰符：private、public、缺省、protected  ---&gt;封装性   作用域的大小
  目前，大家声明属性时，都使用缺省就可以了。</code></pre><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_8.png" alt="成员变量权限修饰符举例子"></li>
<li>局部变量：不可以使用权限修饰符，并没有默认初始化值（也就是理解方法代替了）</li>
</ul>
</li>
<li><p>默认初始化值的情况:</p>
<ul>
<li><p>属性:类的属性，根据其类型，都有默认初始化值。<br>整型(byte、short、int、long):0<br>浮点型(float、double) 0.0<br>字符型(char):0或’\u0000’ )<br>布尔型(boolean) : false<br>引用数据类型(类、数组、接口) : null<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_9.png" alt="属性的默认值举例子"></p>
</li>
<li><p>局部变量:没有默认初始化值。<br>意味着，我们在调用局部变量之前，一定要显式赋值。<br>特别地:形参在调用时，我们赋值即可。（下图）<br><img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_10.png" alt="形参在调用时，我们赋值"></p>
</li>
<li><p>在内存中加载的位置:<br>属性:加载到堆空间中(非static 存在 方法区)<br>局部变量:加载到栈空间</p>
</li>
</ul>
</li>
</ul>
<h3 id="13-类中方法举例与声明的格式"><a href="#13-类中方法举例与声明的格式" class="headerlink" title="13. 类中方法举例与声明的格式"></a>13. 类中方法举例与声明的格式</h3><p>方法：描述类应该具有的功能<br>比如 Math类的sqrt()</p>
<ol>
<li><p>举例<br>public void eat(){}<br>public void sleep(int hour){}<br>public String getName(){}<br>public String getNation(String nation){}</p>
</li>
<li><p>方法的声明：<br>权限修饰符  返回值类型  方法名(形参列表){  方法体 };<br>注意：static、final、abstract 来修饰的方法，后面再讲。</p>
<h3 id="14-方法声明的说明14-15"><a href="#14-方法声明的说明14-15" class="headerlink" title="14. 方法声明的说明14-15"></a>14. 方法声明的说明14-15</h3><ol start="3">
<li>说明：</li>
</ol>
<ul>
<li><p>3.1 关于权限修饰符：默认方法的权限修饰符先都使用public<br>Java规定的4种权限修饰符：private、public、缺省、protected  –&gt;封装性再细说</p>
</li>
<li><p>3.2 返回值类型： 有返回值 vs 没有返回值</p>
<ul>
<li>如果方法<code>有</code>返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：“return 数据”。</li>
<li>如果方法<code>没有</code>返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。</li>
<li>3.2.2 我们定义方法该不该有返回值？<br>① 题目要求② 凭经验：具体问题具体分析</li>
</ul>
</li>
<li><p>3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”</p>
</li>
<li><p>3.4 形参列表： 方法可以声明0个，1个或多个形参。</p>
</li>
<li><p>3.5 方法体：方法功能的体现。 </p>
<h3 id="16-return关键字的使用"><a href="#16-return关键字的使用" class="headerlink" title="16 return关键字的使用"></a>16 return关键字的使用</h3></li>
</ul>
</li>
<li><p>return关键字的使用：</p>
</li>
</ol>
<ul>
<li><p>1.使用范围：使用在方法体中</p>
<ul>
<li>2.作用：① 结束方法 ② 针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。</li>
<li>3.注意点：return关键字后面不可以声明执行语句。<h3 id="17-方法使用中的注意点"><a href="#17-方法使用中的注意点" class="headerlink" title="17. 方法使用中的注意点"></a>17. 方法使用中的注意点</h3></li>
</ul>
</li>
</ul>
<ol start="5">
<li>方法的使用中，可以调用当前类的属性或方法<br>特殊的：方法A中又调用了方法A:递归方法。<br>方法中，不可以定义方法。<br> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_11.png" alt="方法中，不可以定义方法。"></li>
</ol>
<h3 id="18-19-20-类的设计-练习"><a href="#18-19-20-类的设计-练习" class="headerlink" title="18-19-20. 类的设计 练习"></a>18-19-20. 类的设计 练习</h3><h3 id="21-22"><a href="#21-22" class="headerlink" title="21-22"></a>21-22</h3><p> <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_12.png" alt="题4-5"></p>
<p> test  类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4. 对象数组题目：</span></span><br><span class="line"><span class="comment">定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</span></span><br><span class="line"><span class="comment"> 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</span></span><br><span class="line"><span class="comment">问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line"><span class="comment">问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1) 生成随机数：Math.random()，返回值类型double;  </span></span><br><span class="line"><span class="comment">2) 四舍五入取整：Math.round(double d)，返回值类型long。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line">		<span class="comment">//声明Student类型的数组</span></span><br><span class="line">		Student[] stus = <span class="keyword">new</span> Student[<span class="number">20</span>];  <span class="comment">//String[] arr = new String[10];</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length;i++){</span><br><span class="line">			<span class="comment">//给数组元素赋值</span></span><br><span class="line">			stus[i] = <span class="keyword">new</span> Student();</span><br><span class="line">			<span class="comment">//给Student对象的属性赋值</span></span><br><span class="line">			stus[i].number = (i + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//年级：[1,6]</span></span><br><span class="line">			stus[i].state = (<span class="keyword">int</span>)(Math.random() * (<span class="number">6</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//成绩：[0,100]</span></span><br><span class="line">			stus[i].score = (<span class="keyword">int</span>)(Math.random() * (<span class="number">100</span> - <span class="number">0</span> + <span class="number">1</span>));</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line"><span class="comment">//			System.out.println(stus[i].number + "," + stus[i].state </span></span><br><span class="line"><span class="comment">//					+ "," + stus[i].score);</span></span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		<span class="comment">//问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line">			<span class="keyword">if</span>(stus[i].state == <span class="number">3</span>){</span><br><span class="line">				System.out.println(stus[i].info());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		<span class="comment">//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length - <span class="number">1</span>;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; stus.length - <span class="number">1</span> - i;j++){</span><br><span class="line">				<span class="keyword">if</span>(stus[j].score &gt; stus[j + <span class="number">1</span>].score){</span><br><span class="line">					<span class="comment">//如果需要换序，交换的是数组的元素：Student对象！！！</span></span><br><span class="line">					Student temp = stus[j];</span><br><span class="line">					stus[j] = stus[j + <span class="number">1</span>];</span><br><span class="line">					stus[j + <span class="number">1</span>] = temp;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>{</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//学号</span></span><br><span class="line">	<span class="keyword">int</span> state;<span class="comment">//年级</span></span><br><span class="line">	<span class="keyword">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示学生信息的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"学号："</span> + number + <span class="string">",年级："</span> + state + <span class="string">",成绩："</span> + score;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>




<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4. 对象数组题目：     </span></span><br><span class="line"><span class="comment">定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</span></span><br><span class="line"><span class="comment"> 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</span></span><br><span class="line"><span class="comment">问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line"><span class="comment">问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1) 生成随机数：Math.random()，返回值类型double;  </span></span><br><span class="line"><span class="comment">2) 四舍五入取整：Math.round(double d)，返回值类型long。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 此代码是对StudentTest.java的改进：将操作数组的功能封装到方法中。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest1</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//声明Student类型的数组</span></span><br><span class="line">		Student1[] stus = <span class="keyword">new</span> Student1[<span class="number">20</span>];  </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length;i++){</span><br><span class="line">			<span class="comment">//给数组元素赋值</span></span><br><span class="line">			stus[i] = <span class="keyword">new</span> Student1();</span><br><span class="line">			<span class="comment">//给Student对象的属性赋值</span></span><br><span class="line">			stus[i].number = (i + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//年级：[1,6]</span></span><br><span class="line">			stus[i].state = (<span class="keyword">int</span>)(Math.random() * (<span class="number">6</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//成绩：[0,100]</span></span><br><span class="line">			stus[i].score = (<span class="keyword">int</span>)(Math.random() * (<span class="number">100</span> - <span class="number">0</span> + <span class="number">1</span>));</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		StudentTest1 test = <span class="keyword">new</span> StudentTest1();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		test.print(stus);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line">		test.searchState(stus, <span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line">		test.sort(stus);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		test.print(stus);</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>  遍历Student1[]数组的操作</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stus</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Student1[] stus)</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span> 查找Stduent数组中指定年级的学生信息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stus 要查找的数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> state 要找的年级</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchState</span><span class="params">(Student1[] stus,<span class="keyword">int</span> state)</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line">			<span class="keyword">if</span>(stus[i].state == state){</span><br><span class="line">				System.out.println(stus[i].info());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span> 给Student1数组排序</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stus</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Student1[] stus)</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length - <span class="number">1</span>;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; stus.length - <span class="number">1</span> - i;j++){</span><br><span class="line">				<span class="keyword">if</span>(stus[j].score &gt; stus[j + <span class="number">1</span>].score){</span><br><span class="line">					<span class="comment">//如果需要换序，交换的是数组的元素：Student对象！！！</span></span><br><span class="line">					Student1 temp = stus[j];</span><br><span class="line">					stus[j] = stus[j + <span class="number">1</span>];</span><br><span class="line">					stus[j + <span class="number">1</span>] = temp;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span></span>{</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//学号</span></span><br><span class="line">	<span class="keyword">int</span> state;<span class="comment">//年级</span></span><br><span class="line">	<span class="keyword">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">	<span class="comment">//显示学生信息的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"学号："</span> + number + <span class="string">",年级："</span> + state + <span class="string">",成绩："</span> + score;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  <img src="/2017/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_13.png" alt="内存解析图"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据类型</title>
    <url>/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/</url>
    <content><![CDATA[<h3 id="1-Java-语言基础-基本数据类型"><a href="#1-Java-语言基础-基本数据类型" class="headerlink" title="1. Java 语言基础-基本数据类型"></a>1. Java 语言基础-基本数据类型</h3><h4 id="1-HelloWorld程序的讲解"><a href="#1-HelloWorld程序的讲解" class="headerlink" title="1. HelloWorld程序的讲解"></a>1. HelloWorld程序的讲解</h4><p> <img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/1_10.png" alt="1586920600288"></p>
<ul>
<li>public、class、static、 void为关键字，固定写法</li>
<li>HelloWord 为类名，可以任意写</li>
<li>main 为函数或方法名，每个程序都有一个main函数做为入口，如同房间，需要有个门一样</li>
<li>main方法后面括号的内容称为参数</li>
<li>System. out. println(“HelloWord” )向控制台输入内容</li>
<li>注意:类名第一个字母要使用大写，花括号是成对出现的</li>
</ul>
<h4 id="2-常量的概述和使用"><a href="#2-常量的概述和使用" class="headerlink" title="2. 常量的概述和使用"></a>2. 常量的概述和使用</h4><h5 id="2-1-什么是常量"><a href="#2-1-什么是常量" class="headerlink" title="2.1 什么是常量"></a>2.1 什么是常量</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在程序执行的过程中其值不会发生改变</p>
<h5 id="2-2-Java中常量的分类"><a href="#2-2-Java中常量的分类" class="headerlink" title="2.2 Java中常量的分类"></a>2.2 Java中常量的分类</h5><p>① 字面值常量<br>② 自定义常量(面向对象部分讲)</p>
<h5 id="2-3-字面值常量的分类"><a href="#2-3-字面值常量的分类" class="headerlink" title="2.3 字面值常量的分类"></a>2.3 字面值常量的分类</h5><p>① 字符串常量用双引号括起来的内容   #    “Java”<br>② 整数常量所有整数    1000<br>③ 小数常量所有小数   3.14       有效数字  float 6-7 ,  double 15-16<br>④ 字符常量用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号   ‘c’<br>⑤ 布尔常量较为特殊，只有true和false<br>⑥ 空常量null [数组部分]<br>win10 快速访问</p>
<h4 id="3-二-八-十六进制"><a href="#3-二-八-十六进制" class="headerlink" title="3. 二,八,十六进制"></a>3. 二,八,十六进制</h4><h5 id="什么是进制"><a href="#什么是进制" class="headerlink" title="什么是进制"></a>什么是进制</h5><p>  进制是一种进位方法。对于任何一种进制 X进制，就表示某一位置上的数 运算时逢X进一位。</p>
<ul>
<li><p>二进制就是逢二进一，</p>
</li>
<li><p>八逆制是逢八进一，</p>
</li>
<li><p>十进制是逢十进一，</p>
</li>
<li><p>十六进制是逢十六进-一。</p>
</li>
<li><p>不同进制数据的Java表现形式</p>
<ul>
<li><p>二进制的数据表现形式 一 由0,1组成。以0b(b可大小写)开头2= 10<br><code>System.out.print(0b10);</code></p>
</li>
<li><p>八进制的数据表现形式— 由0,1,…7组成。 以0开头[8= 10]</p>
<p><code>System.out.print(011);</code></p>
</li>
<li><p>十进制的数据表现形式—由0,1,…9组成。整数默认是十进制的[10= 10]</p>
</li>
<li><p>十六进制的数据表现形式—由,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头[16= 10]</p>
<p><code>System.out.print(0X16);</code>    </p>
</li>
</ul>
</li>
<li><p>注意:只有JDK1.7版本以上可以使用0b2来表示二进制</p>
</li>
</ul>
<h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><ul>
<li>在计算机中，只能识别二进制的数据，二进制就是0和1来表示的<br><img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_1.png" alt="一个字节有8个比特位"><br> 如上图表示1个字节，一个字节有8个比特位(1byte =8bit)</li>
<li>字节是数据存储的基本单位</li>
<li>数据存储单位计算<br>1byte=8bit (比特)<br>1kb = 1024byte<br>1M = 1024kb<br>1G = 1024M<br>1T=1024G</li>
</ul>
<h5 id="二进制和十进制的转换"><a href="#二进制和十进制的转换" class="headerlink" title="二进制和十进制的转换"></a>二进制和十进制的转换</h5><ul>
<li>任意进制到十进制的转换原理<ul>
<li>系数:就是每一位上的数据。</li>
<li>基数: x进制，基数就是X.</li>
<li>权:在右边，从0开始编号，对应位上的编号即为该位的权。</li>
<li>结果:把系数*基数的权次幂相加即可。</li>
</ul>
</li>
<li>图解<br><img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_2.png" alt="二进制和十进制的转换"></li>
</ul>
<h5 id="八进制到十进制的转换"><a href="#八进制到十进制的转换" class="headerlink" title="八进制到十进制的转换"></a>八进制到十进制的转换</h5><p> <img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_3.png" alt="八进制到十进制的转换"></p>
<h5 id="十六进制到十进制的转换"><a href="#十六进制到十进制的转换" class="headerlink" title="十六进制到十进制的转换"></a>十六进制到十进制的转换</h5><p> <img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_4.png" alt="十六进制到十进制的转换"></p>
<h5 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h5><ul>
<li><p>有符号数据表示法的几种方式</p>
<ul>
<li><p>原码</p>
<ul>
<li><p>就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。    左边是最高位，右边最低位   </p>
<p>1111 1111 255</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 通过一个字节,也就是8个二进制位表示+7和-7

- 0(符号位) 0000111     +7

- 1(符号位) 0000111     -7</code></pre><ul>
<li><p>反码<br>正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</p>
<p>eg. -7 1 000 0111（原码）</p>
<p>反码   11111 000</p>
</li>
<li><p>补码<br>正数的补码与其原码相同；负数的补码是在其反码的末位加1</p>
</li>
<li><p>-7的补码 1111 1001 </p>
</li>
</ul>
<ul>
<li><p><img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_5.png" alt="1586920600288"></p>
</li>
<li><p>原码反码补码练习</p>
<ul>
<li><p>已知原码求补码* 0b10110100</p>
<p>11001011+1    1100 1100</p>
</li>
<li><p>已知补码求原码* 0b11101110</p>
<p>1110 1110           1110  1101     -&gt;1001 0010</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-变量和数据类型"><a href="#4-变量和数据类型" class="headerlink" title="4. 变量和数据类型"></a>4. 变量和数据类型</h4><ul>
<li>变量的概述及格式<ul>
<li>什么是变量<br>在程序执行的过程中，在某个范围内其值可以发生改变的量</li>
<li>变量的定义格式，[如同数据方程式xyz, 求值]<br>数据类型 变量名=变量值;<br>byte b= 127;</li>
<li>为什么要定义变量<br>用来不断的存放同类型的常量,并可以<code>重复使用</code></li>
</ul>
</li>
</ul>
<h4 id="5-基本数据类型的定义"><a href="#5-基本数据类型的定义" class="headerlink" title="5. 基本数据类型的定义"></a>5. 基本数据类型的定义</h4><ul>
<li><p>为什么有数据类型</p>
<ul>
<li>Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，</li>
<li>每一种数据类型在内存中分配了不同大小的内存空间</li>
<li>这样做是为了充分高效的利用内存空间  -&gt;  2m的人  2m床</li>
</ul>
</li>
<li><p>Java中数据类型的分类<br>①基本数据类型<br>②引用数据类型(面向对象部分)</p>
</li>
<li><p>基本数据类型分类(4类8种)</p>
<ul>
<li>整数型:<br>byte (字节类型)  占一个字节 -2^7<del>2^7-1[-128</del>127]   </li>
</ul>
<p><code>不能把一个int 型转换为byte型</code></p>
<p>short 占两个字 -2^15~ 2^15-1 [ -32768<del>32767]<br>int      占四个字节-2^31</del>2^31-1 [-2^31=2147483647]<br>1ong  占八个字节- 2^63~ 2^63-1 [ -2^63=9223372036854775807]<br><code>写长整型时，加个L标识,可以写小写的l,但小写的l像一，不建议写
  long d = -922L;
System.out.println(d);</code></p>
</li>
<li><p>浮点型:<br>float单精度占四个字节 -3.403E38~3.403E38<br><code>单精度型使用F标识,不加F,默认就是双精度
float e = 1.87312343F;//单精度型使用F标识
System.out.println(e);</code></p>
</li>
</ul>
<p>double双精度占八个字节-1.798E308~1.798E308</p>
<ul>
<li>字符型: char占两个字节0~65535</li>
<li>布尔型: boolean java中boolean类型没有明确指定他的大小</li>
<li>基本数据类型定义的注意事项<ul>
<li>赋值时候注意float类型,long类型，加大写的F和L</li>
<li>作用域问题:同一个区域不能使用相同的变量名 </li>
<li>初始化值问题:局部变量在使用之前必须赋值</li>
<li>一条语句可以定义几个变量 eg: int a,b,c</li>
</ul>
</li>
</ul>
<h4 id="6-数据类型转换"><a href="#6-数据类型转换" class="headerlink" title="6.数据类型转换"></a>6.数据类型转换</h4><ul>
<li>Java中 的默认转换规则<ul>
<li>取值范围小的数据类型与取值范围大的数据类型进行运算会先将小的数据类型提升为大的.再运算</li>
<li>Java的运算是以<code>补码</code>形式运算的<br><img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_6.png" alt="1586920600288"><br>得到了结果是1000 0010   ==    -2  再转换为补码<br>强制类型转换会损失精度  </li>
</ul>
</li>
<li>数据类型相加的细节<ul>
<li>进行混合运算的时候,byte,short,char不会相互转换都会自动类型提升为int类型</li>
<li>byte,short,char与其他类型进行混合运算的是小的数据类型提升为大的</li>
</ul>
</li>
</ul>
<h4 id="7-面试题-long与float的取值范園谁大谁小"><a href="#7-面试题-long与float的取值范園谁大谁小" class="headerlink" title="7.面试题:long与float的取值范園谁大谁小"></a>7.面试题:long与float的取值范園谁大谁小</h4><p> <img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_8.png" alt="1586920600288"><br> <img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_9.png" alt="1586920600288"></p>
<ul>
<li>重点<br><img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_7.png" alt="1586920600288"></li>
</ul>
<h4 id="8-字符和字符串参与运算"><a href="#8-字符和字符串参与运算" class="headerlink" title="8.字符和字符串参与运算"></a>8.字符和字符串参与运算</h4><h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><ul>
<li>字符是指计算机中使用的字母、数字、字和符号，包括: 1、2、3、A、B、C、~，( )一一+等等。</li>
<li>在ASCII编码中，一个英文字母字符存储需要1个字节。</li>
<li>在GB2312编码或GBK编码中，一个汉字字符存储需要2个字节。</li>
<li>在UTF-8编码中，一个英文字母存储需要1个字节，一个汉字储存需要3到4个字节。</li>
</ul>
<h5 id="字符的定义"><a href="#字符的定义" class="headerlink" title="字符的定义"></a>字符的定义</h5><ul>
<li>使用char来定义字符类型</li>
<li>给char赋值时，如果是字母或者其它字符使用单引用号<br>如: char c=‘a’</li>
<li>给char 赋值时，可以直接使用asci表的数字<br>如: char c= 97</li>
<li>在ascii表中大写的与小写的相差32 </li>
</ul>
<h5 id="告白"><a href="#告白" class="headerlink" title="告白"></a>告白</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="number">73</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">char</span> c3 = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">char</span> c4 = <span class="number">118</span>;</span><br><span class="line"><span class="keyword">char</span> c5 = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">char</span> c6 = <span class="number">89</span>;</span><br><span class="line"><span class="keyword">char</span> c7 = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">char</span> c8 = <span class="number">117</span>;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="字符的相加"><a href="#字符的相加" class="headerlink" title="字符的相加"></a>字符的相加</h5><ul>
<li>字符相加会把字符对应的ascii数字相加</li>
<li><img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_10.png" alt="1111"></li>
</ul>
<h5 id="记住ASCII码的三个值："><a href="#记住ASCII码的三个值：" class="headerlink" title="记住ASCII码的三个值："></a>记住ASCII码的三个值：</h5><p>‘0’ 48<br>‘A’ 65<br>‘a’ 97</p>
<h5 id="字符与字符串相加"><a href="#字符与字符串相加" class="headerlink" title="字符与字符串相加"></a>字符与字符串相加</h5><p> <img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_11.png" alt="1586920600288"></p>
<h5 id="char数据与中文"><a href="#char数据与中文" class="headerlink" title="char数据与中文"></a>char数据与中文</h5><ul>
<li>char数据类型<br>char 在ascii编码中占1个字节 取值在0到127<br>char 在unicode编码中占2个字节 取值在0到65535</li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题:"></a>面试题:</h4><h5 id="Java语言中的字符char可以存储一个中文汉字吗-为什么呢"><a href="#Java语言中的字符char可以存储一个中文汉字吗-为什么呢" class="headerlink" title="Java语言中的字符char可以存储一个中文汉字吗?为什么呢?"></a>Java语言中的字符char可以存储一个中文汉字吗?为什么呢?</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节，utf-8编码是unicode中的一种编码，所以，Java中的字符可以存储一个中文汉字</span><br></pre></td></tr></tbody></table></figure>

<p>注:可以把编码类型改成ascii再打印中文给学生看，讲解为什么<br>GBK编码 ： 只能显示简体中文<br>GB2312编码:只能显示简体、繁体中文<br>Unicode编码：不仅可以存中文，还有可存日文，韩文(万国码)<br>-UTF-8 (万国码)<br>-UTF-16</p>
<h5 id="Unicode码"><a href="#Unicode码" class="headerlink" title="Unicode码"></a>Unicode码</h5><ul>
<li>Unicode是一种字符集，中、日、韩的三种文字占用了Unicode中0x3000到0x9FFF的部分 </li>
<li>Unicode采用的是UCS-2,用两个字节表示一个字符，2的16次方等于65536，最多能编码65536个字符</li>
<li>比如汉字“经”的编码是0x7ECF （字符码一般用16进制表示），转换成10进制就是32463</li>
<li>unicode编码从0到127的字符与ASCII编码的字符一样<ul>
<li>比如字母”a”的Unicode 编码是0x0061,十进制是97</li>
<li>而”a”的ASCII编码是0x61,十进制也是97</li>
</ul>
</li>
<li>对于汉字的编码，事实上Unicode对汉字支持不怎么好<ul>
<li>因为简体和繁体总共有六七万个汉字，而UCS-2最多能表示65536个，才六万 多个</li>
<li>所以Unicode只能排除一些几乎不用的汉字</li>
<li>好在常用的简体汉字 也不过七千多个</li>
<li>为了能表示所有汉字，Unicode也有UCS-4规范，就是用 4个字节来编码字符</li>
</ul>
</li>
</ul>
<h5 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h5><ul>
<li>UTF-8(8-bit Unicode Transformation Format)是一种针对Unicode的可变长度字符编码,又称万国码。项目开发中常用utf-8</li>
<li>查看部分unicode码表<br><a href="http://baike.baidu.com/item/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8/12022016?sefr=cr" target="_blank" rel="noopener">http://baike.baidu.com/item/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8/12022016?sefr=cr</a></li>
<li>在线unicode码转换<ul>
<li>网址: <a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/tools/unicode.aspx</a></li>
<li>演示a的unicode \u0061 0x61</li>
<li>演示中的unicode \u4e2d</li>
<li>熟记中文在unicode的范围 \u4E00-\u9FA5 19968 ~ 40869<br><img src="/2017/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_12.png" alt="1586920600288"></li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
  </entry>
</search>
