<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu1810下安装MySQL</title>
    <url>/2018/12/02/2018-12-02-ubuntu1810-xia-an-zhuang-mysql/</url>
    <content><![CDATA[<p>版本:Ubuntu 1810<br>1.切换为root,下载并安装SQL服务器</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">q@q-virtual-machine:~$ su root</span><br><span class="line">密码： </span><br><span class="line">root@q-virtual-machine:/home/q# wget -c https://dev.mysql.com/get/mysql-apt-config_0.8.10-1_all.deb</span><br><span class="line">root@q-virtual-machine:/home/q# dpkg -i mysql-apt-config_0.8.10-1_all.deb </span><br><span class="line">root@q-virtual-machine:/home/q# sudo apt update</span><br><span class="line">root@q-virtual-machine:/home/q# apt-get install mysql-server mysql-client libmysqlclient-dev</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105011139162-1649051620.png" alt=""></p>
<p>查看是否安装成功</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/home/q# systemctl status mysql</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105011421419-1161754551.png" alt=""></p>
<p>遇到错误不紧张:<br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105103412302-844933723.png" alt=""><br>重启</p>
<p>2.修改配置<br>设置远程访问及修改密码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/home/q# mysql </span><br><span class="line">mysql&gt; use mysql;select user, plugin from user;</span><br><span class="line">mysql&gt; update user set authentication_string=password("2557"),plugin='mysql_native_password' where user='root';</span><br><span class="line">mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '456';</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></tbody></table></figure>

<p>一条语句版:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">mysql&gt;use mysql;select user, plugin from user;update user set authentication_string=password("2557"),plugin='mysql_native_password' where user='root';grant all privileges on *.* to 'root'@'%' identified by '456';flush privileges;commit;</span><br></pre></td></tr></tbody></table></figure>

<p>远程登录密码是456<br>本地是2557<br>更改的是本地密码  mysql&gt; set password=password(‘123’);和2557是同等功效<br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105011734978-2032220959.png" alt=""><br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105102305276-1714387986.png" alt=""></p>
<p>&amp;%只在远端登录(可不做  知识扩充)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/home/q# vi  /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">注释掉  #bind-address           = 127.0.0.1</span><br><span class="line"></span><br><span class="line">root@q-virtual-machine:/etc/mysql/mysql.conf.d# mysql </span><br><span class="line">mysql&gt; use mysql </span><br><span class="line">mysql&gt; grant all privileges on *.* to 'root'@'%' identified by '456';</span><br><span class="line">mysql&gt; flush privileges;commit;</span><br><span class="line">q@q-virtual-machine:~$ sudo systemctl restart mysql.service</span><br><span class="line">远端可以使用  密码456</span><br><span class="line">本地登录依然不需要密码</span><br></pre></td></tr></tbody></table></figure>

<p>3.注释掉(要以root权限打开)</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/home/q# cd  /etc/mysql/mysql.conf.d/</span><br><span class="line">root@q-virtual-machine:/etc/mysql/mysql.conf.d# vi mysqld.cnf</span><br><span class="line">注释掉</span><br><span class="line">#bind-address           = 127.0.0.1</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105012146046-1207685549.png" alt=""><br>远端登录成功<br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105111337829-834142522.png" alt=""></p>
<p>4.设置utf-8字符集</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/etc/mysql/mysql.conf.d# sudo gedit /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"></span><br><span class="line">lc-messages-dir	= /usr/share/mysql</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105013641674-858490908.png" alt=""></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">root@q-virtual-machine:/etc/mysql/mysql.conf.d# gedit /etc/mysql/conf.d/mysql.cnf</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105013901523-174469967.png" alt=""></p>
<p>查看效果</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE 'char%';</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105014036031-663821687.png" alt=""></p>
<h1 id="shell脚本-配置ubuntu-3步"><a href="#shell脚本-配置ubuntu-3步" class="headerlink" title="shell脚本   配置ubuntu   3步"></a>shell脚本   配置ubuntu   3步</h1><p>1.t.shell</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"># 注释 文件复制 用于配置字符集utf-8和远端登录</span><br><span class="line">cp  t1.cnf  /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line">cp  t3.cnf  /etc/mysql/conf.d/mysql.cnf</span><br><span class="line"># 设置本地密码2557  开启远端密码456 刷新权限</span><br><span class="line">mysql "mysql" -e"update user set authentication_string=password('2557'),plugin='mysql_native_password' where user='root';grant all privileges on *.* to 'root'@'%' identified by '456';flush privileges;commit;"</span><br><span class="line">echo "everything is ok"</span><br><span class="line"># 重启服务</span><br><span class="line">systemctl restart mysql.service</span><br><span class="line">systemctl enable mysql.service</span><br><span class="line"># 查看字符集utf-8</span><br><span class="line">mysql -uroot -p2557 -e"SHOW VARIABLES LIKE 'char%';"</span><br></pre></td></tr></tbody></table></figure>

<p>2.t1.cnf</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># The MySQL database server configuration file.</span><br><span class="line">#</span><br><span class="line"># You can copy this to one of:</span><br><span class="line"># - "/etc/mysql/my.cnf" to set global options,</span><br><span class="line"># - "~/.my.cnf" to set user-specific options.</span><br><span class="line"># </span><br><span class="line"># One can use all long options that the program supports.</span><br><span class="line"># Run program with --help to get a list of available options and with</span><br><span class="line"># --print-defaults to see which it would actually understand and use.</span><br><span class="line">#</span><br><span class="line"># For explanations see</span><br><span class="line"># http://dev.mysql.com/doc/mysql/en/server-system-variables.html</span><br><span class="line"></span><br><span class="line"># This will be passed to all mysql clients</span><br><span class="line"># It has been reported that passwords should be enclosed with ticks/quotes</span><br><span class="line"># escpecially if they contain "#" chars...</span><br><span class="line"># Remember to edit /etc/mysql/debian.cnf when changing the socket location.</span><br><span class="line"></span><br><span class="line"># Here is entries for some specific programs</span><br><span class="line"># The following values assume you have at least 32M ram</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">socket		= /var/run/mysqld/mysqld.sock</span><br><span class="line">nice		= 0</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#</span><br><span class="line"># * Basic Settings</span><br><span class="line">#</span><br><span class="line">user		= mysql</span><br><span class="line">pid-file	= /var/run/mysqld/mysqld.pid</span><br><span class="line">socket		= /var/run/mysqld/mysqld.sock</span><br><span class="line">port		= 3306</span><br><span class="line">basedir		= /usr</span><br><span class="line">datadir		= /var/lib/mysql</span><br><span class="line">tmpdir		= /tmp</span><br><span class="line">lc-messages-dir	= /usr/share/mysql</span><br><span class="line">character-set-server=utf8</span><br><span class="line">skip-external-locking</span><br><span class="line">#</span><br><span class="line"># Instead of skip-networking the default is now to listen only on</span><br><span class="line"># localhost which is more compatible and is not less secure.</span><br><span class="line"># bind-address		= 127.0.0.1</span><br><span class="line">#</span><br><span class="line"># * Fine Tuning</span><br><span class="line">#</span><br><span class="line">key_buffer_size		= 16M</span><br><span class="line">max_allowed_packet	= 16M</span><br><span class="line">thread_stack		= 192K</span><br><span class="line">thread_cache_size       = 8</span><br><span class="line"># This replaces the startup script and checks MyISAM tables if needed</span><br><span class="line"># the first time they are touched</span><br><span class="line">myisam-recover-options  = BACKUP</span><br><span class="line">#max_connections        = 100</span><br><span class="line">#table_open_cache       = 64</span><br><span class="line">#thread_concurrency     = 10</span><br><span class="line">#</span><br><span class="line"># * Query Cache Configuration</span><br><span class="line">#</span><br><span class="line">query_cache_limit	= 1M</span><br><span class="line">query_cache_size        = 16M</span><br><span class="line">#</span><br><span class="line"># * Logging and Replication</span><br><span class="line">#</span><br><span class="line"># Both location gets rotated by the cronjob.</span><br><span class="line"># Be aware that this log type is a performance killer.</span><br><span class="line"># As of 5.1 you can enable the log at runtime!</span><br><span class="line">#general_log_file        = /var/log/mysql/mysql.log</span><br><span class="line">#general_log             = 1</span><br><span class="line">#</span><br><span class="line"># Error log - should be very few entries.</span><br><span class="line">#</span><br><span class="line">log_error = /var/log/mysql/error.log</span><br><span class="line">#</span><br><span class="line"># Here you can see queries with especially long duration</span><br><span class="line">#slow_query_log		= 1</span><br><span class="line">#slow_query_log_file	= /var/log/mysql/mysql-slow.log</span><br><span class="line">#long_query_time = 2</span><br><span class="line">#log-queries-not-using-indexes</span><br><span class="line">#</span><br><span class="line"># The following can be used as easy to replay backup logs or for replication.</span><br><span class="line"># note: if you are setting up a replication slave, see README.Debian about</span><br><span class="line">#       other settings you may need to change.</span><br><span class="line">#server-id		= 1</span><br><span class="line">#log_bin			= /var/log/mysql/mysql-bin.log</span><br><span class="line">expire_logs_days	= 10</span><br><span class="line">max_binlog_size   = 100M</span><br><span class="line">#binlog_do_db		= include_database_name</span><br><span class="line">#binlog_ignore_db	= include_database_name</span><br><span class="line">#</span><br><span class="line"># * InnoDB</span><br><span class="line">#</span><br><span class="line"># InnoDB is enabled by default with a 10MB datafile in /var/lib/mysql/.</span><br><span class="line"># Read the manual for more InnoDB related options. There are many!</span><br><span class="line">#</span><br><span class="line"># * Security Features</span><br><span class="line">#</span><br><span class="line"># Read the manual, too, if you want chroot!</span><br><span class="line"># chroot = /var/lib/mysql/</span><br><span class="line">#</span><br><span class="line"># For generating SSL certificates I recommend the OpenSSL GUI "tinyca".</span><br><span class="line">#</span><br><span class="line"># ssl-ca=/etc/mysql/cacert.pem</span><br><span class="line"># ssl-cert=/etc/mysql/server-cert.pem</span><br><span class="line"># ssl-key=/etc/mysql/server-key.pem</span><br></pre></td></tr></tbody></table></figure>

<p>3.t3.cnf</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>安装</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS 7(18.10)搭建个人网盘和博客</title>
    <url>/2018/12/01/2018-12-01-centos-7-18-10-da-jian-si-ren-wang-pan-he-bo-ke/</url>
    <content><![CDATA[<h4 id="1-java环境-jdk-8u231-linux-x64-tar-gz-由于原先有jdk7版本-故移除更换"><a href="#1-java环境-jdk-8u231-linux-x64-tar-gz-由于原先有jdk7版本-故移除更换" class="headerlink" title="1. java环境 jdk-8u231-linux-x64.tar.gz 由于原先有jdk7版本,故移除更换"></a>1. <code>java环境 jdk-8u231-linux-x64.tar.gz</code> 由于原先有jdk7版本,故移除更换</h4><p>先上传文件-&gt; 修改环境变量-&gt;解压至此文件下<br>/usr/local/src/java/  文件名为解压名 jdk1.8.0_231（和下面配置环境变量java_HOME路径一致）</p>
<h4 id="2-环境变量配置"><a href="#2-环境变量配置" class="headerlink" title="2. 环境变量配置"></a>2. 环境变量配置</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU java]# vi /etc/profile</span><br><span class="line"> #set java environment</span><br><span class="line">        JAVA_HOME=/usr/local/src/java/jdk1.8.0_231</span><br><span class="line">        CLASSPATH=.:$JAVA_HOME/lib.tools.jar</span><br><span class="line">        PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">        export JAVA_HOME CLASSPATH PATH</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105215256350-1833053104.png" alt=""></p>
<h4 id="3-使环境变量生效"><a href="#3-使环境变量生效" class="headerlink" title="3.使环境变量生效"></a>3.使环境变量生效</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU java]# source /etc/profile</span><br><span class="line">[root@NEU java]# java -version</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105215525171-2010478065.png" alt=""></p>
<h3 id="搭建私有网盘"><a href="#搭建私有网盘" class="headerlink" title="搭建私有网盘"></a>搭建私有网盘</h3><h4 id="解压文件tank-3-0-6-linux-amd64-tar-gz-到-root-blueBall-下执行"><a href="#解压文件tank-3-0-6-linux-amd64-tar-gz-到-root-blueBall-下执行" class="headerlink" title="解压文件tank-3.0.6.linux-amd64.tar.gz 到/root/blueBall 下执行"></a>解压文件tank-3.0.6.linux-amd64.tar.gz 到/root/blueBall 下执行</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU blueBall]# cd tank-3.0.6/</span><br><span class="line">[root@NEU tank-3.0.6]# ./tank</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221141703-376703942.png" alt=""></p>
<h5 id="若执行遇到权限不足，请解压！！！！"><a href="#若执行遇到权限不足，请解压！！！！" class="headerlink" title="若执行遇到权限不足，请解压！！！！"></a>若执行遇到权限不足，请解压！！！！</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU ~]# cd blueBall/</span><br><span class="line">[root@NEU blueBall]# tar -zxvf tank-3.0.6.linux-amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221250471-62857338.png" alt=""></p>
<h5 id="修改默认端口"><a href="#修改默认端口" class="headerlink" title="修改默认端口"></a>修改默认端口</h5><p> <img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221453763-559829577.png" alt=""></p>
<h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><h4 id="修改端口-数据库-用户名和登录密码-startup-sh"><a href="#修改端口-数据库-用户名和登录密码-startup-sh" class="headerlink" title="修改端口,数据库,用户名和登录密码  startup.sh"></a>修改端口,数据库,用户名和登录密码  startup.sh</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># executable path</span><br><span class="line">DIR="$( cd "$( dirname "$0"  )" &amp;&amp; pwd  )"</span><br><span class="line">JAR_PATH=$DIR/blog-1.1.0.jar</span><br><span class="line">#configs</span><br><span class="line">ServerPort=80</span><br><span class="line">#mysql configs</span><br><span class="line">MysqlPort=3306</span><br><span class="line">MysqlHost=192.168.20.20</span><br><span class="line">MysqlSchema=blog</span><br><span class="line">MysqlUsername=root</span><br><span class="line">MysqlPassword=123</span><br><span class="line">MysqlUrl="jdbc:mysql://$MysqlHost:$MysqlPort/$MysqlSchema?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false"</span><br><span class="line">#tank configs</span><br><span class="line">TankUrl="https://tank.eyeblue.cn"</span><br><span class="line">TankEmail=zhenqk@163.com</span><br><span class="line">TankPassword=123456</span><br><span class="line">#admin configs</span><br><span class="line">AdminUsername=Tony</span><br><span class="line">AdminNickname=Tony</span><br><span class="line">AdminEmail=zhenqk@163.com</span><br><span class="line">AdminPassword=123456</span><br><span class="line">#email configs</span><br><span class="line">MailProtocol=smtps</span><br><span class="line">MailHost=smtp.126.com</span><br><span class="line">MailPort=465</span><br><span class="line">MailUsername=zhenqk@126.com</span><br><span class="line">MailPassword=a4877188</span><br><span class="line">MailDefaultEncoding=UTF-8</span><br><span class="line"></span><br><span class="line">OPTS="-Xmx512m -Dserver.port=$ServerPort -Dspring.datasource.url=$MysqlUrl -Dspring.datasource.username=$MysqlUsername -Dspring.datasource.password=$MysqlPassword -Dtank.url=$TankUrl -Dtank.email=$TankEmail -Dtank.password=$TankPassword -Dadmin.username=$AdminUsername -Dadmin.nickname=$AdminNickname -Dadmin.email=$AdminEmail -Dadmin.password=$AdminPassword -Dspring.mail.protocol=$MailProtocol -Dspring.mail.host=$MailHost -Dspring.mail.port=$MailPort -Dspring.mail.username=$MailUsername -Dspring.mail.password=$MailPassword -Dspring.mail.default-encoding=$MailDefaultEncoding"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo $OPTS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JAVA='java'</span><br><span class="line">if [ -z `which java` ]; then</span><br><span class="line">    if [ -z $JAVA_HOME ];</span><br><span class="line">        then</span><br><span class="line">            JAVA=$JAVA_HOME/bin/java</span><br><span class="line">        else</span><br><span class="line">            echo 'Cannot find java command and JAVA_HOME.'</span><br><span class="line">    fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ ! -z `java -version 2&gt;&amp;1 | grep 'java version' | awk '{print $3}' | egrep '1.[8-9].\d*'` ]; then</span><br><span class="line">    nohup $JAVA $OPTS -jar $JAR_PATH &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">    echo $JAR_PATH</span><br><span class="line">    echo 'Started successfully.'</span><br><span class="line">else</span><br><span class="line">        echo 'Java version not support, must be 1.8 or 1.8+.'</span><br><span class="line">fi</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221623514-127261145.png" alt=""><br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221801676-685815260.png" alt=""></p>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@NEU blueBall]# cd blog-1.1.0/</span><br><span class="line">[root@NEU blog-1.1.0]# sh startup.sh</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105221930094-1502045769.png" alt=""><br><img src="https://img2018.cnblogs.com/blog/1508241/202001/1508241-20200105222102331-309170409.png" alt=""></p>
<h2 id="开机软件启动-根目录"><a href="#开机软件启动-根目录" class="headerlink" title="开机软件启动(根目录)"></a>开机软件启动(根目录)</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">sh /root/blueBall/blog-1.1.0/startup.sh</span><br><span class="line">/root/blueBall/tank-3.0.6/tank</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>blueBall</tag>
        <tag>Linux下JDK的安装</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(中)补2</title>
    <url>/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/</url>
    <content><![CDATA[<h2 id="1-每日一问"><a href="#1-每日一问" class="headerlink" title="1.每日一问"></a>1.每日一问</h2><p>1.什么是多态性?什么是虚拟方法调用?<br>对象的多态性:父类的引用指向子类的对象。<br>Person p = new Man();<br>p.eat();<br>调用方法时，编译时看左边，运行时看右边。<br>先会写代码，后面慢慢来</p>
<p>2.一个类可以有几个直接父类?(一个 )一个父类可有多少个子类?子类能获取直接父类的父类中的结构吗?(可以)子类能否获取父类中private 权限的属性或方法?。(可以   getset 方法) 封装解决的能不能调的问题，继承性是能不能获取的问题<br>Ais B 是不是true  可继承</p>
<p>3.方法的重写(override/overwrite)的具体规则有哪些。(非static方法)<br>方法名，形参列表相同。<br>权限修饰符。<br>返回值w<br>抛出的异常</p>
<p>4.super调用构造器，有哪些具体的注意点<br>this(形参列表):本类重载的其它的构造器。<br>super(形参列表):调用父类中指定的构造器。<br>n n-11</p>
<p>5.在下面的代码结构中:使用关键字: this,super;方法的重 写;继承;<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_01.png" alt="题"></p>
<h2 id="2-重写与super"><a href="#2-重写与super" class="headerlink" title="2.重写与super"></a>2.重写与super</h2><h3 id="debug-调试"><a href="#debug-调试" class="headerlink" title="debug 调试"></a>debug 调试</h3><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_02.png" alt="debug 调试"></p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>1.什么是方法的重写(override或overwrite)?  (父类的方法不适合子类)<br>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。<br>2.应用:</p>
<p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际<br>执行的是子类重写父类的方法。</p>
<p>3.举例:<br>cylinder</p>
<p>4.重写的规则:<br>方法的声明:权限修饰符 返回值类型 方法名 (形参列表) throws 异常的类型{<br>//方法体<br>约定俗称:子类中的叫重写的方法，父类中的叫被重写的方法<br>②子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同<br>2子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符<br>事</p>
<blockquote>
<p>特殊情况:子类不能重写父类中声明为private权限的方法<br>③返回值类型:<br>父类被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void<br>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类<br>父类被重写的方法的返回值类型是基本数据类型(比如: double)， 则子类重写的方法的返回值类型必须是相<br>同的基本数据类型(必须也是double)<br>日子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型(具体放到异常处理时候讲)<br>子类和父类中的同名同参数的方法要么都声明为非static的(考虑重写，要么都声明为static的(不是重写).</p>
</blockquote>
<p>5.面试题:<br>区分方法的重写和重载?<br>重载  ，可以在同一个类中可以使用相同方法名和形参列表不同相同相同方法，彼此之间构成重载，<br>构造器可以重载<br>动态绑定</p>
<p>答:<br>①二者的概念:<br>②重载和重写的具体规则<br>③重载:不表现为多 态性。<br>重写:表现为多态性。<br>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它石的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同參数的方法。<br>所以:对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为早绑定或静态绑定”;而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定或动态绑定”。引用一句Bruce Eckel的话:“不要犯傻，如果它不是晚绑定，它就不是多态。”</p>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>1.super关键字可以理解为: 父类的<br>2.可以用来调用的结构:<br>属性、方法、构造器</p>
<p>3.super调用属性、方法:<br>3.1我们可以在子类的方法或构造器中。通过使用”super展性”或“super .方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”superA”<br>3.2特殊情况:当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。<br>3.3特殊情况:当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</p>
<p>4.super调用构造器:</p>
<p>4.1我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器<br>4.2 “super(形参 列表)”的使用，必须声明在子类构造器的首行!<br>4.3我们在类的构造器中，针对于”this(形参列表)”或” super(形参列表)”只能二一，不能同时出现<br>4.4在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的<br>in构造器: super()<br>4.5在类的多个构造器中，至少-一个类的构造器中使用了”super(形参列表)”， 调用父类中的构造器</p>
<p>渐渐领悟</p>
<h2 id="3-子类对象实例化过程及多态性"><a href="#3-子类对象实例化过程及多态性" class="headerlink" title="3.子类对象实例化过程及多态性"></a>3.子类对象实例化过程及多态性</h2><p>1.从结果上看:继承性</p>
<blockquote>
<p>子类继承父类以后，就获取了父类中声明的属性或方法。<br>创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</p>
</blockquote>
<p>2.从过程上看:<br>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，<br>进而调用父类的父类的构造器，… 直到调用了java. lang . object类中空参的构造器为止。<br>正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑<br>进行调用。<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_03.png" alt="从过程上看"></p>
<p>3.强调说明<br>为什么super(… )或this(..)调用语句只能作为构造器中的第- - -句出现?</p>
<p>无论通过哪个构造器创建子类对象，需要保证先初始化父类。<br>目的:当子类继承父类后，“继承”父类中所有的属性和方法，因此子类有必要知道父类如何为对象进行初始化。</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_04.png" alt="强调说明"></p>
<h3 id="多调性的理解"><a href="#多调性的理解" class="headerlink" title="多调性的理解"></a>多调性的理解</h3><p>1.多态性的理解:<br>可以理解为一个事物的多种形态。</p>
<p>2.何为多态性:<br>对象的多态性:父类的引用指向子类的对象(或子类的对象赋给父类的引用)<br>举例:<br>Person p = new Man();<br>objlect obj = new Date();<br>3.多态性的使用: 虚拟方法调用<br>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际<br>执行的是子类重写父类的方法。<br>总结:编译，看左边;运行，看右边。<br>4.多态性的使用前提:<br>①类的继承关系②方法的重写<br>5.多态性的应用举例:<br>猫<br>狗<br>6.多态性使用的注意点:<br>对象的多态性，只适用于方法，不适用于属性(编译和运行都看左边</p>
<h2 id="4-向下转型的使用"><a href="#4-向下转型的使用" class="headerlink" title="4. 向下转型的使用"></a>4. 向下转型的使用</h2><p>/ /不能调用子类所特有的方法、属性:编译时，p2是Person类型。<br>p2. earnMoney();<br>//有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致<br>/ /编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p>
<p>/ /如何才能调用子类特有的属性和方法?<br>/ /向下转型:使用强制类型转换符。<br>Man m1 = (Man)p2;<br>m1. earnMoney(); |<br>m1. isSmoking = true;</p>
<p>有可能转不成功<br>Woman w1=(Woman)p2;<br>w1. goShopping();<br>p2是男的  你把他误以为女的</p>
<p>/ /使用强转时，可能出现ClassCast Exception的异常。<br>Woman W1 = (Woman)p2;<br>w1. goShopping();</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_05.png" alt="向下转型图解"><br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_06.png" alt="向下转型图解"></p>
<h2 id="5-instanceof-关键字的使用"><a href="#5-instanceof-关键字的使用" class="headerlink" title="5.instanceof 关键字的使用"></a>5.instanceof 关键字的使用</h2><h3 id="instanceof关键字的使用"><a href="#instanceof关键字的使用" class="headerlink" title="instanceof关键字的使用"></a>instanceof关键字的使用</h3><ul>
<li>a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false</li>
<li>使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先 进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</li>
<li>如果 a instanceof A返回true,则 a instanceof B也返回true.   父类放着也对<br>其中，类B是类A的父类。</li>
</ul>
<p>Person p2=new Man();</p>
<ul>
<li><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_07.png" alt="instanceof 使用"></li>
</ul>
<h2 id="6-向下转型的几个常用问题"><a href="#6-向下转型的几个常用问题" class="headerlink" title="6.向下转型的几个常用问题"></a>6.向下转型的几个常用问题</h2><p>//练习:<br>, /问题一:编译时通过，运行时不通过<br>//举例一:<br>Person p3 = new Woman( ) ;<br>Man m3 = (Man)p3;<br>/ /举例二:<br>Person p4 = new Person( ) ;<br>Man m4<br>= (Man)p4;<br>/ /问题二:编译通过，运行时也通过<br>object obj = new Woman( );<br>Person p = (Person)obj;<br>/ /问题三:编译不通过<br>Man m5 = new Woman();<br>String str = new Date();<br>开发中向下转型用的比较少</p>
<h2 id="7-多态练习—调用属性和方法"><a href="#7-多态练习—调用属性和方法" class="headerlink" title="7.多态练习—调用属性和方法"></a>7.多态练习—调用属性和方法</h2><p>引用类型是地址值</p>
<ul>
<li><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_08.png" alt="instanceof 使用"></li>
</ul>
<p>开发中不要定义同名的</p>
<p>1.若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，<br>系统将不可能把父类里的方法转移到子类中。编译看左边 运行看右边<br>2.对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，<br>这个实例变量依然不可能覆盖父类中定义的实例变量，编译运行都看左边</p>
<h2 id="8-9-基本操作–多态性"><a href="#8-9-基本操作–多态性" class="headerlink" title="8-9.基本操作–多态性"></a>8-9.基本操作–多态性</h2><p>各种图形的面积  可以利用多态来实现   求面积</p>
<p>重写父类中的面积公式</p>
<p>sub-1</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_09.png" alt="instanceof 使用"></p>
<p>认为是重写   sub_1</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_10.png" alt="instanceof 使用"></p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_11.png" alt="instanceof 使用"></p>
<p>确定的优先调用</p>
<h2 id="11-object-类的使用"><a href="#11-object-类的使用" class="headerlink" title="11 object 类的使用"></a>11 object 类的使用</h2><p>5.7 object 类的使用</p>
<ul>
<li><p>Object类是所有Java类的根父类</p>
<p>Order order = new Order( ) ;<br>System. out . println(order .getClass() . getSuperclass());</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类<br>为java.lang.Object类<br>public class Person {<br>}<br>等价于:<br>public class Person extends Object {<br>}</p>
</li>
<li><p>例: method(Object obj){.. } /可以接收任何类作为其参数<br>Person o=new Person();<br>method(0);</p>
</li>
</ul>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_12.png" alt="object的方法"></p>
<p>java.lang.Object类<br>  1.Object类是所有Java类的根父类<br>  2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类<br>  3.Object类中的功能(属性、方法)就具有通用性。<br>      属性：无<br>   方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()<br>      wait() 、 notify()、notifyAll()</p>
<ol start="4">
<li>Object类只声明了一个空参的构造器</li>
</ol>
<p>clone 复制对象   </p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_13.png" alt="clone的使用"></p>
<p>finalize()  垃圾回收期</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_14.png" alt="垃圾回收器的使用"></p>
<p>  面试题：<br>  final、finally、finalize的区别？</p>
<p>关键字前面2个</p>
<p>finalize 方法名</p>
<h2 id="12-运算符的回顾"><a href="#12-运算符的回顾" class="headerlink" title="12. ==运算符的回顾"></a>12. ==运算符的回顾</h2><h2 id="面试题-和equals-的区别"><a href="#面试题-和equals-的区别" class="headerlink" title="面试题:==和equals()的区别"></a>面试题:==和equals()的区别</h2><p>一、回顾 == 的使用：<br>  == ：运算符</p>
<ol>
<li>可以使用在基本数据类型变量和引用数据类型变量中    10=10.0   char c=10 10=10</li>
<li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同） 自动类型提升<br>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">补充： == 符号使用时，必须保证符号左右两边的变量类型一致。</span><br></pre></td></tr></tbody></table></figure>

<p>  二、equals()方法的使用：</p>
<ol>
<li>是一个方法，而非运算符</li>
<li>只能适用于引用数据类型</li>
<li>Object类中equals()的定义：<br>public boolean equals(Object obj) {<pre><code>return (this == obj);</code></pre>  }<br>说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</li>
<li>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是<br>两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</li>
<li>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们<br>就需要对Object类中的equals()进行重写.<br>重写的原则：比较两个对象的实体内容是否相同.</li>
</ol>
<p>—-ppt</p>
<ul>
<li>==:<ul>
<li>基本类型比较值:只要两个变量的值相等，即为true。<br>int a=5; if(a==6)..}</li>
<li>引用类型比较引用(是否指向同一个对象):只有指向同一个对象时，==才<br>返回true。<br>Person p1 =new Person();<br>Person p2=new Person();<br>if (p1==p2)…}<ul>
<li>用“==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本<br>数据类型除外)，否则编译出错</li>
</ul>
</li>
</ul>
</li>
<li>equals();所有类都继承了Object,也就获得了equals()方法。还可以重写。<br>➢只能比较引用类型，其作用与“卜=”相同,比较是否指向同一个对象。<br>➢格式:obj1.equals(obj2)</li>
<li>特例:当用equals()方法进行比较时，对类File、String、 Date 及包装类.<br>(Wrapper Class)来说，是比较类型及内容而不考虑引用的是否是同一个对<br>象;<br>➢原因:在这些类中重写了Object类的equals()方法。</li>
<li>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都<br>相等</li>
</ul>
<h3 id="重写equals-方法的原则"><a href="#重写equals-方法的原则" class="headerlink" title="重写equals()方法的原则."></a>重写equals()方法的原则.</h3><ul>
<li>对称性:如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是“true”</li>
<li>自反性: x.equals(x)必须返回是“true</li>
<li>传递性:如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”<br>那么z.equals(x)也应该返回是“true”。</li>
<li>一 致性:如果x.equals(y)返回是“true” ，只要x和y内容一直不变， 不管你<br>重复x.equals(y)多少次，返回都是“true” 。</li>
<li>任何情况下，x.equal(null)， 永远返回是“false<br>x.equals(和x不同类型的对象)永远返回是“false<br>”</li>
<li>从我面试的反馈，85%的求职者“理直气壮”的回答错误…<br>1.==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型<br>就是比较内存地址<br>2.equals的话， 它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也<br>是==;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中<br>用的比较多，久而久之，形成了equals是比较值的错误观点。<br>3.具体要看自定义类里有没有重写Object的equals方法来判断。<br>4通常情况下，重写equals方法， 会比较类中的相应属性是否都相等。</li>
</ul>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_15.png" alt="字符串比较地址值"></p>
<h2 id="13-equals-的使用"><a href="#13-equals-的使用" class="headerlink" title="13.equals()的使用"></a>13.equals()的使用</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_16.png" alt="string 进行过重写"><br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_17.png" alt="date进行过重写"></p>
<h2 id="14-重写equals-方法"><a href="#14-重写equals-方法" class="headerlink" title="14.重写equals() 方法"></a>14.重写equals() 方法</h2><p>找例子   String 重写equals  源代码</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_18.png" alt="自定义equals()"></p>
<p>字符串等引用类型   equals()</p>
<p>方法2</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_19.png" alt="自定义equals()"></p>
<h3 id="自动生成-General-代码自动生成"><a href="#自动生成-General-代码自动生成" class="headerlink" title="自动生成   General  代码自动生成"></a>自动生成   General  代码自动生成</h3><p>逻辑性更强</p>
<h2 id="15-总结-与equals"><a href="#15-总结-与equals" class="headerlink" title="15. 总结==与equals()"></a>15. 总结==与equals()</h2><h2 id="16-equals-方法的练习"><a href="#16-equals-方法的练习" class="headerlink" title="16.equals 方法的练习"></a>16.equals 方法的练习</h2><p>对象之间不能用 ==  因为new的会改变地址  ，==比较的是地址</p>
<blockquote>
<p>自定义的类也要重写equals ，当在子类中需要的时候</p>
</blockquote>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_20.png" alt="重写equals()注意"></p>
<h2 id="17-toString-的使用"><a href="#17-toString-的使用" class="headerlink" title="17.toString()的使用"></a>17.toString()的使用</h2><p>  Object类中toString()的使用：<br>  1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString()<br>  2.Object类中toString()的定义：<br>    public String toString() {<br>        return getClass().getName() + “@” + Integer.toHexString(hashCode());<br>     }<br>  3.像String、Date、File、包装类等都重写了Object类中的toString()方法。<br>     使得在调用对象的toString()时，返回”实体内容”信息</p>
<p>  4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p>
<p>自定义 手动<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_21.png" alt="重写equals()注意"></p>
<p>系统生成</p>
<h2 id="19-objetc类的练习"><a href="#19-objetc类的练习" class="headerlink" title="19 objetc类的练习"></a>19 objetc类的练习</h2><p>if(obj instanceof Circcle){</p>
<p>Circle c=(Circle)obj;</p>
<p>return this.radius==c.radius;</p>
<p>}</p>
<h2 id="20-单元测试方法的使用"><a href="#20-单元测试方法的使用" class="headerlink" title="20.单元测试方法的使用"></a>20.单元测试方法的使用</h2><p>新建类 JUnitTest.java</p>
<p>选中当前工程-&gt;右键build Path-&gt;add libraries-&gt;JUnit-&gt;finish</p>
<p> Java中的JUnit单元测试</p>
<p>  步骤：<br>  1.选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步<br>  2.创建Java类，进行单元测试。<br>    此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器<br>  3.此类中声明单元测试方法。<br>    此时的单元测试方法：方法的权限是public,没有返回值，没有形参</p>
<p>  4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p>
<p>  5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。<br>  6.写完代码以后，左键双击单元测试方法名，右键：run as -&gt; JUnit Test</p>
<p>  说明：<br>  1.如果执行结果没有任何异常：绿条<br>  2.如果执行结果出现异常：红条</p>
<p>把测试方法当成静态的了</p>
<p>真正开发</p>
<p>@test 导包就可以</p>
<h2 id="21-包装类的理解"><a href="#21-包装类的理解" class="headerlink" title="21.包装类的理解"></a>21.包装类的理解</h2><p>5.8 包装类的使用</p>
<ul>
<li>针对八种基本数据类型定义相应的引用类型一包装类(封装类)</li>
<li>有了类的特点，就可以调用类中的方法，Java才是真正的面向对象<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_22.png" alt="包装类"></li>
<li>基本数据类型包装成包装类的实例__装箱<ul>
<li>通过包装类的构造器实现:<br>int i= 500; Integer t = new Integer();</li>
<li>还可以通过字符串参数构造包装类对象:<br>Float f= new Float(“4. 56”);<br>Long I = new Long(“asdf” ); //NumberFormatException</li>
</ul>
</li>
<li>获得包装类对象中包装的基本类型变量–拆箱<br>-调用包装类的.xxxValue()方法:<br>boolean b = bObj .booleanValue();</li>
<li>JDK1.5之后，支持自动裝箱，自动拆箱。但类型必须匹配。</li>
<li>字符串转换成基本数据类型<ul>
<li>通过包装类的构造器实现:<br>int i = new Integer(“12”);</li>
<li>通过包装类的parseXxx(String s)静态方法:<br>Float f= Float.parseFloat(“12.1”);</li>
</ul>
</li>
<li>基本数据类型转换成字符串<ul>
<li>调用字符串重载的valueOf()方法: .<br>String fstr = String.valueOf(2.34f);</li>
<li>更直接的方式:<br>String intStr= 5 +“”</li>
</ul>
</li>
</ul>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_23.png" alt="包装类"></p>
<h2 id="22-基本数据类型转化为包装类"><a href="#22-基本数据类型转化为包装类" class="headerlink" title="22.基本数据类型转化为包装类"></a>22.基本数据类型转化为包装类</h2><p>包装类的使用<br>  1.java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征<br>  2.掌握的：基本数据类型、包装类、String三者之间的相互转换</p>
<p>//基本数据类型 —&gt;包装类：调用包装类的构造器</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_24.png" alt="包装类"></p>
<p>boolean isMale;</p>
<p>Boolean isFemale;  是个类</p>
<h2 id="23-包装类转化基本数据类型"><a href="#23-包装类转化基本数据类型" class="headerlink" title="23.包装类转化基本数据类型"></a>23.包装类转化基本数据类型</h2><p>​    //包装类—&gt;基本数据类型:调用包装类Xxx的xxxValue()</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">	public void test2(){</span><br><span class="line">		Integer in1 = new Integer(12);</span><br><span class="line">		</span><br><span class="line">		int i1 = in1.intValue();</span><br><span class="line">		System.out.println(i1 + 1);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Float f1 = new Float(12.3);</span><br><span class="line">		float f2 = f1.floatValue();</span><br><span class="line">		System.out.println(f2 + 1);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="24-自动装箱和拆箱"><a href="#24-自动装箱和拆箱" class="headerlink" title="24.自动装箱和拆箱"></a>24.自动装箱和拆箱</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="comment">//  JDK 5.0 新特性：自动装箱 与自动拆箱</span></span><br><span class="line">	 /</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>{</span><br><span class="line"><span class="comment">//		int num1 = 10;</span></span><br><span class="line"><span class="comment">//		//基本数据类型--&gt;包装类的对象</span></span><br><span class="line"><span class="comment">//		method(num1);</span></span><br><span class="line"><span class="comment">//上面独立	</span></span><br><span class="line">		<span class="comment">//自动装箱：基本数据类型 ---&gt;包装类</span></span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">		Integer in1 = num2;<span class="comment">//自动装箱</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> b1 = <span class="keyword">true</span>;</span><br><span class="line">		Boolean b2 = b1;<span class="comment">//自动装箱</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//自动拆箱：包装类---&gt;基本数据类型</span></span><br><span class="line">		System.out.println(in1.toString());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> num3 = in1;<span class="comment">//自动拆箱</span></span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Object obj)</span></span>{</span><br><span class="line">		System.out.println(obj);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="25-基本数据类型、包装类与String间的相互转化"><a href="#25-基本数据类型、包装类与String间的相互转化" class="headerlink" title="25.基本数据类型、包装类与String间的相互转化"></a>25.基本数据类型、包装类与String间的相互转化</h2><p>//基本数据类型、包装类—&gt;String类型：调用String重载的valueOf(Xxx xxx)<br>    @Test</p>
<p>​        </p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">	<span class="comment">//方式1：连接运算</span></span><br><span class="line">	String str1 = num1 + <span class="string">""</span>;</span><br><span class="line">	<span class="comment">//方式2：调用String的valueOf(Xxx xxx)</span></span><br><span class="line">	<span class="keyword">float</span> f1 = <span class="number">12.3f</span>;</span><br><span class="line">	String str2 = String.valueOf(f1);<span class="comment">//"12.3"</span></span><br><span class="line">	</span><br><span class="line">	Double d1 = <span class="keyword">new</span> Double(<span class="number">12.4</span>);</span><br><span class="line">	String str3 = String.valueOf(d1);</span><br><span class="line">	System.out.println(str2);</span><br><span class="line">	System.out.println(str3);<span class="comment">//"12.4"</span></span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>// //String类型 —&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>{</span><br><span class="line">		String str1 = <span class="string">"123"</span>;</span><br><span class="line">		<span class="comment">//错误的情况：</span></span><br><span class="line"><span class="comment">//		int num1 = (int)str1;</span></span><br><span class="line"><span class="comment">//		Integer in1 = (Integer)str1;</span></span><br><span class="line">		<span class="comment">//可能会报NumberFormatException</span></span><br><span class="line">		<span class="keyword">int</span> num2 = Integer.parseInt(str1);</span><br><span class="line">		System.out.println(num2 + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		String str2 = <span class="string">"true1"</span>;  不是标准的<span class="keyword">true</span>  都是<span class="keyword">false</span></span><br><span class="line">		<span class="keyword">boolean</span> b1 = Boolean.parseBoolean(str2);</span><br><span class="line">		System.out.println(b1);</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="26-包装类常见面试题"><a href="#26-包装类常见面试题" class="headerlink" title="26.包装类常见面试题"></a>26.包装类常见面试题</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_26.png" alt="包装类1-2"></p>
<p>第一题  1.0  由于类型提升，要求统一类型</p>
<p>第二题:  1   没有要求统一类型</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_25.png" alt="包装类面试题3"></p>
<p> false   地址</p>
<p>true</p>
<p>false  有个缓存数组 1-127   new 的</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_27.png" alt="包装类面试3 解答"></p>
<h2 id="27-包装类的练习"><a href="#27-包装类的练习" class="headerlink" title="27 包装类的练习"></a>27 包装类的练习</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-2/13_28.png" alt="包装类面试3 解答"></p>
<p>想放多少放多少</p>
<p>先写思路</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.exer4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"> 练习</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  利用Vector代替数组处理：从键盘读入学生成绩（以负数代表输入结束），找出最高分，并输出学生成绩等级。</span></span><br><span class="line"><span class="comment">	提示：数组一旦创建，长度就固定不变，所以在创建数组前就需要知道它的长度。</span></span><br><span class="line"><span class="comment">	而向量类java.util.Vector可以根据需要动态伸缩。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	创建Vector对象：Vector v=new Vector();</span></span><br><span class="line"><span class="comment">	给向量添加元素：v.addElement(Object obj);   //obj必须是对象</span></span><br><span class="line"><span class="comment">	取出向量中的元素：Object  obj=v.elementAt(0);</span></span><br><span class="line"><span class="comment">	注意第一个元素的下标是0，返回值是Object类型的。</span></span><br><span class="line"><span class="comment">	计算向量的长度：v.size();</span></span><br><span class="line"><span class="comment">	若与最高分相差10分内：A等；20分内：B等；</span></span><br><span class="line"><span class="comment">	      30分内：C等；其它：D等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//1.实例化Scanner，用于从键盘获取学生成绩</span></span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2.创建Vector对象：Vector v=new Vector();相当于原来的数组</span></span><br><span class="line">		Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//3.通过for(;;)或while(true)方式，给Vector中添加数组</span></span><br><span class="line">		<span class="keyword">int</span> maxScore = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(;;){</span><br><span class="line">			System.out.println(<span class="string">"请输入学生成绩（以负数代表输入结束）"</span>);</span><br><span class="line">			<span class="keyword">int</span> score = scan.nextInt();</span><br><span class="line">			<span class="comment">//3.2 当输入是负数时，跳出循环</span></span><br><span class="line">			<span class="keyword">if</span>(score &lt; <span class="number">0</span>){</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">if</span>(score &gt; <span class="number">100</span>){</span><br><span class="line">				System.out.println(<span class="string">"输入的数据非法，请重新输入"</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">//3.1 添加操作：：v.addElement(Object obj)</span></span><br><span class="line">			<span class="comment">//jdk5.0之前：</span></span><br><span class="line"><span class="comment">//			Integer inScore = new Integer(score);</span></span><br><span class="line"><span class="comment">//			v.addElement(inScore);//多态</span></span><br><span class="line">			<span class="comment">//jdk5.0之后：</span></span><br><span class="line">			v.addElement(score);<span class="comment">//自动装箱</span></span><br><span class="line">			<span class="comment">//4.获取学生成绩的最大值</span></span><br><span class="line">			<span class="keyword">if</span>(maxScore &lt; score){</span><br><span class="line">				maxScore = score;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//5.遍历Vector，得到每个学生的成绩，并与最大成绩比较，得到每个学生的等级。</span></span><br><span class="line">		<span class="keyword">char</span> level;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; v.size();i++){</span><br><span class="line">			Object obj = v.elementAt(i);</span><br><span class="line">			<span class="comment">//jdk 5.0之前：</span></span><br><span class="line"><span class="comment">//			Integer inScore = (Integer)obj;</span></span><br><span class="line"><span class="comment">//			int score = inScore.intValue();</span></span><br><span class="line">			<span class="comment">//jdk 5.0之后：</span></span><br><span class="line">			<span class="keyword">int</span> score = (<span class="keyword">int</span>)obj;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(maxScore - score &lt;= <span class="number">10</span>){</span><br><span class="line">				level = <span class="string">'A'</span>;</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">20</span>){</span><br><span class="line">				level = <span class="string">'B'</span>;</span><br><span class="line">			}<span class="keyword">else</span> <span class="keyword">if</span>(maxScore - score &lt;= <span class="number">30</span>){</span><br><span class="line">				level = <span class="string">'C'</span>;</span><br><span class="line">			}<span class="keyword">else</span>{</span><br><span class="line">				level = <span class="string">'D'</span>;</span><br><span class="line">			}</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"student-"</span> + i + <span class="string">" score is "</span> + score + <span class="string">",level is "</span> + level);</span><br><span class="line">			</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(中)补1</title>
    <url>/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1. 每日一考"></a>1. 每日一考</h2><p>Arraylist 替换数组   可扩展长度—</p>
<h2 id="2-复习"><a href="#2-复习" class="headerlink" title="2.复习"></a>2.复习</h2><p>项目要求<br>1.看着一边写  一边理解，<br>2.自己去写  试着自己去完成，写不动看文档修饰  看源码  试着独立完成<br>全屏看，看完这个类以后 ，收起来，自己去写，写的时候写不动  看文档提示，再去写，<br>在写不动， 看源码  ，指导咋写 在手些   手写来，在接着写<br>3.</p>
<ol>
<li>至少独立完成一遍以 上的项目代码</li>
<li>积累完成项目的过程中常见的bug的调试<br>方式一‘<br>“硬”看，必要时，添加输出语句。<br>方式二：<br>Debug       逻辑  业务 </li>
<li>捋顺思路,强化逻辑</li>
<li>对象、数组等内存结构的解析</li>
<li>遵守编码的规范,标识符的命名规范等</li>
<li>在类前，方法前，方法内具体逻辑的实现步骤等添加必要的注释.<br>文档注释<br>逻辑步骤： 单行和多行注释</li>
</ol>
<h2 id="3-继承性"><a href="#3-继承性" class="headerlink" title="3.继承性"></a>3.继承性</h2><ol>
<li>为什么要有类的继承性? (继承性的好处)<br>①减少了代码的冗余，提高代码复用性<br>②便于功能的扩展<br>③为之后多态性的使用，提供了前提<br>图示:<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_01.png" alt="继承性复习"></li>
<li>继承性的格式:</li>
</ol>
<p>class A extends B{ }<br>A:子类、派生类、subclass .<br>B:父类、超类、基类、superclass</p>
<ol start="3">
<li>子类继承父类以后有哪些不同?</li>
</ol>
<p>3.1体现: 一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。<br>*特别的， 父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。<br>3.2子类继承父类以后，还可以声明自己特有的属性或方法:实现功能的拓展。<br>子类和父类的关系，不同于子集和集合的关系。<br>extends:延展、扩展</p>
<ol start="4">
<li>Java中继承性的说明</li>
</ol>
<p>1.一个类可以被多个子类继承。<br>2.Java中类的单继承性:一个类只能有一个父类<br>3.子父类是相对的概念。<br>4.子类直接继承的父类，称为:直接父类。间接继承的父类称为:间接父类<br>5.子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</p>
<p>图示:<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_02.png" alt="继承性的说明"></p>
<ol start="5">
<li>java. lang . object类的理解<br>1.如果我们没显式的声明一个类的父类的话，则此类继承于java.1ang . object类<br>2.所的java类(除java.1ang. object类之外都直接或间接的继承于java. lang. object类<br>3.意味着，所的java类具有java. lang. object类声明的功能。</li>
</ol>
<h2 id="4-5-继承性的练习，基本操作（练习）"><a href="#4-5-继承性的练习，基本操作（练习）" class="headerlink" title="4-5. 继承性的练习，基本操作（练习）"></a>4-5. 继承性的练习，基本操作（练习）</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_03.png" alt="练习"><br>紫色的箭头表示继承</p>
<h2 id="6-7Eclipse-Debug的使用"><a href="#6-7Eclipse-Debug的使用" class="headerlink" title="6-7Eclipse Debug的使用"></a>6-7Eclipse Debug的使用</h2><ol>
<li><h3 id="System-out-println-适合小项目"><a href="#System-out-println-适合小项目" class="headerlink" title="System.out.println(). 适合小项目"></a>System.out.println(). 适合小项目</h3></li>
</ol>
<h3 id="Eclipse-Debug调试"><a href="#Eclipse-Debug调试" class="headerlink" title="Eclipse - Debug调试"></a>Eclipse - Debug调试</h3><p> 1.设置断点   关卡<br> 2.debug as–》 java application<br> 3.操 做   –》进入透视图</p>
<p>f6   一行代i码 一行代码走—&gt;执行<br> f5  函数方法里面    到方法实现哪一行用<br>F7 跳出方法<br>resume  到下一个断点<br>进入t<br>drop into  方法的初始部分<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_04.png" alt="F5的说明"></p>
<h2 id="8-解决Debug中step-into功能失灵问题"><a href="#8-解决Debug中step-into功能失灵问题" class="headerlink" title="8.解决Debug中step into功能失灵问题"></a>8.解决Debug中step into功能失灵问题</h2><p>配置debug Configuration<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_05.png" alt="配置debug Configuration"><br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_06.png" alt="配置debug Configuration2"></p>
<h2 id="9-方法重写的理解"><a href="#9-方法重写的理解" class="headerlink" title="9.方法重写的理解"></a>9.方法重写的理解</h2><h3 id="override-overwrite"><a href="#override-overwrite" class="headerlink" title="override/overwrite"></a>override/overwrite</h3><ul>
<li>定义：在子类中可以根据需要对从父继承来的方法进行改造， 在程序执行时，子类的方法将覆盖父。 在程序执行时，子类的方法将覆盖父。</li>
<li>要求:<ul>
<li>子类重写的方法 必须 和父类被重写的方法 具有相同的 方法名称、 参数 列表</li>
<li>子类重写的方法返回值型 不能大于 父类被重写的方法返回值型</li>
<li>子类重写的方法使用访问权限 不能小于 父类被重写的方法访问权限<br>子类不能重写父中声明为 private 权限的方法</li>
<li>子类方法抛出的异常不能大于父被重写方法的异常</li>
</ul>
</li>
<li>注意<br>子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为<br>static的(不是重写)。因为static方法是属于类的，子类无法覆盖父类的方法。</li>
</ul>
<hr>
<h3 id="1-重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作"><a href="#1-重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作" class="headerlink" title="1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作"></a>1.重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</h3><h3 id="2-应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。"><a href="#2-应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。" class="headerlink" title="2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。"></a>2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</h3><h2 id="10-方法重写的细节"><a href="#10-方法重写的细节" class="headerlink" title="10. 方法重写的细节"></a>10. 方法重写的细节</h2><h3 id="3-重写的规定："><a href="#3-重写的规定：" class="headerlink" title="3.重写的规定："></a>3.重写的规定：</h3><p>方法的声明： 权限修饰符  返回值类型  方法名(形参列表) throws 异常的类型{<br>                //方法体<br>                      }<br>  约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法<br>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同<br>② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符   —-摊煎饼</p>
<h4 id="特殊情况：子类不能重写父类中声明为private权限的方法"><a href="#特殊情况：子类不能重写父类中声明为private权限的方法" class="headerlink" title="特殊情况：子类不能重写父类中声明为private权限的方法"></a>特殊情况：子类不能重写父类中声明为private权限的方法</h4><p>权限修饰  除了 private 都是重写<br>③ 返回值类型：<br>     &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void<br>       &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</p>
<blockquote>
<p>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)<br>④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）<br>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）  静态方法不能被重写，随着类的加载而加载<br>— 开发中直接粘贴就可以了—重写<br>wal+ alt+/</p>
</blockquote>
<h2 id="11-f方法重写的练习"><a href="#11-f方法重写的练习" class="headerlink" title="11 f方法重写的练习"></a>11 f方法重写的练习</h2><h2 id="12-测试4种不同的权限修饰"><a href="#12-测试4种不同的权限修饰" class="headerlink" title="12. 测试4种不同的权限修饰"></a>12. 测试4种不同的权限修饰</h2><p>/ /同一个包中的其他类，不可以调用Order类中私有的属性、方法<br>order.orderPrivate = 4;<br>order . methodPrivate( ) ;</p>
<p>//在不同包的子类中，不能调用Order类中声明为private和缺省权限的属性、方法<br>orderDefault = 3;<br>orderPrivate = 4;</p>
<p>//不同包下的普通类(非子类)要使用Order类，不可以调用声明为private、缺省、protected权限的属性、方法<br>order. orderPrivate = 2;<br>order. orderDefault = 3;<br>order. orderProtected = 4;</p>
<p>对于class的权限修饰只可以用public利和Idefault(缺省)。<br>public类可以在任意地方被访问。<br>default类只可以被同一个包内部的类访问。<br>用的最多是public   private</p>
<h2 id="13-super调用属性和方法"><a href="#13-super调用属性和方法" class="headerlink" title="13.super调用属性和方法"></a>13.super调用属性和方法</h2><h3 id="关键字super"><a href="#关键字super" class="headerlink" title="关键字super"></a>关键字super</h3><p>用父类被重写的属性和方法</p>
<p> 1.super理解为：父类的<br> 2.super可以用来调用：属性、方法、构造器<br> 3.super的使用：调用属性和方法<br>3.1 我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用 父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”   –子类没有<br>3.2 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的 使用”super.属性”的方式，表明调用的是父类中声明的属性。   往上找<br>3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的 使用”super.方法”的方式，表明调用的是父类中被重写的方法。<br>4.super调用构造器<br> 4.1  我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器<br> 4.2 “super(形参列表)”的使用，必须声明在子类构造器的首行！<br> 4.3 我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现<br> 4.4 在构造器的首行，没有显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()<br> 4.5 在类的多个构造器中，至少有一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p>
<p>输出结果是一样的<br>由于子类中没有age ，只有父类有<br>System. out . println(“name = “ + this.name + “，age = “ + super.age);</p>
<h2 id="14-super调用构造器"><a href="#14-super调用构造器" class="headerlink" title="14. super调用构造器"></a>14. super调用构造器</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_07.png" alt="super 生成构造器"><br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_08.png" alt="super 调用构造器"></p>
<h2 id="15-子类对象实例化的全过程"><a href="#15-子类对象实例化的全过程" class="headerlink" title="15.子类对象实例化的全过程"></a>15.子类对象实例化的全过程</h2><h4 id="5-5子类对象实例化的过程-为什么能用？"><a href="#5-5子类对象实例化的过程-为什么能用？" class="headerlink" title="5.5子类对象实例化的过程   为什么能用？"></a>5.5子类对象实例化的过程   为什么能用？</h4><ol>
<li>从结果上来看：（继承性）<br>子类继承父类以后，就获取了父类中声明的属性或方法。<br> 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。</li>
<li>从过程上来看：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">		当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，...</span><br><span class="line"> 直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。</span><br><span class="line">明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_09.png" alt="子类对象实例化的过程"><br>子类 间接或直接调用父类构造器</p>
<h2 id="16-继承和super练习"><a href="#16-继承和super练习" class="headerlink" title="16 继承和super练习"></a>16 继承和super练习</h2><p>银行</p>
<h2 id="17-多态性的使用"><a href="#17-多态性的使用" class="headerlink" title="17.多态性的使用"></a>17.多态性的使用</h2><ul>
<li>多态性，是面向对象中最重要的概念 ，在Java 中的体现:<br>对象 的多态性：父类的引用指向子对象 <ul>
<li>可以 直接应用在抽象类和接口上</li>
</ul>
</li>
<li>Java引用变量有两个类型:<code>编译时类型和运行时类型</code>。编译时类型由声明<br>该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简<br>称: <code>编译时，看左边;运行时，看右边</code>。<ul>
<li>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphi sm)</li>
<li>多态情况下，“看左边”:看的是父类的引用(父类中不具备子类特有的方法)<br>“看右边”:看的是子类的对象(实际运行的是子类重写父类的方法)</li>
</ul>
</li>
<li>对象的多态一 - —-在Java中,子类的对象可以替代父类的对象使用<ul>
<li>一个变量只能有一种确定的数据类型</li>
<li>一个引用类型变量可能指向(引用)侈种不同类型的对象<br>Person p = new Student();<br>Object 0 = new Person();//Object类型的变量o，指向Person类型的对象<br>o = new Student(); //Object类型的变量o，指向Student类型的对象</li>
<li>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象:向上转型(upcasting)。</li>
</ul>
</li>
</ul>
<p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法:<br>Student m = new Student();<br>m.school =“pku”;  //合法,Student类有school成员变量<br>Person e = new Student();<br>e.school =“pku”; //非法,Person类没 有school成员变量<br>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编<br>译错误。</p>
<hr>
<p>1.理解多态性：可以理解为一个事物的多种形态。<br>2.何为多态性：<br>    对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p>
<ol start="3">
<li>多态的使用：虚拟方法调用<br>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。<br>总结：编译，看左边；运行，看右边。</li>
</ol>
<p>4.多态性的使用前提：  ① 类的继承关系  ② 方法的重写</p>
<p>5.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_10.png" alt="父类"><br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_11.png" alt="Man子类"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_12.png" alt="WoMan子类"></h2><p> 多态性的使用<br>  <img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_13.png" alt="test"></p>
<p>秘书给我找个人，他能吃东西，结果她找的是男人，</p>
<p>p2.earnMony();  不能使用 ，父类没有什么这个方法</p>
<p>编译生成什么类型就能点出什么类型，p2只调用person里面有的方法 </p>
<p>执行的时候是子类重写的  </p>
<p>p2.eat()  点到父类了</p>
<p>p2 是个person</p>
<h2 id="18-多态性的使用举例"><a href="#18-多态性的使用举例" class="headerlink" title="18.多态性的使用举例"></a>18.多态性的使用举例</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_14.png" alt="没有多态性的缺点"></p>
<p>有了多态性</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_15.png" alt="没有多态性的缺点"></p>
<p>没有多态性   会造成很多重载的方法</p>
<p>equals （子类类型）</p>
<p>举例</p>
<p>Driver  先建立连接 </p>
<p>三种数据库的连接</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_16.png" alt="重写的举例"></p>
<h2 id="19-多态性不适合于属性"><a href="#19-多态性不适合于属性" class="headerlink" title="19.多态性不适合于属性"></a>19.多态性不适合于属性</h2><h2 id="20-虚拟方法调用的再理解"><a href="#20-虚拟方法调用的再理解" class="headerlink" title="20 虚拟方法调用的再理解"></a>20 虚拟方法调用的再理解</h2><h3 id="虚拟方法调用-Virtual-Method-Invocation"><a href="#虚拟方法调用-Virtual-Method-Invocation" class="headerlink" title="虚拟方法调用(Virtual Method Invocation)"></a>虚拟方法调用(Virtual Method Invocation)</h3><ul>
<li><p>正常的方法调用<br>Person e = new Person();<br>e.getInfo();<br>Student e = new Student();<br>e.getlInfo();</p>
<ul>
<li>虚拟方法调用(多态情况下)<br>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父<br>类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法<br>确定的。<br>Person e = new Student();<br>e.getInfo();调 用Student类的getInfo()方法</li>
</ul>
</li>
<li><p>编译时类型和运行时类型<br>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类<br>的getlnfo()方法。一-动态绑定</p>
</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题:"></a>面试题:</h2><p>多态是编译时行为还是<code>运行时行为</code> 若随机呢?</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">//面试题：多态是编译时行为还是运行时行为？</span></span><br><span class="line"><span class="comment">//证明如下：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>  </span>{</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"animal eat food"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>{</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"cat eat fish"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>{</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"Dog eat bone"</span>);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span>  <span class="keyword">extends</span> <span class="title">Animal</span>  </span>{</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"Sheep eat grass"</span>);</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewTest</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal  <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> key)</span> </span>{</span><br><span class="line">		<span class="keyword">switch</span> (key) {</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Cat ();</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Dog ();</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Sheep ();</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="keyword">int</span> key = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		System.out.println(key);</span><br><span class="line"></span><br><span class="line">		Animal  animal = getInstance(key);</span><br><span class="line">		</span><br><span class="line">		animal.eat();</span><br><span class="line">		 </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_17.png" alt="虚拟方法调用的理解"></p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_18.png" alt="重载和重写的区别"></p>
<h3 id="多态小结"><a href="#多态小结" class="headerlink" title="多态小结"></a>多态小结</h3><ul>
<li>多态作用:<br>提高了代码的通用性，常称作接口重用</li>
<li>前提:<br>需要存在继承或者实现关系<br>有方法的重写</li>
<li>成员方法:<br>编译时:要查看引用变量所声明的类中是否有所调用的方法。<br>运行时:调用实际new的对象所属的类中的重写方法。</li>
<li>成员变量:<br>不具备多态性，只看引用变量所声明的类。</li>
</ul>
<hr>
<p>代码</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">animal</span></span>{</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="comment">//4.吃骨头</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"吃骨头"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> <span class="keyword">extends</span> <span class="title">animal</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>{</span><br><span class="line">		System.out.println(<span class="string">"吃老鼠"</span>);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">duotai</span> </span>{</span><br><span class="line">	<span class="comment">//3.调用子类的相应方法 ,如传入new dog()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(animal d)</span> </span>{</span><br><span class="line">	d.eat();</span><br><span class="line">}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		<span class="comment">//1.类的实体化</span></span><br><span class="line">		duotai dt=<span class="keyword">new</span> duotai();</span><br><span class="line">		<span class="comment">//2.调dt里面的方法，传入子类 new 对象，调谁用谁</span></span><br><span class="line">		dt.func(<span class="keyword">new</span> dog());</span><br><span class="line">		dt.func(<span class="keyword">new</span> cat());</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="可以实现不同子类间的相同方法"><a href="#可以实现不同子类间的相同方法" class="headerlink" title="可以实现不同子类间的相同方法"></a>可以实现不同子类间的相同方法</h3><p>图解<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong-bu-1/12_19" alt=""></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(中)</title>
    <url>/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/</url>
    <content><![CDATA[<h2 id="1-每日一考"><a href="#1-每日一考" class="headerlink" title="1. 每日一考"></a>1. 每日一考</h2><h3 id="1-构造器的作用是什么-使用中有哪些注意点-gt-3条"><a href="#1-构造器的作用是什么-使用中有哪些注意点-gt-3条" class="headerlink" title="1.构造器的作用是什么?使用中有哪些注意点(>=3条)"></a>1.构造器的作用是什么?使用中有哪些注意点(&gt;=3条)</h3><p>①创建对象②初始化对象结构</p>
<h3 id="2-关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，"><a href="#2-关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，" class="headerlink" title="2.关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，"></a>2.关于类的属性的赋值，有几种赋值的方式。谈谈赋值的先后顺序，</h3><p>默认初始化显式初始化构造器中初始化-对象方法或对象属性给属性赋值+</p>
<h3 id="3-this-关键字可以用来调用哪些结构，简单说明一下其使用。"><a href="#3-this-关键字可以用来调用哪些结构，简单说明一下其使用。" class="headerlink" title="3. this 关键字可以用来调用哪些结构，简单说明一下其使用。"></a>3. this 关键字可以用来调用哪些结构，简单说明一下其使用。</h3><p>this:属性、方法、构造器。<br>this:理解为当前对象，当前正在创建的对象。</p>
<h3 id="4-Java中目前学习涉及到的四种权限修饰符都有什么-并说明各自的权限范围。"><a href="#4-Java中目前学习涉及到的四种权限修饰符都有什么-并说明各自的权限范围。" class="headerlink" title="4. Java中目前学习涉及到的四种权限修饰符都有什么?并说明各自的权限范围。"></a>4. Java中目前学习涉及到的四种权限修饰符都有什么?并说明各自的权限范围。</h3><p>public protect 缺省 private</p>
<h3 id="5-创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。"><a href="#5-创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。" class="headerlink" title="5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。"></a>5. 创建Circle类，提供私有的radius属性，提供相应的get和set方法，提供求圆面积的方法。</h3><h2 id="2-复习-封装性和构造器"><a href="#2-复习-封装性和构造器" class="headerlink" title="2.复习:封装性和构造器"></a>2.复习:封装性和构造器</h2><h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><ol>
<li>为什么要引入封装性?<br>我们程序设计追求“高内聚，低耦合”</li>
</ol>
<ul>
<li>高内聚:类的内部数据操作细节自己完成，不允许外部干涉;</li>
<li>低耦合:仅对外暴露少量的方法用于使用。</li>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</li>
</ul>
<ol start="2">
<li>问题引入:<br>当我们创建一一个类的对 象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。 (比如: setLegs()同时， 我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private).<br>–&gt;此时，针对于属性就体现了封装性。|</li>
<li>封装性思想具体的代码体现:<br>体现一-:<br>体现一:将类的属性xxx私化(private),同时，提供公共的(public)方法来获取<br>(getXxx)和设置(setXxx)此属性的值<br>体现二:不对外暴露的私有的方法<br>体现三:单例模式(将构造器私有化)<br>体现四:如果不希望类在包外被调用，可以将类设置为缺省的。</li>
<li>Java规定的四种权限修饰符<br>4.1权限从小到大顺序为:<br>4.2具体的修饰范围:</li>
</ol>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol>
<li>构造器(或构造方法) : Constructor<br>构造器的作用:1.创建对象 2.初始化对象的信息</li>
<li>使用说明:<br>1.如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器<br>2.定义构造器的格式:权限修饰符类名(形参 列表){}]|<br>3.一个类中定义的多个构造器，彼此构成重载<br>4.-旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器<br>5.一个类中，至少会有一个构造器。</li>
</ol>
<p>3.举例: </p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_01.png" alt="应用场景"></p>
<h3 id="属性赋值顺序"><a href="#属性赋值顺序" class="headerlink" title="属性赋值顺序"></a>属性赋值顺序</h3><p>默认初始化 赋值初始化 显性赋值初始化 |||| 构造器赋值  对象.方法</p>
<h3 id="JAVABean"><a href="#JAVABean" class="headerlink" title="JAVABean"></a>JAVABean</h3><p>所谓JavaBean，是指符合如下标准的Java类:</p>
<p>类是公共的</p>
<p>一个无参的公共的构造器</p>
<p>属性，且对应的get、set方法</p>
<h2 id="3-复习-关键字-this-package-import"><a href="#3-复习-关键字-this-package-import" class="headerlink" title="3.复习  关键字 this package import"></a>3.复习  关键字 this package import</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>1.可以调用的结构:<br>属性、方法:构造器</p>
<ol start="2">
<li>this调用属性、方法:<br>this理解为:前对象<br>或当前正在创建的对象<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_02.png" alt="说明"></li>
<li>this调用构造器:</li>
</ol>
<p>①我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器<br>②构造器中不能通过”this(形参列表)”方式调用自己<br>③如果一个类中有n个构造器，则最多有n - 1构造器中使用了”this(形参列表)”<br>④规定: “this(形参列表)”必须声明在当前构造器的首行<br>⑤构造器内部，最多只能声明一一个”this(形参列表)”， 用来调用其他的构造器</p>
<h3 id="package的使用"><a href="#package的使用" class="headerlink" title="package的使用"></a>package的使用</h3><p>1使用说明:<br>*1.为了更好的实现项目中类的管理，提供包的概念.<br>*2.使用package声 明类或接口所属的包，声明在源文件的首行<br>*3.包，属于标识符，遵循标识符的命名规则、规范(xxyyyzzz)、 “见名知意”<br>*<br>4.每”.”一次，就代表一层文件目录。<br>1.2 举例:<br>航运系统<br>MVC<br>1.3JDK中的主要包介绍:.</p>
<p>java都是写网页   写客户端很少用</p>
<h3 id="import-关键紫的使用"><a href="#import-关键紫的使用" class="headerlink" title="import 关键紫的使用"></a>import 关键紫的使用</h3><p>import:导入<br> 1.在源文件中显式的使用import结构导入指定包下的类、接口<br> 2.声明在包的声明和类的声明之间<br>3.如果需要导入多个结构，则并列写出即可<br> 4.可以使用”xxx. *”的方式，表示可以导入xxx包下的所结构<br>5.如果使用的类或接口是java.lang包下定义的，则可以省略import结构<br> 6.如果使用的类或接口是本包下定义的，则可以省略import结构<br> 7.如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。<br> 8.使用”xxx.*”方式表明可以调用Xxxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p>
<ol start="9">
<li>import static:导入指定类或接口中的静态结构:属性或方法。</li>
</ol>
<h2 id="4-6-Eclispe-常用快捷键"><a href="#4-6-Eclispe-常用快捷键" class="headerlink" title="4-6 Eclispe 常用快捷键"></a>4-6 Eclispe 常用快捷键</h2><p>Eclipse中的快捷键：<br>  1.补全代码的声明：alt + /<br>  <img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_02.png" alt="修改为都是提示的"><br>  abcdefg-z*<br>  2.快速修复: ctrl + 1<br>  3.批量导包：ctrl + shift + o<br>  4.使用单行注释：ctrl + /<br>  5.使用多行注释： ctrl + shift + /<br>  6.取消多行注释：ctrl + shift + <br>  修改快捷键    Prefer –keys<br>  7.复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up<br>  8.删除指定行的代码：ctrl + d<br>  9.上下移动代码：alt + up  或 alt + down<br>  10.切换到下一行代码空位：shift + enter<br>  11.切换到上一行代码空位：ctrl + shift + enter<br>  12.如何查看源码：ctrl + 选中指定的结构   或  ctrl + shift + t<br>  13.退回到前一个编辑的页面：alt + left<br>  14.进入到下一个编辑的页面(针对于上面那条来说的)：alt + right<br>  15.光标选中指定的类，查看继承树结构：ctrl + t    —–<br>  16.复制代码： ctrl + c<br>  17.撤销： ctrl + z<br>  18.反撤销： ctrl + y<br>  19.剪切：ctrl + x<br>  20.粘贴：ctrl + v<br>  21.保存： ctrl + s<br>  22.全选：ctrl + a<br>  23.格式化代码： ctrl + shift + f<br>  24.选中数行，整体往后移动：tab<br>  25.选中数行，整体往前移动：shift + tab<br>  26.在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o<br>  27.批量修改指定的变量名、方法名、类名等：alt + shift + r<br>  28.选中的结构的大小写的切换：变成大写： ctrl + shift + x<br>  29.选中的结构的大小写的切换：变成小写：ctrl + shift + y<br>  30.调出生成getter/setter/构造器等结构： alt + shift + s<br>  31.显示当前选择资源(工程 or 文件)的属性：alt + enter<br>  32.快速查找：参照选中的Word快速定位到下一个 ：ctrl + k</p>
<hr>
<p>用的少<br>  33.关闭当前窗口：ctrl + w<br>  34.关闭所有的窗口：ctrl + shift + w<br>  35.查看指定的结构使用过的地方：ctrl + alt + g<br>  36.查找与替换：ctrl + f<br>  37.最大化当前的View：ctrl + m<br>  38.直接定位到当前行的首位：home<br>  39.直接定位到当前行的末位：end</p>
<h2 id="7-bank-练习的难点"><a href="#7-bank-练习的难点" class="headerlink" title="7. bank 练习的难点"></a>7. bank 练习的难点</h2><p>  Accout</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_04.png" alt="属性声明自定义类型">  </p>
<p>关联关系<br>类型数组<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_05.png" alt="类型数组"><br>链式结构</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">private Customer[] customers;// 存放多个客户的数组</span><br><span class="line">private int numberOfCustomers;// 记录客户的个数</span><br><span class="line"></span><br><span class="line">public Bank() {</span><br><span class="line">	customers = new Customer[10];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 添加客户</span><br><span class="line">public void addCustomer(String f, String l) {</span><br><span class="line">	Customer cust = new Customer(f, l);</span><br><span class="line">	// customers[numberOfCustomers] = cust;</span><br><span class="line">	// numberOfCustomers++;</span><br><span class="line">	// 或</span><br><span class="line">	customers[numberOfCustomers++] = cust;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取客户的个数</span><br><span class="line">public int getNumOfCustomers() {</span><br><span class="line">	return numberOfCustomers;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 获取指定位置上的客户</span><br><span class="line">public Customer getCustomer(int index) {</span><br><span class="line">	// return customers[index];//可能报异常</span><br><span class="line">	if (index &gt;= 0 &amp;&amp; index &lt; numberOfCustomers) {</span><br><span class="line">		return customers[index];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	return null;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="8-项目二-客户信息管理软件-功能演示"><a href="#8-项目二-客户信息管理软件-功能演示" class="headerlink" title="8..项目二 客户信息管理软件  功能演示"></a>8..项目二 客户信息管理软件  功能演示</h2><p>●模拟实现一个基于文本界面的《客户信息管理软件》<br>●进一步掌握编程技巧和调试技巧，熟悉面向对象编程;<br>●主要涉及以下知识点:<br>➢类结构的使用:属性、方法及构造器<br>➢对象的创建与使用<br>➢类的封装性<br>➢声明和使用数组<br>➢数组的插入、删除和替换<br>➢关键字的使用: this<br>结构.<br>com.atguigu.p2<br>CMUtilityjava<br>Customerjava<br>CustomerLstjava<br>CustomerViewjava</p>
<h2 id="9-软件架构设计"><a href="#9-软件架构设计" class="headerlink" title="9. 软件架构设计"></a>9. 软件架构设计</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_06.png" alt="软件架构设计">  </p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_07.png" alt="软件架构设计"></p>
<h2 id="10-CMUtility工具类的介绍"><a href="#10-CMUtility工具类的介绍" class="headerlink" title="10.CMUtility工具类的介绍"></a>10.CMUtility工具类的介绍</h2><p>可用来方便地实现键盘访问</p>
<ul>
<li>public static char readMenuSelection()<br>用途：该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。</li>
<li>public static char readChar() 和 public static char readChar(char defaultValue)<br>用途：这两个方法功能相同，均从键盘读取一个字符，并将其作为方法的返回值。<br>参数： defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。（提示：此方法可在修改客户时调用）</li>
<li>public static int readInt() 和public static int readInt(int defaultValue)<br>用途：这两个方法功能相同，均从键盘读取一个长度不超过2位的   整数，并将其作为方法的返回值。<br>参数： defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</li>
<li>public static String readString(int limit)  和<br>public static String readString(int limit, String defaultValue)<br>用途：这两个方法功能相同，均从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。<br>参数：limit — 指定字符串的最大长度 <pre><code>defaultValue — 如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</code></pre></li>
<li>public static char readConfirmSelection()<br>用途：从键盘读取‘Y’或’N’，并将其作为方法的返回值</li>
</ul>
<h2 id="11-Customer类的设计"><a href="#11-Customer类的设计" class="headerlink" title="11.Customer类的设计"></a>11.Customer类的设计</h2><p>2 .3 w行</p>
<h2 id="12-CustomerList类的设计"><a href="#12-CustomerList类的设计" class="headerlink" title="12.CustomerList类的设计"></a>12.CustomerList类的设计</h2><p>操作数组之前一定要初始化   在结构体里面<br>代码要有注释<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_08.png" alt="addCustomer"><br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_09.png" alt="注释"></p>
<h2 id="13-CustomerView的整体设计的构建"><a href="#13-CustomerView的整体设计的构建" class="headerlink" title="13.CustomerView的整体设计的构建"></a>13.CustomerView的整体设计的构建</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_10.png" alt="输入逻辑"></p>
<p>char a=‘1’；</p>
<h2 id="14-CustomerView-退出功能的实现"><a href="#14-CustomerView-退出功能的实现" class="headerlink" title="14.CustomerView 退出功能的实现"></a>14.CustomerView 退出功能的实现</h2><h2 id="15-CustomerView-客户列表的实现"><a href="#15-CustomerView-客户列表的实现" class="headerlink" title="15.CustomerView 客户列表的实现"></a>15.CustomerView 客户列表的实现</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_11.png" alt=" 客户列表的实现"></p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_12.png" alt="客户列表的实现"></p>
<h2 id="16-CustomerView-添加客户的实现"><a href="#16-CustomerView-添加客户的实现" class="headerlink" title="16.CustomerView 添加客户的实现"></a>16.CustomerView 添加客户的实现</h2><p>控制读取字符的长度  </p>
<h2 id="17-CustomerView-修改客户的实现"><a href="#17-CustomerView-修改客户的实现" class="headerlink" title="17.CustomerView 修改客户的实现"></a>17.CustomerView 修改客户的实现</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-zhong/11_13.png" alt=" 客户列表的实现"></p>
<p>找不到返回主页面</p>
<p>局部变量</p>
<h2 id="18-CustomerView-删除客户的实现"><a href="#18-CustomerView-删除客户的实现" class="headerlink" title="18.CustomerView 删除客户的实现"></a>18.CustomerView 删除客户的实现</h2><h2 id="19-独立写一下-收获很大-总结"><a href="#19-独立写一下-收获很大-总结" class="headerlink" title="19.独立写一下  收获很大   总结"></a>19.独立写一下  收获很大   总结</h2><p>认知能力</p>
<p>别停   听了一个月就死了   去写 去熟悉</p>
<p>写多就会了</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h2 id="20-继承性的理解"><a href="#20-继承性的理解" class="headerlink" title="20.继承性的理解"></a>20.继承性的理解</h2><h3 id="一、继承性的好处-why"><a href="#一、继承性的好处-why" class="headerlink" title="一、继承性的好处  why"></a>一、继承性的好处  why</h3><p>①减少了代码的冗余，提高代码的复用性<br>②便于功能的扩展<br>③为之后多态性的使用，提供了前提</p>
<h2 id="21-继承性的使用"><a href="#21-继承性的使用" class="headerlink" title="21.继承性的使用"></a>21.继承性的使用</h2><h3 id="二、继承性的格式："><a href="#二、继承性的格式：" class="headerlink" title="二、继承性的格式："></a>二、继承性的格式：</h3><p> class A extends B{}<br>  A:子类、派生类、subclass<br>  B:父类、超类、基类、superclass</p>
<p> 2.1体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。<br>       特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。不可以直接调<br>   只有因为封装性的影响，使得子类不能直接调用父类的结构而已。<br>2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。  —-自类更强大<br>  子类和父类的关系，不同于子集和集合的关系。<br>  extends：延展、扩展</p>
<h2 id="21-继承性的再说明"><a href="#21-继承性的再说明" class="headerlink" title="21.继承性的再说明"></a>21.继承性的再说明</h2><h3 id="三、Java中关于继承性的规定："><a href="#三、Java中关于继承性的规定：" class="headerlink" title="三、Java中关于继承性的规定："></a>三、Java中关于继承性的规定：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.一个类可以被多个子类继承。</span><br></pre></td></tr></tbody></table></figure>

<p>  2.Java中类的单继承性：一个类只能有一个父类<br>  3.子父类是相对的概念。<br>  4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类<br>  5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p>
<h2 id="23-Object类的理解"><a href="#23-Object类的理解" class="headerlink" title="23 Object类的理解"></a>23 Object类的理解</h2><h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><ol>
<li>如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li>
</ol>
<ul>
<li><ol start="2">
<li>所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</li>
</ol>
</li>
<li><ol start="3">
<li>意味着，所有的java类具有java.lang.Object类声明的功能。</li>
</ol>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(上)补2</title>
    <url>/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/</url>
    <content><![CDATA[<h2 id="1-每天一问"><a href="#1-每天一问" class="headerlink" title="1. 每天一问"></a>1. 每天一问</h2><ol>
<li>什么是方法的重载?<br>两同一不同”:同一个类、相同方法名;参数列表不同<br>如何调用确定的方法:方法名→参数列表。</li>
<li>说明Java方法中的参数传递机制的具体体现?<br>基本数据类型:数据值+<br>引用数据类型:地址值(含变量的数据类型)。<br>Person p1 = new Person( );<br>eat();age+<br>User u1 = p1;//编译错误<br>(逆向思维、反证法)<br>u1. eat()<br>u1.age</li>
<li>成员变量和局部变量在声明的位置上、是否有默认初始化值上、是否能有权限修饰符修饰上、内存分配的位置上有何不同?</li>
<li>谈谈return关键字的使用。<br>①结束方法<br>②针对于有返回值的方法，return +返回数据。</li>
<li>提供如下代码的内存解析。<ol>
<li>内存结构:栈(局部变量)、堆(new出来的结构:对象(非static成员变量)、数组)<br>2.变量:成员变量vs局部变量(方法内、方法形参、构造器内、构造器形参、代码块内) </li>
</ol>
</li>
</ol>
<hr>
<h2 id="1-2-复习-重载"><a href="#1-2-复习-重载" class="headerlink" title="1-2. 复习 重载"></a>1-2. 复习 重载</h2><ol>
<li>匿名对象:我们创建的对象，没显式的赋给一个变量名。即为匿名对象<br>特点:匿名对象只能调用一次。<br>举例:<br>new Phone() . sendEmail();<br>new Phone( ) . playGame();<br>new Phone() .price = 1999;<br>new Phone() . showPrice();//0.0<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_01.png" alt="应用场景"></li>
<li>万事万物皆对象<br>3.方法的重载概念<br>定义:在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参<br>数类型不同即可。<br>总结: “两同一不同”:同一个类、相同方法名；参数列表不同:参数个数不同，参数类型不同</li>
<li>构成重载的举例:<br>举例一: Arrays类中 重载的sort() / binarySearch(); PrintStream中 的println()<br>举例<br>/ /如下的4个方法构成了重载<br>public void getSum(int i,int j){<br>System. out. println(“1”);<br>public void getSum( double d1, double d2){<br>System . out . print1n(“2”);<br>}<br>public void getSum(String s， int i){<br>System. out . println(“3”);<br>}<br>public void getSum(int i,String s){<br>System. out . println(“4”);<br>}</li>
</ol>
<p>不构成重载的举例:<br>//如下的3个方法不能与上述4个方法构成重载<br>// public int getSum(int i,int j){<br>//<br>return 0;<br>// }<br>// public void getSum(int m,int n){<br>//<br>// }<br>I<br>// private void getSum(int i,int j){<br>//<br>// }<br>5.如何判断是否构成方法的重载?<br>严格按照定义判断:两同一不同。<br>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系!<br>6.如何确定类中某-一个方法的调用:<br>方法名—&gt;参数列表<br>面试题:方法的重载与重写的区别<br>throws \throw<br>String\StringBuffer\StringBuilder<br>Collection\Collections<br>final \finally\finalize</p>
<p>抽象类、接口<br>sleep()/wait( )</p>
<p>7.可变个数形参的方法</p>
<ul>
<li><p>使用说明</p>
<ul>
<li>1.jdk 5.0新增的内容</li>
<li>2.具体使用:<ul>
<li>2.1 可变个数形参的格式:数据类型… 变量名</li>
<li>2.2当调用可变个数形参的方法时，传入的参数个数可以是: 0个，1个,2个，</li>
<li>2.3可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</li>
<li>2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</li>
<li>2.5可变个数形参在方法的形参中，必须声明在末尾</li>
<li>2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参。</li>
</ul>
</li>
</ul>
</li>
<li><p>举例说明</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_02.png" alt="举例说明"></p>
</li>
</ul>
<p>调用时</p>
<p>test. show( “he1lo”);<br>test. show( “hello”, “world”);<br>test. show();<br>test. show(new String[ ]{“AA”, “BB”, “CC”});</p>
<h2 id="3-值传递和递归方法"><a href="#3-值传递和递归方法" class="headerlink" title="3.值传递和递归方法"></a>3.值传递和递归方法</h2><ul>
<li>针对于方法内变量的赋值举例<br>规则 :<br>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。<br>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
<li>针对于方法的参数概念<ul>
<li>形参:方法定义时，声明的小括号内的参数<ul>
<li>实参:方法调用时，实际传递给形参的数据|</li>
</ul>
</li>
</ul>
</li>
<li>java中参数传递机制:   值传递<br>规则:<br>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。<br>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。<br>推广:<br>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。<br>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
</ul>
<p>String 只想常量方法区<br>  <img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_03.png" alt="关于string说明"><br>引用数据类型<br> <img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_04.png" alt="参数类型为引用数据类型"></p>
<ul>
<li>递归方法</li>
<li>定义<br>递归方法:一个方法体内调用它自身。</li>
<li>如何理解递归方法</li>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须<br>循环控制。<pre><code>- 递归一定要向己知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</code></pre></li>
<li>举例<br>//例1: 计算1-n之间所有自然数的和<br>public int getSum(int n) {//<br>if (n==1) {<br>return 1;<br>}else{<br>return n + getSum(n - 1);<br>}<br>}<br>面试题 <img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_05.png" alt="面试题"><br>面试题 <img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_06.png" alt="图解"></li>
</ul>
<hr>
<h2 id="4-封装性的引入"><a href="#4-封装性的引入" class="headerlink" title="4.封装性的引入"></a>4.封装性的引入</h2><p>IO  验证 和使用面向对象的过程，后面加深理解</p>
<p>面向对象特征之一: 封装与隐藏</p>
<ul>
<li>为什么需要封装？封装的作用和含义？<ul>
<li>我要用洗衣机，只需要按一下开关和洗涤模式就可以了。有必要了解洗衣机内<br>部的结构吗？有必要碰电动机吗？</li>
<li>我要开车， …</li>
</ul>
</li>
<li>我们程序设计追求“高内聚，低耦合”。<ul>
<li>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</li>
<li>低耦合 ： 仅对外暴露少量的方法用于使用。</li>
</ul>
</li>
<li>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说， <code>把该隐藏的隐藏起来，该暴露的暴露出来。 这就是封装性的设计思想。</code> </li>
</ul>
<p>代码<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_07.png" alt="封装性介绍"></p>
<p>若a.legs=-4  不符合常理</p>
<p>加入条件如下:<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_08.png" alt="封装性介绍加入条件"></p>
<p>让a.leg 不能被调用  private int leg；</p>
<h3 id="一、问题的引入："><a href="#一、问题的引入：" class="headerlink" title="一、问题的引入："></a>一、问题的引入：</h3><p>当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值,加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()）<br>同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private). –&gt;此时，针对于属性就体现了封装性。</p>
<h3 id="二、封装性的体现："><a href="#二、封装性的体现：" class="headerlink" title="二、封装性的体现："></a>二、封装性的体现：</h3><p> 我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p>
<p> 拓展：封装性的体现：① 如上  ② 不对外暴露的私有的方法  ③ 单例模式（构造器私有）   …</p>
<h3 id="三、封装性的体现，需要权限修饰符来配合。"><a href="#三、封装性的体现，需要权限修饰符来配合。" class="headerlink" title="三、封装性的体现，需要权限修饰符来配合。"></a>三、封装性的体现，需要权限修饰符来配合。</h3><p>1.Java规定的4种权限（从小到大排列）：private、缺省、protected 、public<br>2.4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类<br>3.具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类<br>修饰类的话，只能使用：缺省、public<br>总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。<br> 封装性的提现<br> public int getAge(){<br>        return age;<br>    }</p>
<h2 id="5-封装性的提现"><a href="#5-封装性的提现" class="headerlink" title="5.封装性的提现"></a>5.封装性的提现</h2><h2 id="6-四种权限修饰的理解"><a href="#6-四种权限修饰的理解" class="headerlink" title="6.四种权限修饰的理解"></a>6.四种权限修饰的理解</h2><ul>
<li>Java权限修饰符public、 protected、 (缺省)、 private置于类的成员定义前，<br>用来限定对象对该类成员的访问权限。<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_09.png" alt="4种权限修饰符"></li>
<li>对于class的权限修饰只可以用public和default(缺省)。<ul>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。</li>
</ul>
</li>
</ul>
<h2 id="7-四种权限修饰符的测试"><a href="#7-四种权限修饰符的测试" class="headerlink" title="7.四种权限修饰符的测试"></a>7.四种权限修饰符的测试</h2><p>权限的大小 打比方公司的秘密</p>
<h2 id="8-封装类的练习"><a href="#8-封装类的练习" class="headerlink" title="8.封装类的练习"></a>8.封装类的练习</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_10.png" alt="类图"></p>
<p>- 表示私有 </p>
<p>+ 表示public</p>
<h2 id="9-类的成员"><a href="#9-类的成员" class="headerlink" title="9.类的成员"></a>9.类的成员</h2><h3 id="类的成员之三：构造器-或构造方法"><a href="#类的成员之三：构造器-或构造方法" class="headerlink" title="类的成员之三：构造器(或构造方法)"></a>类的成员之三：构造器(或构造方法)</h3><ul>
<li>构造器的特征 <ul>
<li>它具有与类相同的名称</li>
<li>它不声明返回值类型。（与声明为void不同）</li>
<li>不能被static、 final、 synchronized、 abstract、 native修饰，不能有<br>return语句返回值 </li>
</ul>
</li>
<li>构造器的作用： <code>创建对象；给对象进行初始化</code><ul>
<li>如： Order o = new Order(); Person p = new Person(“Peter”,15);</li>
<li>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人” 的<br>构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自<br>动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们<br>要“洗澡”了</li>
</ul>
</li>
<li>语法格式：<br>修饰符 类名 (参数列表) {<br>初始化语句；<br>}</li>
<li>举例说明:<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_11.png" alt="构造器举例说明"></li>
<li>根据参数不同，构造器可以分为如下两类：<ul>
<li>隐式无参构造器（系统默认提供）</li>
<li>显式定义一个或多个构造器（无参、有参）</li>
</ul>
</li>
<li>注 意：<br>Java语言中，每个类都至少有一个构造器<br>默认构造器的修饰符与所属类的修饰符一致<br>一旦显式定义了构造器， 则系统不再提供默认构造器<br>一个类可以创建多个重载的构造器<br>父类的构造器不可被子类继承</li>
</ul>
<hr>
<p>构造器</p>
<p> construct：建设、建造。  construction:CCB    constructor:建设者</p>
<p>一、构造器的作用：<br> 1.创建对象   / /创建类的对象:new +构造器      构造器是一种独立的结构<br> 2.初始化对象的信息  —————</p>
<p>二、说明：<br> 1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器<br> 2.定义构造器的格式：权限修饰符  类名(形参列表){}<br> 3.一个类中定义的多个构造器，彼此构成重载<br> 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器(一旦结婚了，就不给饭吃了 )<br> 5.一个类中，至少会有一个构造器。</p>
<h2 id="10-构造器使用的细节说明"><a href="#10-构造器使用的细节说明" class="headerlink" title="10.构造器使用的细节说明"></a>10.构造器使用的细节说明</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_12.png" alt="构造器重载说明"></p>
<h2 id="11-12-构造器的练习-三角形的练习"><a href="#11-12-构造器的练习-三角形的练习" class="headerlink" title="11-12 .构造器的练习   三角形的练习"></a>11-12 .构造器的练习   三角形的练习</h2><h2 id="13-总结属性赋值的过程"><a href="#13-总结属性赋值的过程" class="headerlink" title="13 总结属性赋值的过程"></a>13 总结属性赋值的过程</h2><p>截止到目前，我们讲到了很多位置都可以对类的属性赋值。现总结这几个位<br>置，并指明赋值的先后顺序。</p>
<ul>
<li>赋值的位置:<br>①默认初始化 0.0<br>②显式初始化 1.0<br>③构造器中初始化       123 是一次性的<br>④通过“对象.属性“或“对象.方法”的方式赋值</li>
<li>赋值的先后顺序:<br>①.②-③-④</li>
</ul>
<h2 id="14-JavaBean的使用"><a href="#14-JavaBean的使用" class="headerlink" title="14. JavaBean的使用"></a>14. JavaBean的使用</h2><ul>
<li>JavaBean是一种Java语言写成的可重用组件。</li>
<li>所谓javaBean，是指符合如下标准的Java类：<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、 set方法</li>
<li>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以<br>用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP<br>页面、 Servlet、其他JavaBean、 applet程序或者应用来使用这些对象。用<br>户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关<br>心任何改变。    一个类就是一个jAVABean<br>—&gt;反射造对象</li>
</ul>
</li>
</ul>
<h2 id="15-UML类图"><a href="#15-UML类图" class="headerlink" title="15. UML类图"></a>15. UML类图</h2><p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_13.png" alt="UML说明"></p>
<h2 id="16-this调用属性和方法"><a href="#16-this调用属性和方法" class="headerlink" title="16. this调用属性和方法"></a>16. this调用属性和方法</h2><h3 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h3><ul>
<li>在Java中， this关键字比较难理解，它的作用和其词义很接近。<ul>
<li>它在方法内部使用，即这个方法所属对象的引用；</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
</li>
<li>this 可以调用类的属性、方法和构造器</li>
<li>什么时候使用this关键字呢？<ul>
<li>当在方法内需要用到调用该方法的对象时，就用this。<br>具体的：我们可以用this来区分<code>属性</code>和<code>局部变量</code>。<br>比如： this.name = name;</li>
</ul>
</li>
<li>使用this，调用属性、方法<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_14.png" alt="this 举例说明1"></li>
<li>说明<ul>
<li><ol>
<li>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添this，增强程序的阅读性。不过，通常我们都习惯省略this。</li>
</ol>
</li>
<li><ol start="2">
<li>当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量</li>
</ol>
</li>
<li>3.使用this访问属性和方法时，如果在本类中未找到，会从父类中查找</li>
<li>4.this可以作为一个类中构造器相互调用的特殊格式<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_15.png" alt="this 举例说明2"></li>
</ul>
</li>
<li>使用this调用本类的构造器<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_16.png" alt="this 举例说明3 this可以作为一个类中构造器相互调用的特殊格式 "></li>
<li>注意</li>
</ul>
<ol>
<li>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！</li>
<li>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</li>
<li>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了”this(形参列表)”</li>
<li>“this(形参列表)”必须声明在类的构造器的首行！</li>
<li>在类的一个构造器中，最多只能声明一个”this(形参列表)</li>
</ol>
<hr>
<p>www    what(是什么) why(为什么要用) how.</p>
<p>代码中</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_17" alt="1587564642445"></p>
<h3 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h3><ol>
<li>this可以用来修饰、调用：属性、方法、构造器</li>
<li>this修饰属性和方法：<br>this理解为：当前对象  或 当前正在创建的对象 （构造器）<ul>
<li>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
<li>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</li>
</ul>
</li>
<li>this调用构造器<br>① 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器<br>② 构造器中不能通过”this(形参列表)”方式调用自己<br> ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”<br>④ 规定：”this(形参列表)”必须声明在当前构造器的首行<br>  ⑤ 构造器内部，最多只能声明一个”this(形参列表)”，用来调用其他的构造器</li>
</ol>
<h2 id="17-this调用构造器–减少冗余了"><a href="#17-this调用构造器–减少冗余了" class="headerlink" title="17.this调用构造器–减少冗余了"></a>17.this调用构造器–减少冗余了</h2><p>构造器里面调用构造器</p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_17.png" alt="this调用构造器"></p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_18.png" alt="1587564642445"></p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_19.png" alt="比较两个对象的大小"></p>
<h2 id="18-练习boyand-girl"><a href="#18-练习boyand-girl" class="headerlink" title="18 练习boyand girl"></a>18 练习boyand girl</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.exer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">()</span> </span>{</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(String name)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Girl girl)</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"我想娶"</span> + girl.getName());</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age &gt;= <span class="number">22</span>){</span><br><span class="line">			System.out.println(<span class="string">"你可以去合法登记结婚了！"</span>);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			System.out.println(<span class="string">"先多谈谈恋爱~~"</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">*-*-----------------</span><br><span class="line">    <span class="keyword">package</span> com.atguigu.exer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">marry</span><span class="params">(Boy boy)</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"我想嫁给"</span> + boy.getName());</span><br><span class="line">		boy.marry(<span class="keyword">this</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span> 比较两个对象的大小</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2019年1月18日下午4:02:09</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> girl</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>  正数：当前对象大；  负数：当前对象小  ； 0：当前对象与形参对象相等</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Girl girl)</span></span>{</span><br><span class="line"><span class="comment">//		if(this.age &gt; girl.age){</span></span><br><span class="line"><span class="comment">//			return 1;</span></span><br><span class="line"><span class="comment">//		}else if(this.age &lt; girl.age){</span></span><br><span class="line"><span class="comment">//			return -1;</span></span><br><span class="line"><span class="comment">//		}else{</span></span><br><span class="line"><span class="comment">//			return 0;</span></span><br><span class="line"><span class="comment">//		}</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.age - girl.age;</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line">-------------</span><br><span class="line">  <span class="keyword">package</span> com.atguigu.exer2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoyGirlTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		</span><br><span class="line">		Boy boy = <span class="keyword">new</span> Boy(<span class="string">"罗密欧"</span>, <span class="number">21</span>);</span><br><span class="line">		boy.shout();</span><br><span class="line">		</span><br><span class="line">		Girl girl = <span class="keyword">new</span> Girl(<span class="string">"朱丽叶"</span>, <span class="number">18</span>);</span><br><span class="line">		girl.marry(boy);</span><br><span class="line">		</span><br><span class="line">		Girl girl1 = <span class="keyword">new</span> Girl(<span class="string">"祝英台"</span>,<span class="number">19</span>);</span><br><span class="line">		<span class="keyword">int</span> compare = girl.compare(girl1);</span><br><span class="line">		<span class="keyword">if</span>(compare &gt; <span class="number">0</span>){</span><br><span class="line">			System.out.println(girl.getName() + <span class="string">"大"</span>);</span><br><span class="line">		}<span class="keyword">else</span> <span class="keyword">if</span>(compare &lt; <span class="number">0</span>){</span><br><span class="line">			System.out.println(girl1.getName() + <span class="string">"大"</span>);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			System.out.println(<span class="string">"一样大"</span>);</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<h2 id="19-练习Account"><a href="#19-练习Account" class="headerlink" title="19. 练习Account"></a>19. 练习Account</h2><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.exer3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//账号</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;<span class="comment">//余额</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> annualInterestRate;<span class="comment">//年利率</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span> <span class="params">(<span class="keyword">int</span> id, <span class="keyword">double</span> balance, <span class="keyword">double</span> annualInterestRate )</span></span>{</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">		<span class="keyword">this</span>.annualInterestRate = annualInterestRate;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> balance;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAnnualInterestRate</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> annualInterestRate;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnnualInterestRate</span><span class="params">(<span class="keyword">double</span> annualInterestRate)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.annualInterestRate = annualInterestRate;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span> <span class="params">(<span class="keyword">double</span> amount)</span></span>{<span class="comment">//取钱</span></span><br><span class="line">		<span class="keyword">if</span>(balance &lt; amount){</span><br><span class="line">			System.out.println(<span class="string">"余额不足，取款失败"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		}</span><br><span class="line">		balance -= amount;</span><br><span class="line">		System.out.println(<span class="string">"成功取出："</span> + amount);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span> <span class="params">(<span class="keyword">double</span> amount)</span></span>{<span class="comment">//存钱</span></span><br><span class="line">		<span class="keyword">if</span>(amount &gt; <span class="number">0</span>){</span><br><span class="line">			balance += amount;</span><br><span class="line">			System.out.println(<span class="string">"成功存入："</span> + amount);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"><span class="keyword">package</span> com.atguigu.exer3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String firstName;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> Account account;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String f,String l)</span></span>{</span><br><span class="line">		<span class="keyword">this</span>.firstName = f;</span><br><span class="line">		<span class="keyword">this</span>.lastName = l;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Account <span class="title">getAccount</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> account;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(Account account)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.account = account;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> firstName;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> lastName;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">----------</span><br><span class="line"><span class="keyword">package</span> com.atguigu.exer3;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 写一个测试程序。</span></span><br><span class="line"><span class="comment">（1）	创建一个Customer ，名字叫 Jane Smith, </span></span><br><span class="line"><span class="comment">他有一个账号为1000，余额为2000元，年利率为 1.23％ 的账户。</span></span><br><span class="line"><span class="comment">（2）	对Jane Smith操作。</span></span><br><span class="line"><span class="comment">存入 100 元，再取出960元。再取出2000元。</span></span><br><span class="line"><span class="comment">打印出Jane Smith 的基本信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成功存入 ：100.0</span></span><br><span class="line"><span class="comment">成功取出：960.0</span></span><br><span class="line"><span class="comment">余额不足，取款失败</span></span><br><span class="line"><span class="comment">Customer [Smith, Jane] has a account: id is 1000, </span></span><br><span class="line"><span class="comment">annualInterestRate is 1.23％, balance is 1140.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Customer cust = <span class="keyword">new</span> Customer(<span class="string">"Jane"</span>, <span class="string">"Smith"</span>);</span><br><span class="line">		</span><br><span class="line">		Account acct = <span class="keyword">new</span> Account(<span class="number">1000</span>, <span class="number">2000</span>, <span class="number">0.0123</span>);</span><br><span class="line">		</span><br><span class="line">		cust.setAccount(acct);</span><br><span class="line">		</span><br><span class="line">		cust.getAccount().deposit(<span class="number">100</span>);</span><br><span class="line">		cust.getAccount().withdraw(<span class="number">960</span>);</span><br><span class="line">		cust.getAccount().withdraw(<span class="number">2000</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Customer["</span> + cust.getLastName() + <span class="string">","</span> + cust.getFirstName() + </span><br><span class="line">				<span class="string">"] has a account: id is "</span> + cust.getAccount().getId() + <span class="string">",annualInterestRate is "</span>+</span><br><span class="line">		cust.getAccount().getAnnualInterestRate() * <span class="number">100</span> + <span class="string">"% ,balance is "</span> + cust.getAccount().getBalance());</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="20-练习对象数组"><a href="#20-练习对象数组" class="headerlink" title="20. 练习对象数组"></a>20. 练习对象数组</h2><p>每加顾客+1<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_20.png" alt="每加顾客+1"><br>或customers [ numberOfCustomers++] = cust;<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_21.png" alt="别忘记初始化"></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.exer4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>{</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(<span class="keyword">double</span> init_balance)</span></span>{</span><br><span class="line">		<span class="keyword">this</span>.balance = init_balance;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> balance;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//存钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amt)</span></span>{</span><br><span class="line">		<span class="keyword">if</span>(amt &gt; <span class="number">0</span>){</span><br><span class="line">			balance += amt;</span><br><span class="line">			System.out.println(<span class="string">"存钱成功"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//取钱操作</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>{</span><br><span class="line">		<span class="keyword">if</span>(balance &gt;= amt){</span><br><span class="line">			balance -= amt;</span><br><span class="line">			System.out.println(<span class="string">"取钱成功"</span>);</span><br><span class="line">		}<span class="keyword">else</span>{</span><br><span class="line">			System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="keyword">package</span> com.atguigu.exer4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String firstName;</span><br><span class="line">	<span class="keyword">private</span> String lastName;</span><br><span class="line">	<span class="keyword">private</span> Account account;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String f, String l)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.firstName = f;</span><br><span class="line">		<span class="keyword">this</span>.lastName = l;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Account <span class="title">getAccount</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> account;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(Account account)</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.account = account;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> firstName;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> lastName;</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.exer4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>{</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Customer[] customers;<span class="comment">// 存放多个客户的数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> numberOfCustomers;<span class="comment">// 记录客户的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">()</span> </span>{</span><br><span class="line">		customers = <span class="keyword">new</span> Customer[<span class="number">10</span>];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加客户</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCustomer</span><span class="params">(String f, String l)</span> </span>{</span><br><span class="line">		Customer cust = <span class="keyword">new</span> Customer(f, l);</span><br><span class="line">		<span class="comment">// customers[numberOfCustomers] = cust;</span></span><br><span class="line">		<span class="comment">// numberOfCustomers++;</span></span><br><span class="line">		<span class="comment">// 或</span></span><br><span class="line">		customers[numberOfCustomers++] = cust;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取客户的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfCustomers</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> numberOfCustomers;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取指定位置上的客户</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">		<span class="comment">// return customers[index];//可能报异常</span></span><br><span class="line">		<span class="keyword">if</span> (index &gt;= <span class="number">0</span> &amp;&amp; index &lt; numberOfCustomers) {</span><br><span class="line">			<span class="keyword">return</span> customers[index];</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">+-++++++</span><br><span class="line"><span class="keyword">package</span> com.atguigu.exer4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		</span><br><span class="line">		Bank bank = <span class="keyword">new</span> Bank();</span><br><span class="line">		</span><br><span class="line">		bank.addCustomer(<span class="string">"Jane"</span>, <span class="string">"Smith"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//连续操作</span></span><br><span class="line">		bank.getCustomer(<span class="number">0</span>).setAccount(<span class="keyword">new</span> Account(<span class="number">2000</span>));</span><br><span class="line">		</span><br><span class="line">		bank.getCustomer(<span class="number">0</span>).getAccount().withdraw(<span class="number">500</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">double</span> balance = bank.getCustomer(<span class="number">0</span>).getAccount().getBalance();</span><br><span class="line">		System.out.println(<span class="string">"客户："</span> + bank.getCustomer(<span class="number">0</span>).getFirstName() + <span class="string">"的账户余额为："</span> + balance);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"***********************"</span>);</span><br><span class="line">		bank.addCustomer(<span class="string">"万里"</span>, <span class="string">"杨"</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"银行客户的个数为："</span> + bank.getNumOfCustomers());</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">-------</span><br></pre></td></tr></tbody></table></figure>

<h2 id="21-package关键字的使用"><a href="#21-package关键字的使用" class="headerlink" title="21.package关键字的使用"></a>21.package关键字的使用</h2><ul>
<li><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在<br>的包。 (若缺省该语句，则指定为无名包)。它的格式为：<br>package 顶层包名.子包名</p>
</li>
<li><p>包对应于文件系统的目录， package语句中，用 “.” 来指明包(目录)的层次；</p>
</li>
<li><p>包通常用小写单词标识。通常使用所在公司域名的倒置： com.atguigu.xxx</p>
</li>
<li><p>包的作用：</p>
<ul>
<li>包帮助管理大型软件系统： 将功能相近的类划分到同一个包中。 比如： MVC的设计模式</li>
<li>包可以包含类和子包， 划分项目层次， 便于管理</li>
<li>解决类命名冲突的问题</li>
<li>控制访问权限</li>
</ul>
<hr>
</li>
</ul>
<h4 id="一、package关键字的使用"><a href="#一、package关键字的使用" class="headerlink" title="一、package关键字的使用"></a>一、package关键字的使用</h4><p>1.为了更好的实现项目中类的管理，提供包的概念<br>2.使用package声明类或接口所属的包，声明在源文件的首行<br>3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”<br>4.每”.”一次，就代表一层文件目录。<br> 补充：同一个包下，不能命名同名的接口、类。<br>     不同的包下，可以命名同名的接口、类。<br>JDK中主要的包介绍<br><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_22.png" alt="JDK中主要的包介绍"></p>
<h2 id="22-MVC设计模式的理解"><a href="#22-MVC设计模式的理解" class="headerlink" title="22.MVC设计模式的理解"></a>22.MVC设计模式的理解</h2><p>​      MVC是常用的设计模式之一，将整个程序分为三个层次： <code>视图模型层，控制器层，与数据模型层</code>。 这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性 </p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_23.png" alt="MVC 设计模式"></p>
<p><img src="/2016/06/28/2016-06-28-mian-xiang-dui-xiang-shang-bu-2/10_24.png" alt="MVC 设计模式图解"></p>
<h2 id="23-import-关键字的使用"><a href="#23-import-关键字的使用" class="headerlink" title="23 import 关键字的使用"></a>23 import 关键字的使用</h2><h4 id="二、import关键字的使用"><a href="#二、import关键字的使用" class="headerlink" title="二、import关键字的使用"></a>二、import关键字的使用</h4><p>import:导入</p>
<ol>
<li><p>在源文件中显式的使用import结构导入指定包下的类、接口</p>
</li>
<li><p>声明在包的声明和类的声明之间</p>
</li>
<li><p>如果需要导入多个结构，则并列写出即可</p>
</li>
<li><p>可以使用”xxx.*”的方式，表示可以导入xxx包下的所有结构</p>
</li>
<li><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p>
</li>
<li><p>如果使用的类或接口是本包下定义的，则可以省略import结构</p>
</li>
<li><p>如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。————<strong><strong><strong><strong>*****</strong></strong></strong></strong></p>
</li>
<li><p>使用”xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入    * 不代表子包</p>
</li>
<li><p>import static:导入指定类或接口中的静态结构:属性或方法。 </p>
<p>eg import static java.lang.System.*；</p>
<p>out.print(“121”)</p>
</li>
</ol>
<hr>
<ul>
<li>为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类<br>或全部类(.*)。 import语句告诉编译器到哪里去寻找类。</li>
<li>语法格式：<br>import 包名. 类名;</li>
<li>应用举例：<br>import pack1.pack2.Test; //import pack1.pack2.*;表示引入pack1.pack2包中的所有结构</li>
<li>注意：</li>
</ul>
<ol>
<li><p>在源文件中使用import显式的导入指定包下的类或接口</p>
</li>
<li><p>声明在包的声明和类的声明之间。</p>
</li>
<li><p>如果需要导入多个类或接口，那么就并列显式多个import语句即可</p>
</li>
<li><p>举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</p>
</li>
<li><p>如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。</p>
</li>
<li><p>如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的<br>是哪个类。</p>
</li>
<li><p>如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。</p>
</li>
<li><p>import static组合的使用：调用指定类或接口下的静态的属性或方法</p>
<p>两个date</p>
<p>#</p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(上)补1</title>
    <url>/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/</url>
    <content><![CDATA[<h2 id="1-2-每天一问"><a href="#1-2-每天一问" class="headerlink" title="1-2. 每天一问"></a>1-2. 每天一问</h2><p>不是获取文件，而是过程，抄别人没有意义</p>
<p>1.面向对象思想编程内容的三条主线分别是什么</p>
<p>①类及类的成员:属性、方法、构造器;代码块、内部类<br>②面向对象的三大特征:封装、继承、多态。</p>
<p>③其它关键字: this,super,abstract,interface,static,final,package,import</p>
<p>面向对象的编程思想?<br>(类、对象;面向对象的三大特征…) </p>
<p>2.谈谈你对面向对象中类和对象的理解，并指出二者的关系</p>
<p>类:抽象的、概念上的内容。<br>对象:实实在在存在的一个个体。<br>对象是由类派生出来的。</p>
<p>3.面向对象思想的体现一:类和对象的创建和执行操作有哪三步?</p>
<p>①创建类<br>②类的实例化。<br>③调用对象的结构: “对象，属性” “对象.方法’</p>
<p>4.类的方法内是否可以定义变量?是否可以调用属性?是否可以定<br>义方法?是否可以调用方法? </p>
<p>是;是;否;是</p>
<h2 id="3-4-复习"><a href="#3-4-复习" class="headerlink" title="3-4 复习"></a>3-4 复习</h2><p>学习 1个月 就可以工作了</p>
<h3 id="1-面向对象学习的三条主线"><a href="#1-面向对象学习的三条主线" class="headerlink" title="1.面向对象学习的三条主线:"></a>1.面向对象学习的三条主线:</h3><p>①类及类的成员:属性、方法、构造器;代码块、内部类<br>②面向对象的三大特征:封装、继承、多态。<br>③其它关键字: this,super,abstract,interface,static,final,package,import</p>
<h2 id="“大处着眼，小处着手”"><a href="#“大处着眼，小处着手”" class="headerlink" title="“大处着眼，小处着手”"></a>“大处着眼，小处着手”</h2><h3 id="2-面向对象与面向过程-理解"><a href="#2-面向对象与面向过程-理解" class="headerlink" title="2.面向对象与面向过程(理解)"></a>2.面向对象与面向过程(理解)</h3><p>1.面向过程: 强调的是功能行为，以函数为最小单位，考虑怎么做。<br>2.面向对象: 强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</p>
<h2 id="举例-把大象装进冰箱"><a href="#举例-把大象装进冰箱" class="headerlink" title="举例: 把大象装进冰箱"></a>举例: 把大象装进冰箱</h2><h3 id="3-完成一一个项目-或功能-的思路"><a href="#3-完成一一个项目-或功能-的思路" class="headerlink" title="3.完成一一个项目(或功能)的思路:"></a>3.完成一一个项目(或功能)的思路:</h3><ul>
<li>根据问题需要，选择问题所针对的现实世界中的实体。</li>
<li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。</li>
<li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序<br>语言，把类构造成计算机能够识别和处理的数据结构。</li>
<li>将类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。</li>
</ul>
<h3 id="4-面向对象中两个重要的概念"><a href="#4-面向对象中两个重要的概念" class="headerlink" title="4.面向对象中两个重要的概念:"></a>4.面向对象中两个重要的概念:</h3><ul>
<li>类:对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象:是实际存在的该类事物的每个个体，因而也称为实例(instance)<br>面向对象程字设计的重点是类的设计<br>设计类，就是设计类的成员。</li>
<li>二者的关系:<br>对象，是由类new出来的，派生出来的。</li>
</ul>
<h3 id="5-面向对象思想落地实现的规则一"><a href="#5-面向对象思想落地实现的规则一" class="headerlink" title="5.面向对象思想落地实现的规则一"></a>5.面向对象思想落地实现的规则一</h3><ul>
<li>1.创建类，设计类的成员</li>
<li>2.创建类的对象</li>
<li>3.通过“对象.属性”或“对象.方法”调用对象的结构</li>
<li>补充:几个概念的使用说明<br>属性=成员变量=fie]d=域、字段<br>方法=成员方法=函数= method<br>创建类的对象=类的实例化=实例化类</li>
</ul>
<h3 id="6-对象的创建与对象的内存解析"><a href="#6-对象的创建与对象的内存解析" class="headerlink" title="6.对象的创建与对象的内存解析"></a>6.对象的创建与对象的内存解析</h3><ul>
<li>典型代码:<br>Person p1 = new Person();<br>Person p2 = new Person();<br>Person p3 = p1;//没有新创建-一个对象，共用一个堆空间中的对象实体。</li>
<li>说明:<br>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非<br>static的)<br>意味着:如果我们修改一-个对象的属性a，则不影响另外–个对象属性a的值。</li>
</ul>
<h3 id="7-JVM-内存结果"><a href="#7-JVM-内存结果" class="headerlink" title="7. JVM 内存结果"></a>7. JVM 内存结果</h3><p>《JVI规范》</p>
<ul>
<li>虚拟机栈，即为平时提到的栈结构。我们将局部变量存储在栈结构中</li>
<li>堆，我们将nev出来的结构(比如:数组、对象)加载在对空间中。补充:对象的属性(非static的)加载在堆空间中。</li>
<li>方法区:类的加载信息、常量池、静态域</li>
</ul>
<h2 id="5-属性和方法"><a href="#5-属性和方法" class="headerlink" title="5. 属性和方法"></a>5. 属性和方法</h2><h3 id="局部变量和属性-相同点和不同点"><a href="#局部变量和属性-相同点和不同点" class="headerlink" title="局部变量和属性 相同点和不同点"></a>局部变量和属性 相同点和不同点</h3><p> 补充: 回顾变量的分类<br> 1.按照数据类型分<br>  <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_1.png" alt="按照数据类型分"></p>
<p>2.按照类中声明的位置</p>
<p><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_2.png" alt="按照类中声明的位置"></p>
<h3 id="方法复习"><a href="#方法复习" class="headerlink" title="方法复习"></a>方法复习</h3><h3 id="关键字return"><a href="#关键字return" class="headerlink" title="关键字return"></a>关键字return</h3><h3 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h3><h2 id="6-万物皆对象"><a href="#6-万物皆对象" class="headerlink" title="6. 万物皆对象"></a>6. 万物皆对象</h2><h3 id="一、理解“万事万物皆对象”"><a href="#一、理解“万事万物皆对象”" class="headerlink" title="一、理解“万事万物皆对象”"></a>一、理解“万事万物皆对象”</h3><p>1.在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构<br>Scanner,String等<br>文件：File<br>网络资源：URL<br>2.涉及到Java语言与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</p>
<h2 id="7-对象数组的内存解析"><a href="#7-对象数组的内存解析" class="headerlink" title="7. 对象数组的内存解析"></a>7. 对象数组的内存解析</h2><p><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_3.png" alt="对象数组的内存解析"><br>内存解析的说明<br>1.引用类型的变量，只可能存储两类值：null  或  地址值（含变量的类型）</p>
<hr>
<h2 id="8-匿名对象的使用-（可以看到这个）"><a href="#8-匿名对象的使用-（可以看到这个）" class="headerlink" title="8. 匿名对象的使用 （可以看到这个）"></a>8. 匿名对象的使用 （可以看到这个）</h2><h3 id="有名的对象"><a href="#有名的对象" class="headerlink" title="有名的对象"></a>有名的对象</h3><p>eg<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_4.png" alt="有名的对象"></p>
<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><p><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_5.png" alt="匿名的对象"><br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_6.png" alt="匿名的对象2"></p>
<h4 id="1-理解"><a href="#1-理解" class="headerlink" title="1.理解"></a>1.理解</h4><p>我们创建的对象，没有显式的赋给一个变量名。即为匿名对象</p>
<h4 id="2-特征"><a href="#2-特征" class="headerlink" title="2.特征"></a>2.特征</h4><p>匿名对象只能调用一次。</p>
<h4 id="3-实现代码-PhoneMall-p104"><a href="#3-实现代码-PhoneMall-p104" class="headerlink" title="3.实现代码  PhoneMall p104"></a>3.实现代码  PhoneMall p104</h4><p>类比，你给别人的匿名信，他写上名字了<br>mall.show(new Phone());</p>
<p>class PhoneMall{<br>    public void show(Phone phone){<br>        phone.sendEmail();<br>        phone.playGame();<br>    }</p>
<p>}</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Phone p = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="comment">//		p = null;</span></span><br><span class="line">		System.out.println(p);</span><br><span class="line">		</span><br><span class="line">		p.sendEmail();</span><br><span class="line">		p.playGame();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//匿名对象</span></span><br><span class="line"><span class="comment">//		new Phone().sendEmail();</span></span><br><span class="line"><span class="comment">//		new Phone().playGame();</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Phone().price = <span class="number">1999</span>;</span><br><span class="line">		<span class="keyword">new</span> Phone().showPrice();<span class="comment">//0.0</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//**********************************</span></span><br><span class="line">		PhoneMall mall = <span class="keyword">new</span> PhoneMall();</span><br><span class="line"><span class="comment">//		mall.show(p);</span></span><br><span class="line">		<span class="comment">//匿名对象的使用</span></span><br><span class="line">		mall.show(<span class="keyword">new</span> Phone());</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneMall</span></span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Phone phone)</span></span>{</span><br><span class="line">		phone.sendEmail();</span><br><span class="line">		phone.playGame();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>{</span><br><span class="line">	<span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"发送邮件"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"玩游戏"</span>);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showPrice</span><span class="params">()</span></span>{</span><br><span class="line">		System.out.println(<span class="string">"手机价格为："</span> + price);</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="9-自定义数据工具类"><a href="#9-自定义数据工具类" class="headerlink" title="9.自定义数据工具类"></a>9.自定义数据工具类</h2><p>合理 整洁  复用性   –工具类的封装</p>
<h2 id="10-理解方法的重载"><a href="#10-理解方法的重载" class="headerlink" title="10.理解方法的重载"></a>10.理解方法的重载</h2><h3 id="10-1方法的重载"><a href="#10-1方法的重载" class="headerlink" title="10.1方法的重载"></a>10.1方法的重载</h3><ul>
<li>重载的概念overload 参数列表<br>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。<br> “两同一不同”:同一个类、相同方法名<br> 参数列表不同：参数个数不同，参数类型不同</li>
<li>重载的特点:<br>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</li>
<li>重载示例:<br>//返回两个整数的和<br>int add(int x,int y){return x+y;}<br>//返回三个整数的和<br>int add(int x,int y,int z){return x+y+Z;}<br>1返回两个小数的和<br>double add(double x,double y){return x+y;}<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_7.png" alt="重载举例"></li>
</ul>
<h2 id="11-方法的重载细节介绍"><a href="#11-方法的重载细节介绍" class="headerlink" title="11.方法的重载细节介绍"></a>11.方法的重载细节介绍</h2><p><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_8.png" alt="不能构成重载"></p>
<ul>
<li>重载的判断<br>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_9.png" alt="方法没有调用int类型 会自动提升double"></li>
<li>在通过对象调用方法时，如何确定某一个指定的方法：<br>方法名 —&gt; 参数列表(还要看)</li>
</ul>
<h2 id="12-重载的举例与判断"><a href="#12-重载的举例与判断" class="headerlink" title="12.重载的举例与判断"></a>12.重载的举例与判断</h2><p>使用重载，可以为编程带来便捷<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_10.png" alt="重载练习"><br>a n<br>b y  不要看返回值类型<br>c y<br>d ye<br>e y<br>f n<br>g n</p>
<h2 id="13-编程实现"><a href="#13-编程实现" class="headerlink" title="13.编程实现"></a>13.编程实现</h2><p>duplicate 重复的 多重的</p>
<h2 id="14-可变个数的形参的方法"><a href="#14-可变个数的形参的方法" class="headerlink" title="14.可变个数的形参的方法"></a>14.可变个数的形参的方法</h2><h3 id="可变形参的方法"><a href="#可变形参的方法" class="headerlink" title="可变形参的方法"></a>可变形参的方法</h3><p>JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定<br>义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可<br>变的实参。<br>//JDK 5.0以前:采用数组形参来定义方法，传入多个同一类型变量<br>public static void test(int a ,String[] books);<br>//JDK5.0:采用可变个数形参来定义方法，传入多个同一类型变量<br>public static void test(int a ,String…books);</p>
<ul>
<li>具体使用<ul>
<li>1.可变个数形参的格式：数据类型 … 变量名</li>
<li>2.当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</li>
<li>3.可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载  9-11</li>
<li>4.可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。图9-12</li>
<li>5.可变个数形参在方法的形参中，必须声明在末尾<br>String .. .strs必须声明在末尾<br> public void show(int i,String .. .strs)；</li>
<li>6.可变个数形参在方法的形参中,最多只能声明一个可变形参。   一山不容二虎<br>打比方:万能备胎王  ；任何找不到  都不可以找到他；<br>解说都要是String类型 才可以<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_11.png" alt="实现"></li>
</ul>
</li>
</ul>
<p><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_12.png" alt="认为两个一样"></p>
<p>原来的时候</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">test.show(<span class="keyword">new</span> String[]{<span class="string">"AA"</span>,<span class="string">"BB"</span>,<span class="string">"CC"</span>});</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String[] strs)</span></span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">不用new</span><br><span class="line">test.show("AA",“BB”)；</span><br><span class="line">这样做也对</span><br><span class="line">test.show(new String[]{"AA","BB","CC"});</span><br><span class="line"></span><br><span class="line">	public void show(String ... strs){</span><br><span class="line">		System.out.println("show(String ... strs)");</span><br><span class="line">		</span><br><span class="line">		for(int i = 0;i &lt; strs.length;i++){</span><br><span class="line">			System.out.println(strs[i]);</span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<p>应用: SQL 查条件   where 之后条件不知道要写几个</p>
<h2 id="15-理解变量的赋值-难点"><a href="#15-理解变量的赋值-难点" class="headerlink" title="15.理解变量的赋值** 难点"></a>15.理解变量的赋值<strong>**</strong> 难点</h2><h3 id="方法参数的值传递机制"><a href="#方法参数的值传递机制" class="headerlink" title="方法参数的值传递机制"></a>方法参数的值传递机制</h3><ul>
<li>方法，必须由其所在类或对象调用才有意义。若方法含有参数:<ul>
<li>形参:方法声明时的参数</li>
<li>实参:方法调用时实际传给形参的参数值</li>
</ul>
</li>
<li>Java的实参值如何传入方法呢?<br>Java里方法的参数传递方式只有一种:值传递。<br>即将实际参数值的副本(复制品)传入方法内，而参数本身不受影响。<ul>
<li>形参是基本数据类型:将实参基本数据类型变量的“数据值”传递给形参</li>
<li>形参是引用数据类型:将实参引用数据类型变量的“地址值”传递给形参<br>每天坚持 不停去写<br>真是存的数字给它了，自己没有动<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_13.png" alt="基本类型的变量"></li>
</ul>
</li>
</ul>
<p>order o1=o2；<br>一个对象的值修改了会影响到另一个对象<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_14.png" alt="引用类型的变量"><br>Order o2 = o1;//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</p>
<ul>
<li>关于变量赋值<br>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。<br>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
</ul>
<h2 id="16-方法的形参的传递机制：值传递"><a href="#16-方法的形参的传递机制：值传递" class="headerlink" title="16.方法的形参的传递机制：值传递"></a>16.方法的形参的传递机制：值传递</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">形参：方法定义时，声明的小括号内的参数</span><br><span class="line">实参：方法调用时，实际传递给形参的数据</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>值传递机制：<br>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。<br> 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</li>
</ul>
<h2 id="17-方法的形参的传递机制：引用数据类型传递"><a href="#17-方法的形参的传递机制：引用数据类型传递" class="headerlink" title="17.方法的形参的传递机制：引用数据类型传递"></a>17.方法的形参的传递机制：引用数据类型传递</h2><p> ###引用数据类型 赋值了地址<br> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_15.png" alt="引用类型的变量"><br> 交换两个数组元素的值<br> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_16.png" alt="交换两个数组元素的值"></p>
<h2 id="18-画图"><a href="#18-画图" class="headerlink" title="18.画图"></a>18.画图</h2><h2 id="19-探讨网红题目"><a href="#19-探讨网红题目" class="headerlink" title="19.探讨网红题目"></a>19.探讨网红题目</h2><p> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_17.png" alt="题1"><br> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_18.png" alt="题1的答案1"><br> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_19.png" alt="题1的答案2"></p>
<p> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_20.png" alt="题2"><br> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_21.png" alt="题3"></p>
<h2 id="20-参数传递的联系"><a href="#20-参数传递的联系" class="headerlink" title="20 参数传递的联系"></a>20 参数传递的联系</h2><h2 id="21-递归方法的使用"><a href="#21-递归方法的使用" class="headerlink" title="21 递归方法的使用"></a>21 递归方法的使用</h2><h3 id="递归方法-–理解"><a href="#递归方法-–理解" class="headerlink" title="递归方法 –理解"></a>递归方法 –理解</h3><ul>
<li>递归方法：一个方法体内调用它自身。</li>
<li>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</li>
<li>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。<br>eg<br>//计算1-100之间所有自然数的和<br>public int sum(int num){<br>if(num == 1){<br>return 1;<br>}else{<br>return num + sum(num - 1);<br>}<br>}</li>
</ul>
<h2 id="22-递归方法的使用递归的练习"><a href="#22-递归方法的使用递归的练习" class="headerlink" title="22 递归方法的使用递归的练习"></a>22 递归方法的使用递归的练习</h2><p> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_22.png" alt="练习"><br>  <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang-bu-1/9_23.png" alt="题3解答"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象(上)</title>
    <url>/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/</url>
    <content><![CDATA[<h4 id="Java语言的基本元素-类与对象"><a href="#Java语言的基本元素-类与对象" class="headerlink" title="Java语言的基本元素 类与对象"></a>Java语言的基本元素 类与对象</h4><h3 id="5-面向对象的思想概述"><a href="#5-面向对象的思想概述" class="headerlink" title="5. 面向对象的思想概述"></a>5. 面向对象的思想概述</h3><ul>
<li>类(Class)和对象(Object)是面向对象的核心概念。<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
</li>
<li>万事万物皆对象<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_1.png" alt="例子"></li>
</ul>
<ul>
<li><p>可以理解为:<code>类=抽象概念的人</code>;<code>对象=实实在在的某个人</code></p>
</li>
<li><p>面向对象程序设计的重点是<code>类的设计</code>（图纸）</p>
</li>
<li><p>类的设计，其实就是类的成员的设计</p>
</li>
</ul>
<hr>
<h3 id="6-类的结构-属性和方法"><a href="#6-类的结构-属性和方法" class="headerlink" title="6.类的结构: 属性和方法"></a>6.类的结构: 属性和方法</h3><h4 id="Java类及类的成员"><a href="#Java类及类的成员" class="headerlink" title="Java类及类的成员"></a>Java类及类的成员</h4><ul>
<li>现实世界的生物体，大到鲸鱼，小到蚂蚁，都是由最基本的<code>细胞</code>构成的。同理，Java代码世界是由诸多个不同功能的<code>类</code>构成的。</li>
<li>现实生物世界中的细胞又是由什么构成的呢?细胞核、细胞质、..那么,<br>Java中用<code>类class</code>来描述事物也是如此。常见的类的成员有:<ul>
<li>属性:对应类中的成员变量</li>
<li>行为:对应类中的成员方法</li>
</ul>
</li>
<li>Field=属性=成员变量=域，字段，Method= (成员)方法=函数<br>eg： 生活中描述事物无非就是描述事物的属性和行为。如:人有身高，体重等属性，有说话,打球等行为。<br>类的成员构成version 1.0<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_2.png" alt="简单版"></li>
</ul>
<p>类的成员构成version 2.0 </p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_3.png" alt="完整版"></h2><h3 id="7-类和对象的创建"><a href="#7-类和对象的创建" class="headerlink" title="7.类和对象的创建"></a>7.类和对象的创建</h3><p><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_4.png" alt="引入"></p>
<ul>
<li><p>创建类的对象=类的实例化=实例化类</p>
</li>
<li><p>创建对象语法： 类名 对象名 = new 类名();</p>
</li>
<li><p>使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）</p>
</li>
<li><p>二、类和对象的使用(面向对象思想落地的实现)</p>
<ol>
<li>创建类，设计类的成员（多）</li>
<li>创建类的对象</li>
<li>通过““对象.属性或“对象.方法”调用对象的结构<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>{</span><br><span class="line">	<span class="comment">//属性</span></span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">boolean</span> isMale;</span><br><span class="line">	<span class="comment">//方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">	System.out.println(<span class="string">"人可以吃饭"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">	System.out.println(<span class="string">"人可以睡觉"</span>);</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">(String language)</span></span></span><br><span class="line"><span class="function">	</span>{</span><br><span class="line">	System.out.println(<span class="string">"人可以说话,使用的是: "</span> + language);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//创建Person类的对象</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person( ) ;</span><br><span class="line"><span class="comment">//Scanner scanner = new Scanner(System.in);</span></span><br><span class="line"><span class="comment">//调用对象的结构:属性、方法</span></span><br><span class="line"><span class="comment">//调用属性:“对象.属性”</span></span><br><span class="line">p1.name = <span class="string">"Tom"</span>;</span><br><span class="line">p1. isMale = <span class="keyword">true</span>;</span><br><span class="line">System. out . println(p1. name);</span><br><span class="line"><span class="comment">//调用方法:“对象。方法”</span></span><br><span class="line">p1.eat();</span><br><span class="line">p1.sleep();</span><br><span class="line">p1. talk(<span class="string">"Chinese"</span>);</span><br><span class="line">										}</span><br><span class="line">						}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-对类和对象创建的再理解"><a href="#8-对类和对象创建的再理解" class="headerlink" title="8.对类和对象创建的再理解"></a>8.对类和对象创建的再理解</h3>有了对象反推出类—&gt;反射<h3 id="9-类多个对象的关系"><a href="#9-类多个对象的关系" class="headerlink" title="9.类多个对象的关系"></a>9.类多个对象的关系</h3>==   打比方   简历的模板 ，谁填是谁的信息</li>
</ol>
</li>
<li><p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。(非static的)</p>
</li>
<li><p>意味着:如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//将p1变量保存的对象地址值赋给p3 ,导致p1和p3指向了堆空间中的同一个对象实体。</span></span><br><span class="line">Person p3=p1;</span><br><span class="line">System. out. println(p3.name);/ /Tom</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-对象的内存解析"><a href="#10-对象的内存解析" class="headerlink" title="10.对象的内存解析"></a>10.对象的内存解析</h3><p><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_5.png" alt="内存解析"></p>
</li>
</ul>
<p>方法中定义的变量都是局部变量</p>
<p><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_6.png" alt="完整版"></p>
<h3 id="11-属性与局部变量的对比11-12"><a href="#11-属性与局部变量的对比11-12" class="headerlink" title="11.属性与局部变量的对比11-12"></a>11.属性与局部变量的对比11-12</h3><p>属性(成员变量)  VS 局部变量 （打比方 放的位置不同 蜂王和工蜂）</p>
<p>1.相同点</p>
<ul>
<li>定义变量的格式:数据类型变量名=变量值</li>
<li>先声明，后作用</li>
<li>变量都有其对应的作用域、</li>
</ul>
<p>2.不同点</p>
<ul>
<li><p>在类中声明的位置的不同</p>
<ul>
<li>属性：直接定义在类的一对{}内<ul>
<li>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量<br> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_7.png" alt="局部变量的位置举例子"></li>
<li>关于权限修饰符的不同</li>
</ul>
</li>
<li>属性：可以在声明属性时，指明其权限，使用权限修饰符。<pre><code>常用的权限修饰符：private、public、缺省、protected  ---&gt;封装性   作用域的大小
  目前，大家声明属性时，都使用缺省就可以了。</code></pre><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_8.png" alt="成员变量权限修饰符举例子"></li>
<li>局部变量：不可以使用权限修饰符，并没有默认初始化值（也就是理解方法代替了）</li>
</ul>
</li>
<li><p>默认初始化值的情况:</p>
<ul>
<li><p>属性:类的属性，根据其类型，都有默认初始化值。<br>整型(byte、short、int、long):0<br>浮点型(float、double) 0.0<br>字符型(char):0或’\u0000’ )<br>布尔型(boolean) : false<br>引用数据类型(类、数组、接口) : null<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_9.png" alt="属性的默认值举例子"></p>
</li>
<li><p>局部变量:没有默认初始化值。<br>意味着，我们在调用局部变量之前，一定要显式赋值。<br>特别地:形参在调用时，我们赋值即可。（下图）<br><img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_10.png" alt="形参在调用时，我们赋值"></p>
</li>
<li><p>在内存中加载的位置:<br>属性:加载到堆空间中(非static 存在 方法区)<br>局部变量:加载到栈空间</p>
</li>
</ul>
</li>
</ul>
<h3 id="13-类中方法举例与声明的格式"><a href="#13-类中方法举例与声明的格式" class="headerlink" title="13. 类中方法举例与声明的格式"></a>13. 类中方法举例与声明的格式</h3><p>方法：描述类应该具有的功能<br>比如 Math类的sqrt()</p>
<ol>
<li><p>举例<br>public void eat(){}<br>public void sleep(int hour){}<br>public String getName(){}<br>public String getNation(String nation){}</p>
</li>
<li><p>方法的声明：<br>权限修饰符  返回值类型  方法名(形参列表){  方法体 };<br>注意：static、final、abstract 来修饰的方法，后面再讲。</p>
<h3 id="14-方法声明的说明14-15"><a href="#14-方法声明的说明14-15" class="headerlink" title="14. 方法声明的说明14-15"></a>14. 方法声明的说明14-15</h3><ol start="3">
<li>说明：</li>
</ol>
<ul>
<li><p>3.1 关于权限修饰符：默认方法的权限修饰符先都使用public<br>Java规定的4种权限修饰符：private、public、缺省、protected  –&gt;封装性再细说</p>
</li>
<li><p>3.2 返回值类型： 有返回值 vs 没有返回值</p>
<ul>
<li>如果方法<code>有</code>返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：“return 数据”。</li>
<li>如果方法<code>没有</code>返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。</li>
<li>3.2.2 我们定义方法该不该有返回值？<br>① 题目要求② 凭经验：具体问题具体分析</li>
</ul>
</li>
<li><p>3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意”</p>
</li>
<li><p>3.4 形参列表： 方法可以声明0个，1个或多个形参。</p>
</li>
<li><p>3.5 方法体：方法功能的体现。 </p>
<h3 id="16-return关键字的使用"><a href="#16-return关键字的使用" class="headerlink" title="16 return关键字的使用"></a>16 return关键字的使用</h3></li>
</ul>
</li>
<li><p>return关键字的使用：</p>
</li>
</ol>
<ul>
<li><p>1.使用范围：使用在方法体中</p>
<ul>
<li>2.作用：① 结束方法 ② 针对于有返回值类型的方法，使用”return 数据”方法返回所要的数据。</li>
<li>3.注意点：return关键字后面不可以声明执行语句。<h3 id="17-方法使用中的注意点"><a href="#17-方法使用中的注意点" class="headerlink" title="17. 方法使用中的注意点"></a>17. 方法使用中的注意点</h3></li>
</ul>
</li>
</ul>
<ol start="5">
<li>方法的使用中，可以调用当前类的属性或方法<br>特殊的：方法A中又调用了方法A:递归方法。<br>方法中，不可以定义方法。<br> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_11.png" alt="方法中，不可以定义方法。"></li>
</ol>
<h3 id="18-19-20-类的设计-练习"><a href="#18-19-20-类的设计-练习" class="headerlink" title="18-19-20. 类的设计 练习"></a>18-19-20. 类的设计 练习</h3><h3 id="21-22"><a href="#21-22" class="headerlink" title="21-22"></a>21-22</h3><p> <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_12.png" alt="题4-5"></p>
<p> test  类</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4. 对象数组题目：</span></span><br><span class="line"><span class="comment">定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</span></span><br><span class="line"><span class="comment"> 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</span></span><br><span class="line"><span class="comment">问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line"><span class="comment">问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1) 生成随机数：Math.random()，返回值类型double;  </span></span><br><span class="line"><span class="comment">2) 四舍五入取整：Math.round(double d)，返回值类型long。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line"><span class="comment">//		Student s1 = new Student();</span></span><br><span class="line">		<span class="comment">//声明Student类型的数组</span></span><br><span class="line">		Student[] stus = <span class="keyword">new</span> Student[<span class="number">20</span>];  <span class="comment">//String[] arr = new String[10];</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length;i++){</span><br><span class="line">			<span class="comment">//给数组元素赋值</span></span><br><span class="line">			stus[i] = <span class="keyword">new</span> Student();</span><br><span class="line">			<span class="comment">//给Student对象的属性赋值</span></span><br><span class="line">			stus[i].number = (i + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//年级：[1,6]</span></span><br><span class="line">			stus[i].state = (<span class="keyword">int</span>)(Math.random() * (<span class="number">6</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//成绩：[0,100]</span></span><br><span class="line">			stus[i].score = (<span class="keyword">int</span>)(Math.random() * (<span class="number">100</span> - <span class="number">0</span> + <span class="number">1</span>));</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line"><span class="comment">//			System.out.println(stus[i].number + "," + stus[i].state </span></span><br><span class="line"><span class="comment">//					+ "," + stus[i].score);</span></span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		<span class="comment">//问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line">			<span class="keyword">if</span>(stus[i].state == <span class="number">3</span>){</span><br><span class="line">				System.out.println(stus[i].info());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		<span class="comment">//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length - <span class="number">1</span>;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; stus.length - <span class="number">1</span> - i;j++){</span><br><span class="line">				<span class="keyword">if</span>(stus[j].score &gt; stus[j + <span class="number">1</span>].score){</span><br><span class="line">					<span class="comment">//如果需要换序，交换的是数组的元素：Student对象！！！</span></span><br><span class="line">					Student temp = stus[j];</span><br><span class="line">					stus[j] = stus[j + <span class="number">1</span>];</span><br><span class="line">					stus[j + <span class="number">1</span>] = temp;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>{</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//学号</span></span><br><span class="line">	<span class="keyword">int</span> state;<span class="comment">//年级</span></span><br><span class="line">	<span class="keyword">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示学生信息的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"学号："</span> + number + <span class="string">",年级："</span> + state + <span class="string">",成绩："</span> + score;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>




<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4. 对象数组题目：     </span></span><br><span class="line"><span class="comment">定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。</span></span><br><span class="line"><span class="comment"> 创建20个学生对象，学号为1到20，年级和成绩都由随机数确定。</span></span><br><span class="line"><span class="comment">问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line"><span class="comment">问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">1) 生成随机数：Math.random()，返回值类型double;  </span></span><br><span class="line"><span class="comment">2) 四舍五入取整：Math.round(double d)，返回值类型long。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 此代码是对StudentTest.java的改进：将操作数组的功能封装到方法中。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest1</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//声明Student类型的数组</span></span><br><span class="line">		Student1[] stus = <span class="keyword">new</span> Student1[<span class="number">20</span>];  </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length;i++){</span><br><span class="line">			<span class="comment">//给数组元素赋值</span></span><br><span class="line">			stus[i] = <span class="keyword">new</span> Student1();</span><br><span class="line">			<span class="comment">//给Student对象的属性赋值</span></span><br><span class="line">			stus[i].number = (i + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//年级：[1,6]</span></span><br><span class="line">			stus[i].state = (<span class="keyword">int</span>)(Math.random() * (<span class="number">6</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//成绩：[0,100]</span></span><br><span class="line">			stus[i].score = (<span class="keyword">int</span>)(Math.random() * (<span class="number">100</span> - <span class="number">0</span> + <span class="number">1</span>));</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		StudentTest1 test = <span class="keyword">new</span> StudentTest1();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		test.print(stus);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题一：打印出3年级(state值为3）的学生信息。</span></span><br><span class="line">		test.searchState(stus, <span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"********************"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//问题二：使用冒泡排序按学生成绩排序，并遍历所有学生信息</span></span><br><span class="line">		test.sort(stus);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历学生数组</span></span><br><span class="line">		test.print(stus);</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span>  遍历Student1[]数组的操作</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2019年1月15日下午5:10:19</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stus</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Student1[] stus)</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line">			System.out.println(stus[i].info());</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span> 查找Stduent数组中指定年级的学生信息</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2019年1月15日下午5:08:08</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stus 要查找的数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> state 要找的年级</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchState</span><span class="params">(Student1[] stus,<span class="keyword">int</span> state)</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;stus.length;i++){</span><br><span class="line">			<span class="keyword">if</span>(stus[i].state == state){</span><br><span class="line">				System.out.println(stus[i].info());</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@Description</span> 给Student1数组排序</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@date</span> 2019年1月15日下午5:09:46</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stus</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Student1[] stus)</span></span>{</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stus.length - <span class="number">1</span>;i++){</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; stus.length - <span class="number">1</span> - i;j++){</span><br><span class="line">				<span class="keyword">if</span>(stus[j].score &gt; stus[j + <span class="number">1</span>].score){</span><br><span class="line">					<span class="comment">//如果需要换序，交换的是数组的元素：Student对象！！！</span></span><br><span class="line">					Student1 temp = stus[j];</span><br><span class="line">					stus[j] = stus[j + <span class="number">1</span>];</span><br><span class="line">					stus[j + <span class="number">1</span>] = temp;</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student1</span></span>{</span><br><span class="line">	<span class="keyword">int</span> number;<span class="comment">//学号</span></span><br><span class="line">	<span class="keyword">int</span> state;<span class="comment">//年级</span></span><br><span class="line">	<span class="keyword">int</span> score;<span class="comment">//成绩</span></span><br><span class="line">	<span class="comment">//显示学生信息的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">info</span><span class="params">()</span></span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"学号："</span> + number + <span class="string">",年级："</span> + state + <span class="string">",成绩："</span> + score;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>  <img src="/2016/06/27/2016-06-10-mian-xiang-dui-xiang-shang/8_13.png" alt="内存解析图"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>面向对象概述</tag>
      </tags>
  </entry>
  <entry>
    <title>基本数据类型</title>
    <url>/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/</url>
    <content><![CDATA[<h3 id="1-Java-语言基础-基本数据类型"><a href="#1-Java-语言基础-基本数据类型" class="headerlink" title="1. Java 语言基础-基本数据类型"></a>1. Java 语言基础-基本数据类型</h3><h4 id="1-HelloWorld程序的讲解"><a href="#1-HelloWorld程序的讲解" class="headerlink" title="1. HelloWorld程序的讲解"></a>1. HelloWorld程序的讲解</h4><p> <img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/1_10.png" alt="1586920600288"></p>
<ul>
<li>public、class、static、 void为关键字，固定写法</li>
<li>HelloWord 为类名，可以任意写</li>
<li>main 为函数或方法名，每个程序都有一个main函数做为入口，如同房间，需要有个门一样</li>
<li>main方法后面括号的内容称为参数</li>
<li>System. out. println(“HelloWord” )向控制台输入内容</li>
<li>注意:类名第一个字母要使用大写，花括号是成对出现的</li>
</ul>
<h4 id="2-常量的概述和使用"><a href="#2-常量的概述和使用" class="headerlink" title="2. 常量的概述和使用"></a>2. 常量的概述和使用</h4><h5 id="什么是常量"><a href="#什么是常量" class="headerlink" title="什么是常量"></a>什么是常量</h5><p>在程序执行的过程中其值不可以发生改变</p>
<h5 id="Java中常量的分类"><a href="#Java中常量的分类" class="headerlink" title="Java中常量的分类"></a>Java中常量的分类</h5><p>①字面值常量<br>②自定义常量(面向对象部分讲)</p>
<h5 id="字面值常量的分类"><a href="#字面值常量的分类" class="headerlink" title="字面值常量的分类"></a>字面值常量的分类</h5><p>①字符串常量用双引号括起来的内容      “Java”<br>②整数常量所有整数    1000<br>③小数常量所有小数   3.14       有效数字  float 6-7   double 15-16<br>④字符常量用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号   ‘c’<br>⑤布尔常量较为特殊，只有true和false<br>⑥空常量null [数组部分]<br>win10 快速访问</p>
<h4 id="3-二-八-十六进制"><a href="#3-二-八-十六进制" class="headerlink" title="3. 二,八,十六进制"></a>3. 二,八,十六进制</h4><h5 id="什么是进制"><a href="#什么是进制" class="headerlink" title="什么是进制"></a>什么是进制</h5><p>  进制是一种进位方法。对于任何一种进制 X进制，就表示某-位置上的数 运算时逢X进一一位。</p>
<ul>
<li><p>二进制就是逢二进一，</p>
</li>
<li><p>八逆制是逢八进一，</p>
</li>
<li><p>十进制是逢十进一，</p>
</li>
<li><p>十六进制是逢十六进-一。</p>
</li>
<li><p>不同进制数据的Java表现形式</p>
<ul>
<li><p>二进制的数据表现形式 -一 由0,1组成。以0b(b可大小写)开头2= 10<br><code>System.out.print(0b10);</code></p>
</li>
<li><p>八进制的数据表现形式— 由0,1,…7组成。 以0开头[8= 10]</p>
<p><code>System.out.print(011);</code></p>
</li>
<li><p>十进制的数据表现形式—由0,1-9组成。整数默认是十进制的[10= 10]</p>
</li>
<li><p>十六进制的数据表现形式—由,1,–9,a,b,c,d,e,f(大小写均可)。以0x开头[16= 10]</p>
<p><code>System.out.print(0X16);</code>    </p>
</li>
</ul>
</li>
<li><p>注意:只有JDK1.7版本以上可以使用0b2来表示二进制</p>
</li>
</ul>
<h5 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h5><ul>
<li>在计算机中，只能识别二进制的数据，二进制就是0和1来表示的<br><img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_1.png" alt="1586920600288"><br> 如上图表示1个字节，一个字节有8个比特位(1lbyte =8bit)</li>
<li>字节是数据存储的基本单位</li>
<li>数据存储单位计算<br>1byte=8bit (比特)<br>1kb = 1024byte<br>1M = 1024kb<br>1G = 1024M<br>1T=1024G</li>
</ul>
<h5 id="二进制和十进制的转换"><a href="#二进制和十进制的转换" class="headerlink" title="二进制和十进制的转换"></a>二进制和十进制的转换</h5><ul>
<li>任意进制到十进制的转换原理<ul>
<li>系数:就是每一位上的数据。</li>
<li>基数: x进制，基数就是X.</li>
<li>权:在右边，从0开始编号，对应位上的编号即为该位的权。</li>
<li>结果:把系数*基数的权次幂相加即可。</li>
</ul>
</li>
<li>图解<br><img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_2.png" alt="1586920600288"></li>
</ul>
<h5 id="八进制到十进制的转换"><a href="#八进制到十进制的转换" class="headerlink" title="八进制到十进制的转换"></a>八进制到十进制的转换</h5><p> <img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_3.png" alt="1586920600288"></p>
<h5 id="十六进制到十进制的转换"><a href="#十六进制到十进制的转换" class="headerlink" title="十六进制到十进制的转换"></a>十六进制到十进制的转换</h5><p> <img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_4.png" alt="1586920600288"></p>
<h5 id="原码反码补码"><a href="#原码反码补码" class="headerlink" title="原码反码补码"></a>原码反码补码</h5><ul>
<li><p>有符号数据表示法的几种方式</p>
<ul>
<li><p>原码</p>
<ul>
<li><p>就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。    左边是最高位，右边最低位   </p>
<p>1111 1111 255</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 通过一个字节,也就是8个二进制位表示+7和-7

- 0(符号位) 0000111     +7

- 1(符号位) 0000111     -7</code></pre><ul>
<li><p>反码<br>正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</p>
<p>eg. -7 1 000 0111（原码）</p>
<p>反码   11111 000</p>
</li>
<li><p>补码<br>正数的补码与其原码相同；负数的补码是在其反码的末位加1</p>
</li>
<li><p>-7的补码 1111 1001 </p>
</li>
</ul>
<ul>
<li><p><img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_5.png" alt="1586920600288"></p>
</li>
<li><p>原码反码补码练习</p>
<ul>
<li><p>已知原码求补码* 0b10110100</p>
<p>11001011+1    1100 1100</p>
</li>
<li><p>已知补码求原码* 0b11101110</p>
<p>1110 1110           1110  1101     -&gt;1001 0010</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-变量和数据类型"><a href="#4-变量和数据类型" class="headerlink" title="4. 变量和数据类型"></a>4. 变量和数据类型</h4><ul>
<li>变量的概述及格式<ul>
<li>什么是变量<br>在程序执行的过程中，在某个范围内其值可以发生改变的量</li>
<li>变量的定义格式，[如同数据方程式xyz, 求值]<br>数据类型 变量名=变量值;<br>byte b= 127;</li>
<li>为什么要定义变量<br>用来不断的存放同类型的常量,并可以<code>重复使用</code></li>
</ul>
</li>
</ul>
<h4 id="5-基本数据类型的定义"><a href="#5-基本数据类型的定义" class="headerlink" title="5. 基本数据类型的定义"></a>5. 基本数据类型的定义</h4><ul>
<li><p>为什么有数据类型</p>
<ul>
<li>Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，</li>
<li>每一种数据类型在内存中分配了不同大小的内存空间</li>
<li>这样做是为了充分高效的利用内存空间  -&gt;  2m的人  2m床</li>
</ul>
</li>
<li><p>Java中数据类型的分类<br>①基本数据类型<br>②引用数据类型(面向对象部分)</p>
</li>
<li><p>基本数据类型分类(4类8种)</p>
<ul>
<li>整数型:<br>byte (字节类型)  占一个字节 -2^7<del>2^7-1[-128</del>127]   </li>
</ul>
<p><code>不能把一个int 型转换为byte型</code></p>
<p>short 占两个字 -2^15~ 2^15-1 [ -32768<del>32767]<br>int      占四个字节-2^31</del>2^31-1 [-2^31=2147483647]<br>1ong  占八个字节- 2^63~ 2^63-1 [ -2^63=9223372036854775807]<br><code>写长整型时，加个L标识,可以写小写的l,但小写的l像一，不建议写
  long d = -922L;
System.out.println(d);</code></p>
</li>
<li><p>浮点型:<br>float单精度占四个字节 -3.403E38~3.403E38<br><code>单精度型使用F标识,不加F,默认就是双精度
float e = 1.87312343F;//单精度型使用F标识
System.out.println(e);</code></p>
</li>
</ul>
<p>double双精度占八个字节-1.798E308~1.798E308</p>
<ul>
<li>字符型: char占两个字节0~65535</li>
<li>布尔型: boolean java中boolean类型没有明确指定他的大小</li>
<li>基本数据类型定义的注意事项<ul>
<li>赋值时候注意float类型,long类型，加大写的F和L</li>
<li>作用域问题:同一个区域不能使用相同的变量名 </li>
<li>初始化值问题:局部变量在使用之前必须赋值</li>
<li>一条语句可以定义几个变量 eg: int a,b,c</li>
</ul>
</li>
</ul>
<h4 id="6-数据类型转换"><a href="#6-数据类型转换" class="headerlink" title="6.数据类型转换"></a>6.数据类型转换</h4><ul>
<li>Java中 的默认转换规则<ul>
<li>取值范围小的数据类型与取值范围大的数据类型进行运算会先将小的数据类型提升为大的.再运算</li>
<li>Java的运算是以<code>补码</code>形式运算的<br><img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_6.png" alt="1586920600288"><br>得到了结果是1000 0010   ==    -2  再转换为补码<br>强制类型转换会损失精度  </li>
</ul>
</li>
<li>数据类型相加的细节<ul>
<li>进行混合运算的时候,byte,short,char不会相互转换都会自动类型提升为int类型</li>
<li>byte,short,char与其他类型进行混合运算的是小的数据类型提升为大的</li>
</ul>
</li>
</ul>
<h4 id="7-面试题-long与float的取值范園谁大谁小"><a href="#7-面试题-long与float的取值范園谁大谁小" class="headerlink" title="7.面试题:long与float的取值范園谁大谁小"></a>7.面试题:long与float的取值范園谁大谁小</h4><p> <img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_8.png" alt="1586920600288"><br> <img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_9.png" alt="1586920600288"></p>
<ul>
<li>重点<br><img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_7.png" alt="1586920600288"></li>
</ul>
<h4 id="8-字符和字符串参与运算"><a href="#8-字符和字符串参与运算" class="headerlink" title="8.字符和字符串参与运算"></a>8.字符和字符串参与运算</h4><h5 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h5><ul>
<li>字符是指计算机中使用的字母、数字、字和符号，包括: 1、2、3、A、B、C、~，( )一一+等等。</li>
<li>在ASCII编码中，一个英文字母字符存储需要1个字节。</li>
<li>在GB2312编码或GBK编码中，一个汉字字符存储需要2个字节。</li>
<li>在UTF-8编码中，一个英文字母存储需要1个字节，一个汉字储存需要3到4个字节。</li>
</ul>
<h5 id="字符的定义"><a href="#字符的定义" class="headerlink" title="字符的定义"></a>字符的定义</h5><ul>
<li>使用char来定义字符类型</li>
<li>给char赋值时，如果是字母或者其它字符使用单引用号<br>如: char c=‘a’</li>
<li>给char 赋值时，可以直接使用asci表的数字<br>如: char c= 97</li>
<li>在ascii表中大写的与小写的相差32 </li>
</ul>
<h5 id="告白"><a href="#告白" class="headerlink" title="告白"></a>告白</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="number">73</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="number">76</span>;</span><br><span class="line"><span class="keyword">char</span> c3 = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">char</span> c4 = <span class="number">118</span>;</span><br><span class="line"><span class="keyword">char</span> c5 = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">char</span> c6 = <span class="number">89</span>;</span><br><span class="line"><span class="keyword">char</span> c7 = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">char</span> c8 = <span class="number">117</span>;</span><br></pre></td></tr></tbody></table></figure>

<h5 id="字符的相加"><a href="#字符的相加" class="headerlink" title="字符的相加"></a>字符的相加</h5><ul>
<li>字符相加会把字符对应的ascii数字相加</li>
<li><img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_10.png" alt="1111"></li>
</ul>
<h5 id="记住ASCII码的三个值："><a href="#记住ASCII码的三个值：" class="headerlink" title="记住ASCII码的三个值："></a>记住ASCII码的三个值：</h5><p>‘0’ 48<br>‘A’ 65<br>‘a’ 97</p>
<h5 id="字符与字符串相加"><a href="#字符与字符串相加" class="headerlink" title="字符与字符串相加"></a>字符与字符串相加</h5><p> <img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_11.png" alt="1586920600288"></p>
<h5 id="char数据与中文"><a href="#char数据与中文" class="headerlink" title="char数据与中文"></a>char数据与中文</h5><ul>
<li>char数据类型<br>char 在ascii编码中占1个字节 取值在0到127<br>char 在unicode编码中占2个字节 取值在0到65535</li>
</ul>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题:"></a>面试题:</h4><h5 id="Java语言中的字符char可以存储一个中文汉字吗-为什么呢"><a href="#Java语言中的字符char可以存储一个中文汉字吗-为什么呢" class="headerlink" title="Java语言中的字符char可以存储一个中文汉字吗?为什么呢?"></a>Java语言中的字符char可以存储一个中文汉字吗?为什么呢?</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节，utf-8编码是unicode中的一种编码，所以，Java中的字符可以存储一个中文汉字</span><br></pre></td></tr></tbody></table></figure>

<p>注:可以把编码类型改成ascii再打印中文给学生看，讲解为什么<br>GBK编码 ： 只能显示简体中文<br>GB2312编码:只能显示简体、繁体中文<br>Unicode编码：不仅可以存中文，还有可存日文，韩文(万国码)<br>-UTF-8 (万国码)<br>-UTF-16</p>
<h5 id="Unicode码"><a href="#Unicode码" class="headerlink" title="Unicode码"></a>Unicode码</h5><ul>
<li>Unicode是一种字符集，中、日、韩的三种文字占用了Unicode中0x3000到0x9FFF的部分 </li>
<li>Unicode采用的是UCS-2,用两个字节表示一个字符，2的16次方等于65536，最多能编码65536个字符</li>
<li>比如汉字“经”的编码是0x7ECF （字符码一般用16进制表示），转换成10进制就是32463</li>
<li>unicode编码从0到127的字符与ASCII编码的字符一样<ul>
<li>比如字母”a”的Unicode 编码是0x0061,十进制是97</li>
<li>而”a”的ASCII编码是0x61,十进制也是97</li>
</ul>
</li>
<li>对于汉字的编码，事实上Unicode对汉字支持不怎么好<ul>
<li>因为简体和繁体总共有六七万个汉字，而UCS-2最多能表示65536个，才六万 多个</li>
<li>所以Unicode只能排除一些几乎不用的汉字</li>
<li>好在常用的简体汉字 也不过七千多个</li>
<li>为了能表示所有汉字，Unicode也有UCS-4规范，就是用 4个字节来编码字符</li>
</ul>
</li>
</ul>
<h5 id="UTF-8编码"><a href="#UTF-8编码" class="headerlink" title="UTF-8编码"></a>UTF-8编码</h5><ul>
<li>UTF-8(8-bit Unicode Transformation Format)是一种针对Unicode的可变长度字符编码,又称万国码。项目开发中常用utf-8</li>
<li>查看部分unicode码表<br><a href="http://baike.baidu.com/item/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8/12022016?sefr=cr" target="_blank" rel="noopener">http://baike.baidu.com/item/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8/12022016?sefr=cr</a></li>
<li>在线unicode码转换<ul>
<li>网址: <a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener">http://tool.chinaz.com/tools/unicode.aspx</a></li>
<li>演示a的unicode \u0061 0x61</li>
<li>演示中的unicode \u4e2d</li>
<li>熟记中文在unicode的范围 \u4E00-\u9FA5 19968 ~ 40869<br><img src="/2016/06/24/2016-06-24-ji-ben-shu-ju-lei-xing/2_12.png" alt="1586920600288"></li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
  </entry>
  <entry>
    <title>引言:为什么学习Java以及怎么学习Java</title>
    <url>/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/</url>
    <content><![CDATA[<h3 id="1认识Java"><a href="#1认识Java" class="headerlink" title="1认识Java+"></a>1认识Java+</h3><h4 id="1-Java在公司里是用于干啥的-主要1和3"><a href="#1-Java在公司里是用于干啥的-主要1和3" class="headerlink" title="1. Java在公司里是用于干啥的?(主要1和3)"></a>1. Java在公司里是用于干啥的?(主要1和3)</h4><p>①Java web: 银行系统&amp;银行网站&amp;酒店系统&amp;N多后台管理系统   主要<br>②App: android是 用java写的，今年出了新的kotlin语言<br>③接口:为android、i0S等App提供数据访问接口    主要<br>④大数据(马云说过“大”是计算的意思)<br>⑤桌面应用(比较少开发桌面应用)<br>⑥….</p>
<h4 id="2-Java的招聘需求及薪资"><a href="#2-Java的招聘需求及薪资" class="headerlink" title="2. Java的招聘需求及薪资"></a>2. Java的招聘需求及薪资</h4><p> 拉钩</p>
<img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_1.png" class="" title="This is an example image">

<h4 id="3-Java的职业规划发展方向"><a href="#3-Java的职业规划发展方向" class="headerlink" title="3. Java的职业规划发展方向"></a>3. Java的职业规划发展方向</h4><ol>
<li>首席java程序员</li>
<li>项目组组长:管理一个小团队</li>
<li>技术总监:主要把控项目中技术一块</li>
<li>软件系统架构师:负责整个项目的架构和技术实施方案（服务器 运维 并发  5年）</li>
<li>技术合伙人:公司的技术一把手，以技术来占公司股份，不需要花钱买（以技术入股）</li>
<li>软件营销:成为一个软件方面的销售高手</li>
<li>当IT讲师:传授你的工作经验</li>
<li>创业:与其他好友同事创业，开自己的公司，接外包或者做自己的产品</li>
<li>赚得一-定财富后，回老家开小店过小日子   (年薪20万    要有副业)</li>
</ol>
<h4 id="4-Java的就业前景和形势"><a href="#4-Java的就业前景和形势" class="headerlink" title="4. Java的就业前景和形势"></a>4. Java的就业前景和形势</h4><ol>
<li>领域非常广<br>Java技术具有卓越的通用性、高效性、平台移植性和安全性，广泛应用于PC、数据中心、游戏控制台、科学超级计算机、移动电话和互联网，所以说Java的应用领域非常广，同时拥有全球最大的开发者专业社群</li>
<li>需求量大<br>Java是全球最流行的开发语言，我国的软件开发人才极为缺乏，其中java人才缺口最大，对java软件工程师的需求达到全部需求量的60% -70%，Java又 是安卓开发的基础，所以人才的需求又增加一大波。</li>
<li>就业方向非常广<br>学完可应聘java\h5\android\大数据架构师等职位。。。<br>Java是一一门世界最好的语言，学会了Java再学习其它语言php, ios, python等非常容易上手<br>一个星期或者半个月就可以做项目<br>总结:学了Java,你可以在招聘网上投递的职位非常多<br>需求量巨大</li>
</ol>
<h4 id="5-Java的学习方法和建议"><a href="#5-Java的学习方法和建议" class="headerlink" title="5.  Java的学习方法和建议"></a>5.  Java的学习方法和建议</h4><ol>
<li>跟着上课老师的课程大纲学习，掌握课堂知识点。</li>
<li>勤做笔记，如果上课走神或者没听懂的知识点，记下时间，再倒回去看视频。</li>
<li>复习时看视频，尽量1.5~2倍来看视频,课后多练代码。   写多了  就理解多了</li>
<li>尽量老师一边讲课，同学们一边写代码，当场掌握知识点。</li>
<li>不懂的多问老师与同学，因为毕业后，不一定才能能及时帮到你。</li>
<li>要有自己的思维，做一个功能或者需求时，想想有没有另一种方法。</li>
<li>多与同班同学交流，丰富情感生活，以后好互相推荐工作。</li>
<li>脑子累了要休息，尽量不要晚上通宵写代码，身体要紧。</li>
<li>每周或者两周要去参加一个活动,集体打球。</li>
<li>还有一点是学程序开发，有时是枯澡无味的，要忍住无聊和寂寞，特别是Java基础</li>
</ol>
<h4 id="6-学习前要谨记一些心态"><a href="#6-学习前要谨记一些心态" class="headerlink" title="6.  学习前要谨记一些心态"></a>6.  学习前要谨记一些心态</h4><ul>
<li>只要努力掌握课堂知识和老师的建议再加上自己的信心，找份较满意工资的工作是没有问题</li>
<li>一个班不可能每个都拿高薪，工资高的不一定是知识掌握的最好的那位同学。有时高薪看天<br>时地利人和</li>
<li>学习Java找工作，只是你的一一个起点，以后你还会学习其它的语言，或者说不干程序员这份<br>工作也说不定。(sina- 程序员辞职卖水果)</li>
<li>只要学精一门语言，不用怕以后这门语言不值钱，不用怕以后找不到工作。经验是最值钱的</li>
</ul>
<p>对自己要有信心&amp;工资量&amp;打牢固<br>公司看中经验</p>
<h3 id="2-计算机基础-amp-DOS"><a href="#2-计算机基础-amp-DOS" class="headerlink" title="2.计算机基础&amp;DOS"></a>2.计算机基础&amp;DOS</h3><h4 id="1-计算机简介"><a href="#1-计算机简介" class="headerlink" title="1. 计算机简介:"></a>1. 计算机简介:</h4><ul>
<li>计算机(computer) 俗称电脑，是现代一种用于高速计算的电子计算机器，是能够按照程序运<br>行，自动、高速处理海量数据的现代化智能电子设备。</li>
<li>计算机由硬件系统和软件系统所组成，没有安装任何软件的计算机称为裸机。</li>
<li>计算机可分为超级计算机、工业控制计算机、网络计算机、个人计算机、嵌入式计算机五类，<br>较先进的计算机有生物计算机、光子计算机、量子计算机等。</li>
<li>计算机发明者约翰.冯，诺依曼。计算机是20世纪最先进的科学技术发明之一</li>
<li>计算机的硬件分成5大组成部件:运算器、控制器、存储器、输入设备和输出设备。<ul>
<li>运算器、控制器合称为中央处理单元(Central ProcessingUnit, CPU)或处理器</li>
<li>存储器分为:<br>内部存储器(内存条) -重启电脑数据不在<br> 外部存储器(U盘、硬盘),重启电脑数据还在</li>
<li>输入设备有键盘、 鼠标等</li>
<li>输出设备有显示器、打印机等</li>
</ul>
</li>
</ul>
<h4 id="2-计算机的操作系统"><a href="#2-计算机的操作系统" class="headerlink" title="2. 计算机的操作系统"></a>2. 计算机的操作系统</h4><ul>
<li>操作系统(Operating System, 简称0S)是管理和控制计算机硬件与软件资源的<br>计算机程序，是直接运行在”裸机”上的最基本的系统软件，任何其他软件都必<br>须在操作系统的支持下才能运行。</li>
<li>常见的操作系统: Windows/Linux/MacOS/ Android/ iOS</li>
</ul>
<h4 id="3-计算机软件概念"><a href="#3-计算机软件概念" class="headerlink" title="3. 计算机软件概念"></a>3. 计算机软件概念</h4><ul>
<li>软件(中国大陆及香港用语，台湾称作软体，英文: Software)   app</li>
<li>软件是一系列按照特定顺序组织的计算机数据和指令的集合。</li>
<li>一般来讲软件被划分为<code>系统软件、应用软件</code>和介于这两者之间的中间件。</li>
<li>系统软件:windows/linux/macOS/ Android/i0S</li>
<li>应用软件:QQ WeChat 浏览器迅雷、后台系统等…</li>
</ul>
<h4 id="4-软件开发的概念"><a href="#4-软件开发的概念" class="headerlink" title="4. 软件开发的概念"></a>4. 软件开发的概念</h4><h5 id="什么是软件开发"><a href="#什么是软件开发" class="headerlink" title="什么是软件开发"></a>什么是软件开发</h5><p>借助开发工具与计算机语言制作软件</p>
<h5 id="什么是计算机语言"><a href="#什么是计算机语言" class="headerlink" title="什么是计算机语言"></a>什么是计算机语言</h5><p>人与计算机之间进行信息交流沟通的一种特殊语言</p>
<h5 id="计算机语言的分类"><a href="#计算机语言的分类" class="headerlink" title="计算机语言的分类"></a>计算机语言的分类</h5><ul>
<li>机器语言:<br>机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。</li>
<li>汇编语言:<br>汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。</li>
<li>高级语言:<br>使用普通英语进行编写源代码，通过<code>编译器</code>将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。高级语言包括C,C++, C#, JAVA，PHP, Py thon</li>
</ul>
<h4 id="5-DOS命令"><a href="#5-DOS命令" class="headerlink" title="5. DOS命令"></a>5. DOS命令</h4><p>​        DOS (<code>磁盘操作系统</code>)命令，是DOS操作系统的命令，是一种面向磁盘的操作命令，主要包括目录操作类命令、磁盘操作类命令、文件操作类命令和其它命令。常用命令如下:</p>
<p>win+e 文件资源管理器 win+r 命令行</p>
<h5 id="1-查看目录内容命令dir"><a href="#1-查看目录内容命令dir" class="headerlink" title="1. 查看目录内容命令dir"></a>1. 查看目录内容命令<code>dir</code></h5><p>   <img src="/1_1.png" alt="1586910803670"></p>
<h5 id="2-打开指定目录命令-语法-cd路径"><a href="#2-打开指定目录命令-语法-cd路径" class="headerlink" title="2. 打开指定目录命令[语法: cd路径]"></a>2. 打开指定目录命令[语法: cd路径]</h5><p>   拖拽 </p>
<p>   2.1 同盘下(切换路径)</p>
<p>   <img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_2.png" alt="1586911147759"></p>
<p>   2.2 异盘下(切换到D盘)</p>
<p>   <img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_3.png" alt="1586911588039"></p>
<p>   2.3 特殊用法 ;返回当前盘的根路径</p>
<p>   <img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_4.png" alt="1586911661427"></p>
<h5 id="3-创建目录命令-语法-md-文件夹名字-—mkdir-dir"><a href="#3-创建目录命令-语法-md-文件夹名字-—mkdir-dir" class="headerlink" title="3. 创建目录命令[语法:md 文件夹名字]  —mkdir dir"></a>3. 创建目录命令[语法:<code>md 文件夹名字</code>]  —mkdir dir</h5><h5 id="4-删除当前指定的目录-语法-rd-路径-–remove-123"><a href="#4-删除当前指定的目录-语法-rd-路径-–remove-123" class="headerlink" title="4. 删除当前指定的目录[语法:rd 路径]   –remove 123"></a>4. 删除当前指定的目录[语法:<code>rd 路径</code>]   –remove 123</h5><h5 id="5-创建文件-echo-a-gt-a-txt"><a href="#5-创建文件-echo-a-gt-a-txt" class="headerlink" title="5. 创建文件 echo a> a.txt"></a>5. 创建文件 <code>echo a&gt; a.txt</code></h5><h5 id="6-文件复制命令-语法-copy-源文件路径-目标文件路径"><a href="#6-文件复制命令-语法-copy-源文件路径-目标文件路径" class="headerlink" title="6. 文件复制命令[语法: copy 源文件路径 目标文件路径]"></a>6. 文件复制命令[语法: <code>copy 源文件路径 目标文件路径</code>]</h5><p>   <img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_5.png" alt="1586912287262"></p>
<p>   执行效果相同</p>
<h5 id="7-显示文本文件内容命令-语法-type-文件名"><a href="#7-显示文本文件内容命令-语法-type-文件名" class="headerlink" title="7. 显示文本文件内容命令[语法: type 文件名]"></a>7. 显示文本文件内容命令[语法: <code>type 文件名</code>]</h5><h5 id="8-更改文件名命令-语法-ren-a-txt-a1-txt"><a href="#8-更改文件名命令-语法-ren-a-txt-a1-txt" class="headerlink" title="8. 更改文件名命令[语法: ren a.txt a1.txt]"></a>8. 更改文件名命令[语法: <code>ren a.txt a1.txt</code>]</h5><h5 id="9-删除文件命令-语法-del-a-txt-a1-txt-note-stuck-out-tongue-同时删除2个"><a href="#9-删除文件命令-语法-del-a-txt-a1-txt-note-stuck-out-tongue-同时删除2个" class="headerlink" title="9. 删除文件命令[语法: del a.txt a1.txt]  note :stuck_out_tongue:  同时删除2个"></a>9. 删除文件命令[语法: <code>del a.txt a1.txt</code>]  note <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f61b.png?v8">😛</span>  同时删除2个</h5><h5 id="10-清除屏幕命令-cls"><a href="#10-清除屏幕命令-cls" class="headerlink" title="10. 清除屏幕命令 cls"></a>10. 清除屏幕命令 <code>cls</code></h5><h5 id="11-改变当前盘符命令d"><a href="#11-改变当前盘符命令d" class="headerlink" title="11. 改变当前盘符命令d:"></a>11. 改变当前盘符命令d:</h5><h5 id="12-查看环境变量path-or-echo-path"><a href="#12-查看环境变量path-or-echo-path" class="headerlink" title="12. 查看环境变量path  or  echo %path%"></a>12. 查看环境变量<code>path</code>  or  echo %path%</h5><h3 id="3-Java-开发环境的准备"><a href="#3-Java-开发环境的准备" class="headerlink" title="3.Java 开发环境的准备"></a>3.Java 开发环境的准备</h3><h4 id="1-Java语言发展史"><a href="#1-Java语言发展史" class="headerlink" title="1. Java语言发展史"></a>1. Java语言发展史</h4><ul>
<li>詹姆斯.高斯林(James Gosling) 1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得 了<code>美国卡内基梅隆大学</code>计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统， 但不受重视。后来转至Sun公司，1990年， 与Patrick, Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak” ，后改名为Java。</li>
<li>SUN (Stanford Uni versity Network, 斯坦福大学网络公司)</li>
<li>卡内基梅隆大学截至2017年卡耐基梅隆大学共培养出了12个图灵奖，20个诺贝尔奖，9个奥斯卡，114个艾米奖，44个托尼奖，非常牛逼的大学。</li>
<li>Java是一 门软件编程语言，可编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等</li>
<li>早期Sun公司研发 人员对C++进行改造，开发了一种称为Oak的面向对象语言</li>
<li>1995年，Sun公司将Oak更名为Java</li>
<li>1996年，Sun公司发布了Java的第一个开发工具包(JDK1.0)</li>
<li>1998年，第二代Java平台的企业版J2EE发布</li>
<li>1999年公司发布了第二代Java平台(简称为Java2)的3个版本<br>J2ME (Java2 Micro Edition, Java2平 台的微型版)，应用于移动、无线及有限资源的环境;<br>J2SE (Java 2 Standard Edition, Java 2平台的标准版)，应用于桌面环境;<br>J2EE (Java 2Enterprise Edition, Java 2平台的企业版)，应用于基于Java的应用服务器。</li>
<li>Java 2平台的发布，是Java发展过程中最重要的一个里程碑，标志着Java的应用开始普及。</li>
<li>2009年，甲骨文公司宣布收购Sun。</li>
<li>2010年，Java编程语言的共同创始人之一詹姆斯.高斯林(Java之父)从Oracle公司辞职。</li>
<li>2011年，甲骨文公司举行了全球性的活动，以庆祝Java7的推出，随后Java7正式发布。</li>
<li>2014年，甲骨文公司发布了Java8正式版。</li>
<li>2017年，甲骨文公司发布了Java9</li>
</ul>
<h4 id="2-Java语言版本"><a href="#2-Java语言版本" class="headerlink" title="2. Java语言版本"></a>2. Java语言版本</h4><p>   <img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_6.png" alt="1586911661427"></p>
<p>老版本稳定，追求稳定</p>
<h4 id="3-Java语言特点"><a href="#3-Java语言特点" class="headerlink" title="3. Java语言特点"></a>3. Java语言特点</h4><p>​        简单性、解释性、<code>面向对象</code>、<code>高性能</code>、分布式处理、多线程、健壮性、动态性、<code>安全性</code>、<code>跨平台</code>、移植性<br>注:这是一道笔记题，需要记住</p>
<h4 id="4-Java语言跨平台原理"><a href="#4-Java语言跨平台原理" class="headerlink" title="4. Java语言跨平台原理"></a>4. Java语言跨平台原理</h4><h5 id="4-1-什么是跨平台性"><a href="#4-1-什么是跨平台性" class="headerlink" title="4.1 什么是跨平台性"></a>4.1 什么是跨平台性</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">开发的软件在任何操作系统(mac/window/linux)上都能安装并运行</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-2-Java语言跨平台原理"><a href="#4-2-Java语言跨平台原理" class="headerlink" title="4.2 Java语言跨平台原理"></a>4.2 Java语言跨平台原理</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。</span><br></pre></td></tr></tbody></table></figure>

<h5 id="4-3-Java语言跨平台图解"><a href="#4-3-Java语言跨平台图解" class="headerlink" title="4.3 Java语言跨平台图解"></a>4.3 Java语言跨平台图解</h5><p><img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_7.png" alt="1586911661427"></p>
<h5 id="4-4-write-once-，run-anywhere-一处编译-到处运行"><a href="#4-4-write-once-，run-anywhere-一处编译-到处运行" class="headerlink" title="4.4 write once ，run anywhere!(一处编译,到处运行)"></a>4.4 write once ，run anywhere!(一处编译,到处运行)</h5><h4 id="5-JRE和JDK的概述"><a href="#5-JRE和JDK的概述" class="headerlink" title="5. JRE和JDK的概述"></a>5. JRE和JDK的概述</h4><h5 id="5-1-什么是JRE-Java-Runtime-Environment"><a href="#5-1-什么是JRE-Java-Runtime-Environment" class="headerlink" title="5.1 什么是JRE (Java Runtime Environment)"></a>5.1 什么是JRE (Java Runtime Environment)</h5><ul>
<li>JRE包括Java虛拟机(JVM Java Virtual Machine)和Java程序所需的核心类库(jar 包)等</li>
<li>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。（java-&gt;jar）</li>
<li>总的说JRE = JVM +核心类库</li>
</ul>
<h5 id="5-2-什么是JDK-Java-Development-Kit"><a href="#5-2-什么是JDK-Java-Development-Kit" class="headerlink" title="5.2 什么是JDK (Java Development Kit)"></a>5.2 什么是JDK (Java Development Kit)</h5><ul>
<li>JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。</li>
<li><code>所以安装了JDK,就不用在单独安装JRE了</code>。</li>
<li>java的开发工具有:<code>编译工具(javac)</code>、 <code>打包工具(jar)</code>等</li>
<li>JDK=JRE+JAVA的开发工具。</li>
<li>JDK=JVM+核心类库+ Java开发工具(javac, jar..)</li>
</ul>
<h5 id="5-3-JDK-JRE-JVM的作用和关系"><a href="#5-3-JDK-JRE-JVM的作用和关系" class="headerlink" title="5.3 JDK, JRE, JVM的作用和关系"></a>5.3 JDK, JRE, JVM的作用和关系</h5><p>  JDK包含JRE，而JRE包含JVM， 总的来说JDK是用于java程序的开发，而jre则是只</p>
<h5 id="5-4-能运行class而没有编译的功能，最后用张网络图片总结下"><a href="#5-4-能运行class而没有编译的功能，最后用张网络图片总结下" class="headerlink" title="5.4 能运行class而没有编译的功能，最后用张网络图片总结下"></a>5.4 能运行class而没有编译的功能，最后用张网络图片总结下</h5><p> <img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_8.png" alt="1586911661427"></p>
<ul>
<li>总结:<br>JDK:主要用于编译<br>JRE:主要作用看运行效果<br>JVM:主要作用跨平台，负责Java程序的调用</li>
</ul>
<h4 id="6-JDK的下载和安装过程图解"><a href="#6-JDK的下载和安装过程图解" class="headerlink" title="6. JDK的下载和安装过程图解"></a>6. JDK的下载和安装过程图解</h4><h5 id="6-1-JDK的下载地址"><a href="#6-1-JDK的下载地址" class="headerlink" title="6.1 JDK的下载地址"></a>6.1 JDK的下载地址</h5><ul>
<li><code>https://www.oracle.com/java/technologies/javase-downloads.html</code></li>
<li>Sun被oracle收购，地址都可以，访问sun会跳转到oracle</li>
</ul>
<h5 id="6-2-JDK的安装"><a href="#6-2-JDK的安装" class="headerlink" title="6.2 JDK的安装"></a>6.2 JDK的安装</h5><p>  下载对应操作系统平台的JDK,这里下载1.8的windows平台然后傻瓜式安装，下一步下一步<br>  验证安装是否成功</p>
<ul>
<li><p>如果安装 了JDK, JDK的安装路径在C: \Program Files\Java\jdk1.8.0_ 131路径下</p>
</li>
<li><p>在cmd中可以输入java -version来查看jdk的版本</p>
<p>可安装共存:1.7和 1.8 共存</p>
</li>
</ul>
<h4 id="7-JDK的删除和自定义安装路径"><a href="#7-JDK的删除和自定义安装路径" class="headerlink" title="7. JDK的删除和自定义安装路径"></a>7. JDK的删除和自定义安装路径</h4><ol>
<li>删除JDK不能直接把Java的home目录文件夹删除了，这种操作是不正确</li>
<li>正确的删除JDK是要来到 “ 控制面板\所有控制面板项\程序和功能”进行删除，</li>
<li>JDK安装路径可以自己定义， 个人喜好，我就不喜欢改。</li>
<li>什么时候需要更改jdk的安装路径<br>■当默认的c盘没有空 间的时候，可以改成D盘</li>
</ol>
<h4 id="8-JDK安装路径下的目录解释"><a href="#8-JDK安装路径下的目录解释" class="headerlink" title="8. JDK安装路径下的目录解释"></a>8. JDK安装路径下的目录解释</h4><ul>
<li>在jdk的Home中，会有如下图的结构<br><img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_9.png" alt="1586911661427"><ul>
<li>Home 目录路径C: \Program Fi les\JavaXjdk1.8.0131,又称jdk主目录<ul>
<li>bin:该目录用于存放一些可执行程序，如javac ( java编译器)、java(java运行 工具)，jar(打包工具)和javadoc(文档生成工具)等</li>
<li>db:db目录是一个小型的数据库，从JDK 6. 0开始，Java中引用了一个新的成员JavaDB, 这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4. 0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。</li>
<li>jre: “jre”是Java Runt ime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及-个bin目录，但不包含开发环境中的开发工具。</li>
<li>include: 由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。</li>
<li>1ib: 1ib是1ibrary的缩写， 意为Java 类库或库文件，是开发工具使用的归档包文件。</li>
<li>src. zip文件: src. zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码， 通过该文件可以查看Java基础类的源代码。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-第一个Java程序，-Hel-loWord案例的编写与编译-命令行方式"><a href="#9-第一个Java程序，-Hel-loWord案例的编写与编译-命令行方式" class="headerlink" title="9.第一个Java程序， Hel loWord案例的编写与编译(命令行方式)"></a>9.第一个Java程序， Hel loWord案例的编写与编译(命令行方式)</h4><ul>
<li><p>编写Java源代码，以.java结尾<br><img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_10.png" alt="1586911661427"></p>
</li>
<li><p>打开终端cmd,进入到jdk的bin目录，cd “C:\ Program Files\Java\jdk1.8.0_ 131\bin”</p>
</li>
<li><p>编译java文件，终端中输入javac HelloWorld.java的全路径</p>
</li>
<li><p>执行class文件,终端输入java HelloWorld,不需要加.class后缀<br>Java程序运行流程[记住]<br>①编写java文件<br>②编译java文件，获得一个.class文件<br>③运行.class文件 看到效果</p>
</li>
<li><p>遇到问题</p>
<p><img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_11.png" alt="1586920600288"></p>
</li>
</ul>
<h4 id="10-Javac-amp-Java命令执行的路径"><a href="#10-Javac-amp-Java命令执行的路径" class="headerlink" title="10. Javac&amp;Java命令执行的路径"></a>10. Javac&amp;Java命令执行的路径</h4><ul>
<li>Javac是一个将. java编译成. class文件命令</li>
<li>javac命令的具体路径是C: \Program Files\Java\jdk1. 8.0_ 131bin</li>
<li>在终端cmd输入java - version, Java的命令执行的路径是在Path的<br>C: \PrbgramData \0racl e\Java\javapath</li>
<li>如果在命令行执行javac HelloWorld. java 返回‘javac’ 不是内部或外部命令，也不是可运行的程序，或批处理文件。说明在当前路径找不到Javac命令</li>
</ul>
<h4 id="11-Java环境变量Path配置"><a href="#11-Java环境变量Path配置" class="headerlink" title="11. Java环境变量Path配置"></a>11. Java环境变量Path配置</h4><ul>
<li>目的: 不需要进入到bin目录，也可执行bin目录下的命令javac</li>
<li>方法步骤- windows10的操作:</li>
</ul>
<ol>
<li>点击:此电脑-右键属性-高级系统设置-高级-环境变量</li>
<li>在系统变量中新建JAVA_ HOME=C: \Program Files\Java\jdk1.8.0_ 131</li>
<li>在系统变量中编辑Path,在后面追加路径%JAVA_ HOME%\bin (注:是右斜杠)</li>
<li>在命令行可以输入echo %JAVA HOME%\bin 来查看环境变量</li>
</ol>
<ul>
<li>通过上面的努力， 你就可以在任意目录编译. java文件了<br>MacOs：  .bash_profile</li>
</ul>
<h4 id="12-CLASSPATH变量配置"><a href="#12-CLASSPATH变量配置" class="headerlink" title="12. CLASSPATH变量配置"></a>12. CLASSPATH变量配置</h4><ul>
<li>jvm在 查找class文件时如果没有设置classpath会在当前路径查找，设置classpath后<code>仅在classpath路径下</code>查找class文件即可。</li>
<li>classpath 不是必须配置的</li>
<li>一旦修改了环境变量的东西，一定要重新启动cmd命令行<br>echo %classpath%<br>补: cd.. 切换到上一个路径</li>
</ul>
<h3 id="4-Java开发工具Eclipse"><a href="#4-Java开发工具Eclipse" class="headerlink" title="4. Java开发工具Eclipse"></a>4. Java开发工具Eclipse</h3><h4 id="1-常用的Java-IDE开发工具"><a href="#1-常用的Java-IDE开发工具" class="headerlink" title="1. 常用的Java IDE开发工具"></a>1. 常用的Java IDE开发工具</h4><ul>
<li>为什么会有Java IDE开发工具，如果像以前那样在终端通过命令行来编译执行java文件，一旦<br>文件比较多，是件多么折腾的一件事。所以有很多开发工具，来简化我们的开发工作。</li>
<li>集成开发环境(IDE， Integrated Deve lopment Environment )是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。</li>
<li>常见的Java开发工具有，工作中掌握Eclipse即可<br>①Editplus 少<br>②Sublime Text  少<br>③Eclipse (工作中常用，200多M)  免费<br>④MyEclipse(至 少1G)<br>⑤IntelliJ IDEA (500多M)  多</li>
<li>注:掌握了Eclipse, MyEclipse, IDEA也自然会用，因为他们长的两差不多</li>
</ul>
<h4 id="2-Eclipse历史版本-Neon"><a href="#2-Eclipse历史版本-Neon" class="headerlink" title="2. Eclipse历史版本  Neon"></a>2. Eclipse历史版本  Neon</h4><p> <img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_12.png" alt="1586920600288"></p>
<h4 id="3-Eclipse的下载与安装"><a href="#3-Eclipse的下载与安装" class="headerlink" title="3. Eclipse的下载与安装"></a>3. Eclipse的下载与安装</h4><ul>
<li>进入eclipse的 下载页面<code>https://www.eclipse.org/downloads/packages/</code></li>
<li>然后在页面中，选择红色框的下载，下载后得到一个eclipse-jee neon-3-win32-<br>x86_ 64.zip文 件</li>
<li>然后解压zip,直接点击解压后文件夹中的eclipse.exe即可使用 -&gt;发送快捷方式<br>注意:下载Eclipse-Neon的版本，一定要安装jdk1.8<br>现在最新版本是eclipse-jee -oxygen-1a-win32 x86_ 64.zip [oxygen:氧气 ]<br>建议项目名格式 wzq_day01_20170206</li>
</ul>
<h4 id="3-Eclipse的区域与字体调整"><a href="#3-Eclipse的区域与字体调整" class="headerlink" title="3. Eclipse的区域与字体调整"></a>3. Eclipse的区域与字体调整</h4><p> <img src="/2016/06/24/2016-06-24-wei-shi-me-xue-xi-java-yi-ji-zen-me-xue-xi-java/1_14.png" alt="1586920600288"></p>
<ul>
<li>调整Eclipse的字体大小<ul>
<li>第一种方式:<ul>
<li>点击Eclipse的Window Prefernces偏好设置，</li>
<li>找到General-Appearance Colors and Fonts. 再找到Basic </li>
<li>然后点击Text Font来 调字体大小</li>
</ul>
</li>
<li>第二种方式:<ul>
<li>neon<br>版本的eclipse可以通过[ctrl +、-]来更改文字大小<br>注:有些旧版本不支持这种方式，所以只能使用第一种</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-项目的导入和删除"><a href="#4-项目的导入和删除" class="headerlink" title="4.项目的导入和删除"></a>4.项目的导入和删除</h4><p>Project Explorer 下 选择 import -&gt;General-&gt;Existing Projects into Workspace</p>
<p>注释 ctrl+shift+/<br>ctrl+/</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>DOS命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2016/06/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
</search>
